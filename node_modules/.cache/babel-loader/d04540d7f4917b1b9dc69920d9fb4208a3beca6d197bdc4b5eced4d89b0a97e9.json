{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseDict = void 0;\nfunction readUnaryLength(slice) {\n  let res = 0;\n  while (slice.loadBit()) {\n    res++;\n  }\n  return res;\n}\nfunction doParse(prefix, slice, n, res, extractor) {\n  // Reading label\n  let lb0 = slice.loadBit() ? 1 : 0;\n  let prefixLength = 0;\n  let pp = prefix;\n  if (lb0 === 0) {\n    // Short label detected\n    // Read \n    prefixLength = readUnaryLength(slice);\n    // Read prefix\n    for (let i = 0; i < prefixLength; i++) {\n      pp += slice.loadBit() ? '1' : '0';\n    }\n  } else {\n    let lb1 = slice.loadBit() ? 1 : 0;\n    if (lb1 === 0) {\n      // Long label detected\n      prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n      for (let i = 0; i < prefixLength; i++) {\n        pp += slice.loadBit() ? '1' : '0';\n      }\n    } else {\n      // Same label detected\n      let bit = slice.loadBit() ? '1' : '0';\n      prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n      for (let i = 0; i < prefixLength; i++) {\n        pp += bit;\n      }\n    }\n  }\n  if (n - prefixLength === 0) {\n    res.set(BigInt('0b' + pp), extractor(slice));\n  } else {\n    let left = slice.loadRef();\n    let right = slice.loadRef();\n    // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'\n    if (!left.isExotic) {\n      doParse(pp + '0', left.beginParse(), n - prefixLength - 1, res, extractor);\n    }\n    if (!right.isExotic) {\n      doParse(pp + '1', right.beginParse(), n - prefixLength - 1, res, extractor);\n    }\n  }\n}\nfunction parseDict(sc, keySize, extractor) {\n  let res = new Map();\n  if (sc) {\n    doParse('', sc, keySize, res, extractor);\n  }\n  return res;\n}\nexports.parseDict = parseDict;","map":{"version":3,"names":["Object","defineProperty","exports","value","parseDict","readUnaryLength","slice","res","loadBit","doParse","prefix","n","extractor","lb0","prefixLength","pp","i","lb1","loadUint","Math","ceil","log2","bit","set","BigInt","left","loadRef","right","isExotic","beginParse","sc","keySize","Map"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/dict/parseDict.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseDict = void 0;\nfunction readUnaryLength(slice) {\n    let res = 0;\n    while (slice.loadBit()) {\n        res++;\n    }\n    return res;\n}\nfunction doParse(prefix, slice, n, res, extractor) {\n    // Reading label\n    let lb0 = slice.loadBit() ? 1 : 0;\n    let prefixLength = 0;\n    let pp = prefix;\n    if (lb0 === 0) {\n        // Short label detected\n        // Read \n        prefixLength = readUnaryLength(slice);\n        // Read prefix\n        for (let i = 0; i < prefixLength; i++) {\n            pp += slice.loadBit() ? '1' : '0';\n        }\n    }\n    else {\n        let lb1 = slice.loadBit() ? 1 : 0;\n        if (lb1 === 0) {\n            // Long label detected\n            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n            for (let i = 0; i < prefixLength; i++) {\n                pp += slice.loadBit() ? '1' : '0';\n            }\n        }\n        else {\n            // Same label detected\n            let bit = slice.loadBit() ? '1' : '0';\n            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n            for (let i = 0; i < prefixLength; i++) {\n                pp += bit;\n            }\n        }\n    }\n    if (n - prefixLength === 0) {\n        res.set(BigInt('0b' + pp), extractor(slice));\n    }\n    else {\n        let left = slice.loadRef();\n        let right = slice.loadRef();\n        // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'\n        if (!left.isExotic) {\n            doParse(pp + '0', left.beginParse(), n - prefixLength - 1, res, extractor);\n        }\n        if (!right.isExotic) {\n            doParse(pp + '1', right.beginParse(), n - prefixLength - 1, res, extractor);\n        }\n    }\n}\nfunction parseDict(sc, keySize, extractor) {\n    let res = new Map();\n    if (sc) {\n        doParse('', sc, keySize, res, extractor);\n    }\n    return res;\n}\nexports.parseDict = parseDict;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}