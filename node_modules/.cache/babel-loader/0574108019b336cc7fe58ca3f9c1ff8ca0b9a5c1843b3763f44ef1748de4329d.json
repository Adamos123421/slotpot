{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitString = void 0;\nconst paddedBits_1 = require(\"./utils/paddedBits\");\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\n/**\n * BitString is a class that represents a bitstring in a buffer with a specified offset and length\n */\nclass BitString {\n  /**\n   * Checks if supplied object is BitString\n   * @param src is unknow object\n   * @returns true if object is BitString and false otherwise\n   **/\n  static isBitString(src) {\n    return src instanceof BitString;\n  }\n  /**\n   * Constructing BitString from a buffer\n   * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified\n   * @param offset offset in bits from the start of the buffer\n   * @param length length of the bitstring in bits\n   */\n  constructor(data, offset, length) {\n    this[_a] = () => this.toString();\n    // Check bounds\n    if (length < 0) {\n      throw new Error(\"Length \".concat(length, \" is out of bounds\"));\n    }\n    this._length = length;\n    this._data = data;\n    this._offset = offset;\n  }\n  /**\n   * Returns the length of the bitstring\n   */\n  get length() {\n    return this._length;\n  }\n  /**\n   * Returns the bit at the specified index\n   * @param index index of the bit\n   * @throws Error if index is out of bounds\n   * @returns true if the bit is set, false otherwise\n   */\n  at(index) {\n    // Check bounds\n    if (index >= this._length) {\n      throw new Error(\"Index \".concat(index, \" > \").concat(this._length, \" is out of bounds\"));\n    }\n    if (index < 0) {\n      throw new Error(\"Index \".concat(index, \" < 0 is out of bounds\"));\n    }\n    // Calculcate offsets\n    let byteIndex = this._offset + index >> 3;\n    let bitIndex = 7 - (this._offset + index) % 8; // NOTE: We are using big endian\n    // Return the bit\n    return (this._data[byteIndex] & 1 << bitIndex) !== 0;\n  }\n  /**\n   * Get a subscring of the bitstring\n   * @param offset\n   * @param length\n   * @returns\n   */\n  substring(offset, length) {\n    // Check offset\n    if (offset > this._length) {\n      throw new Error(\"Offset(\".concat(offset, \") > \").concat(this._length, \" is out of bounds\"));\n    }\n    if (offset < 0) {\n      throw new Error(\"Offset(\".concat(offset, \") < 0 is out of bounds\"));\n    }\n    // Corner case of empty string\n    if (length === 0) {\n      return BitString.EMPTY;\n    }\n    if (offset + length > this._length) {\n      throw new Error(\"Offset \".concat(offset, \" + Length \").concat(length, \" > \").concat(this._length, \" is out of bounds\"));\n    }\n    // Create substring\n    return new BitString(this._data, this._offset + offset, length);\n  }\n  /**\n   * Try to get a buffer from the bitstring without allocations\n   * @param offset offset in bits\n   * @param length length in bits\n   * @returns buffer if the bitstring is aligned to bytes, null otherwise\n   */\n  subbuffer(offset, length) {\n    // Check offset\n    if (offset > this._length) {\n      throw new Error(\"Offset \".concat(offset, \" is out of bounds\"));\n    }\n    if (offset < 0) {\n      throw new Error(\"Offset \".concat(offset, \" is out of bounds\"));\n    }\n    if (offset + length > this._length) {\n      throw new Error(\"Offset + Lenght = \".concat(offset + length, \" is out of bounds\"));\n    }\n    // Check alignment\n    if (length % 8 !== 0) {\n      return null;\n    }\n    if ((this._offset + offset) % 8 !== 0) {\n      return null;\n    }\n    // Create substring\n    let start = this._offset + offset >> 3;\n    let end = start + (length >> 3);\n    return this._data.subarray(start, end);\n  }\n  /**\n   * Checks for equality\n   * @param b other bitstring\n   * @returns true if the bitstrings are equal, false otherwise\n   */\n  equals(b) {\n    if (this._length !== b._length) {\n      return false;\n    }\n    for (let i = 0; i < this._length; i++) {\n      if (this.at(i) !== b.at(i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Format to canonical string\n   * @returns formatted bits as a string\n   */\n  toString() {\n    const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);\n    if (this._length % 4 === 0) {\n      const s = padded.subarray(0, Math.ceil(this._length / 8)).toString('hex').toUpperCase();\n      if (this._length % 8 === 0) {\n        return s;\n      } else {\n        return s.substring(0, s.length - 1);\n      }\n    } else {\n      const hex = padded.toString('hex').toUpperCase();\n      if (this._length % 8 <= 4) {\n        return hex.substring(0, hex.length - 1) + '_';\n      } else {\n        return hex + '_';\n      }\n    }\n  }\n}\nexports.BitString = BitString;\n_a = symbol_inspect_1.default;\nBitString.EMPTY = new BitString(Buffer.alloc(0), 0, 0);","map":{"version":3,"names":["__importDefault","mod","__esModule","_a","Object","defineProperty","exports","value","BitString","paddedBits_1","require","symbol_inspect_1","isBitString","src","constructor","data","offset","length","toString","Error","concat","_length","_data","_offset","at","index","byteIndex","bitIndex","substring","EMPTY","subbuffer","start","end","subarray","equals","b","i","padded","bitsToPaddedBuffer","s","Math","ceil","toUpperCase","hex","default","Buffer","alloc"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/boc/BitString.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitString = void 0;\nconst paddedBits_1 = require(\"./utils/paddedBits\");\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\n/**\n * BitString is a class that represents a bitstring in a buffer with a specified offset and length\n */\nclass BitString {\n    /**\n     * Checks if supplied object is BitString\n     * @param src is unknow object\n     * @returns true if object is BitString and false otherwise\n     **/\n    static isBitString(src) {\n        return src instanceof BitString;\n    }\n    /**\n     * Constructing BitString from a buffer\n     * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified\n     * @param offset offset in bits from the start of the buffer\n     * @param length length of the bitstring in bits\n     */\n    constructor(data, offset, length) {\n        this[_a] = () => this.toString();\n        // Check bounds\n        if (length < 0) {\n            throw new Error(`Length ${length} is out of bounds`);\n        }\n        this._length = length;\n        this._data = data;\n        this._offset = offset;\n    }\n    /**\n     * Returns the length of the bitstring\n     */\n    get length() {\n        return this._length;\n    }\n    /**\n     * Returns the bit at the specified index\n     * @param index index of the bit\n     * @throws Error if index is out of bounds\n     * @returns true if the bit is set, false otherwise\n     */\n    at(index) {\n        // Check bounds\n        if (index >= this._length) {\n            throw new Error(`Index ${index} > ${this._length} is out of bounds`);\n        }\n        if (index < 0) {\n            throw new Error(`Index ${index} < 0 is out of bounds`);\n        }\n        // Calculcate offsets\n        let byteIndex = (this._offset + index) >> 3;\n        let bitIndex = 7 - ((this._offset + index) % 8); // NOTE: We are using big endian\n        // Return the bit\n        return (this._data[byteIndex] & (1 << bitIndex)) !== 0;\n    }\n    /**\n     * Get a subscring of the bitstring\n     * @param offset\n     * @param length\n     * @returns\n     */\n    substring(offset, length) {\n        // Check offset\n        if (offset > this._length) {\n            throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);\n        }\n        if (offset < 0) {\n            throw new Error(`Offset(${offset}) < 0 is out of bounds`);\n        }\n        // Corner case of empty string\n        if (length === 0) {\n            return BitString.EMPTY;\n        }\n        if (offset + length > this._length) {\n            throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);\n        }\n        // Create substring\n        return new BitString(this._data, this._offset + offset, length);\n    }\n    /**\n     * Try to get a buffer from the bitstring without allocations\n     * @param offset offset in bits\n     * @param length length in bits\n     * @returns buffer if the bitstring is aligned to bytes, null otherwise\n     */\n    subbuffer(offset, length) {\n        // Check offset\n        if (offset > this._length) {\n            throw new Error(`Offset ${offset} is out of bounds`);\n        }\n        if (offset < 0) {\n            throw new Error(`Offset ${offset} is out of bounds`);\n        }\n        if (offset + length > this._length) {\n            throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);\n        }\n        // Check alignment\n        if (length % 8 !== 0) {\n            return null;\n        }\n        if ((this._offset + offset) % 8 !== 0) {\n            return null;\n        }\n        // Create substring\n        let start = ((this._offset + offset) >> 3);\n        let end = start + (length >> 3);\n        return this._data.subarray(start, end);\n    }\n    /**\n     * Checks for equality\n     * @param b other bitstring\n     * @returns true if the bitstrings are equal, false otherwise\n     */\n    equals(b) {\n        if (this._length !== b._length) {\n            return false;\n        }\n        for (let i = 0; i < this._length; i++) {\n            if (this.at(i) !== b.at(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Format to canonical string\n     * @returns formatted bits as a string\n     */\n    toString() {\n        const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);\n        if (this._length % 4 === 0) {\n            const s = padded.subarray(0, Math.ceil(this._length / 8)).toString('hex').toUpperCase();\n            if (this._length % 8 === 0) {\n                return s;\n            }\n            else {\n                return s.substring(0, s.length - 1);\n            }\n        }\n        else {\n            const hex = padded.toString('hex').toUpperCase();\n            if (this._length % 8 <= 4) {\n                return hex.substring(0, hex.length - 1) + '_';\n            }\n            else {\n                return hex + '_';\n            }\n        }\n    }\n}\nexports.BitString = BitString;\n_a = symbol_inspect_1.default;\nBitString.EMPTY = new BitString(Buffer.alloc(0), 0, 0);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}