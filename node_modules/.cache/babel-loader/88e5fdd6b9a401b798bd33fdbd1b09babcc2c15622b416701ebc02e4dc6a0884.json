{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveExotic = void 0;\nconst BitReader_1 = require(\"../BitReader\");\nconst CellType_1 = require(\"../CellType\");\nconst exoticLibrary_1 = require(\"./exoticLibrary\");\nconst exoticMerkleProof_1 = require(\"./exoticMerkleProof\");\nconst exoticMerkleUpdate_1 = require(\"./exoticMerkleUpdate\");\nconst exoticPruned_1 = require(\"./exoticPruned\");\nconst LevelMask_1 = require(\"./LevelMask\");\nfunction resolvePruned(bits, refs) {\n  // Parse pruned cell\n  let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);\n  // Calculate parameters\n  let depths = [];\n  let hashes = [];\n  let mask = new LevelMask_1.LevelMask(pruned.mask);\n  for (let i = 0; i < pruned.pruned.length; i++) {\n    depths.push(pruned.pruned[i].depth);\n    hashes.push(pruned.pruned[i].hash);\n  }\n  return {\n    type: CellType_1.CellType.PrunedBranch,\n    depths,\n    hashes,\n    mask\n  };\n}\nfunction resolveLibrary(bits, refs) {\n  // Parse library cell\n  let pruned = (0, exoticLibrary_1.exoticLibrary)(bits, refs);\n  // Calculate parameters\n  let depths = [];\n  let hashes = [];\n  let mask = new LevelMask_1.LevelMask();\n  return {\n    type: CellType_1.CellType.Library,\n    depths,\n    hashes,\n    mask\n  };\n}\nfunction resolveMerkleProof(bits, refs) {\n  // Parse merkle proof cell\n  let merkleProof = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);\n  // Calculate parameters\n  let depths = [];\n  let hashes = [];\n  let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);\n  return {\n    type: CellType_1.CellType.MerkleProof,\n    depths,\n    hashes,\n    mask\n  };\n}\nfunction resolveMerkleUpdate(bits, refs) {\n  // Parse merkle proof cell\n  let merkleUpdate = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);\n  // Calculate parameters\n  let depths = [];\n  let hashes = [];\n  let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);\n  return {\n    type: CellType_1.CellType.MerkleUpdate,\n    depths,\n    hashes,\n    mask\n  };\n}\nfunction resolveExotic(bits, refs) {\n  let reader = new BitReader_1.BitReader(bits);\n  let type = reader.preloadUint(8);\n  if (type === 1) {\n    return resolvePruned(bits, refs);\n  }\n  if (type === 2) {\n    return resolveLibrary(bits, refs);\n  }\n  if (type === 3) {\n    return resolveMerkleProof(bits, refs);\n  }\n  if (type === 4) {\n    return resolveMerkleUpdate(bits, refs);\n  }\n  throw Error('Invalid exotic cell type: ' + type);\n}\nexports.resolveExotic = resolveExotic;","map":{"version":3,"names":["Object","defineProperty","exports","value","resolveExotic","BitReader_1","require","CellType_1","exoticLibrary_1","exoticMerkleProof_1","exoticMerkleUpdate_1","exoticPruned_1","LevelMask_1","resolvePruned","bits","refs","pruned","exoticPruned","depths","hashes","mask","LevelMask","i","length","push","depth","hash","type","CellType","PrunedBranch","resolveLibrary","exoticLibrary","Library","resolveMerkleProof","merkleProof","exoticMerkleProof","level","MerkleProof","resolveMerkleUpdate","merkleUpdate","exoticMerkleUpdate","MerkleUpdate","reader","BitReader","preloadUint","Error"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/boc/cell/resolveExotic.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveExotic = void 0;\nconst BitReader_1 = require(\"../BitReader\");\nconst CellType_1 = require(\"../CellType\");\nconst exoticLibrary_1 = require(\"./exoticLibrary\");\nconst exoticMerkleProof_1 = require(\"./exoticMerkleProof\");\nconst exoticMerkleUpdate_1 = require(\"./exoticMerkleUpdate\");\nconst exoticPruned_1 = require(\"./exoticPruned\");\nconst LevelMask_1 = require(\"./LevelMask\");\nfunction resolvePruned(bits, refs) {\n    // Parse pruned cell\n    let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);\n    // Calculate parameters\n    let depths = [];\n    let hashes = [];\n    let mask = new LevelMask_1.LevelMask(pruned.mask);\n    for (let i = 0; i < pruned.pruned.length; i++) {\n        depths.push(pruned.pruned[i].depth);\n        hashes.push(pruned.pruned[i].hash);\n    }\n    return {\n        type: CellType_1.CellType.PrunedBranch,\n        depths,\n        hashes,\n        mask\n    };\n}\nfunction resolveLibrary(bits, refs) {\n    // Parse library cell\n    let pruned = (0, exoticLibrary_1.exoticLibrary)(bits, refs);\n    // Calculate parameters\n    let depths = [];\n    let hashes = [];\n    let mask = new LevelMask_1.LevelMask();\n    return {\n        type: CellType_1.CellType.Library,\n        depths,\n        hashes,\n        mask\n    };\n}\nfunction resolveMerkleProof(bits, refs) {\n    // Parse merkle proof cell\n    let merkleProof = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);\n    // Calculate parameters\n    let depths = [];\n    let hashes = [];\n    let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);\n    return {\n        type: CellType_1.CellType.MerkleProof,\n        depths,\n        hashes,\n        mask\n    };\n}\nfunction resolveMerkleUpdate(bits, refs) {\n    // Parse merkle proof cell\n    let merkleUpdate = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);\n    // Calculate parameters\n    let depths = [];\n    let hashes = [];\n    let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);\n    return {\n        type: CellType_1.CellType.MerkleUpdate,\n        depths,\n        hashes,\n        mask\n    };\n}\nfunction resolveExotic(bits, refs) {\n    let reader = new BitReader_1.BitReader(bits);\n    let type = reader.preloadUint(8);\n    if (type === 1) {\n        return resolvePruned(bits, refs);\n    }\n    if (type === 2) {\n        return resolveLibrary(bits, refs);\n    }\n    if (type === 3) {\n        return resolveMerkleProof(bits, refs);\n    }\n    if (type === 4) {\n        return resolveMerkleUpdate(bits, refs);\n    }\n    throw Error('Invalid exotic cell type: ' + type);\n}\nexports.resolveExotic = resolveExotic;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}