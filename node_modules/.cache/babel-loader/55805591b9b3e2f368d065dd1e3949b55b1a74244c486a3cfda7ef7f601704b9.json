{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nimport { jackpotContract } from '../services/jackpotContract';\nimport { backendApi } from '../services/backendApi';\nimport useTonConnect from './useTonConnect';\nimport socketService from '../services/socketService';\n\n// API polling removed - all data now comes via socket broadcasts\n\nconst useJackpotContract = () => {\n  _s();\n  var _contractState$timer2;\n  console.log('ðŸ”§ useJackpotContract hook initializing...');\n\n  // Contract state\n  const [contractState, setContractState] = useState({\n    totalJackpot: 0,\n    isActive: false,\n    betCount: 0,\n    lastWinner: null,\n    lastWinnerAddress: null,\n    lastPrizeAmount: 0,\n    contractBalance: 0,\n    timestamp: 0,\n    error: null,\n    // Winner detection\n    roundJustEnded: false,\n    hasWinner: false,\n    winnerAnnouncement: null,\n    // Timer information (now integrated)\n    timer: {\n      isActive: false,\n      timeRemaining: 0,\n      timeElapsed: 0,\n      roundNumber: 0\n    },\n    roundDuration: 300,\n    bettors: []\n  });\n\n  // Current round bettors\n  const [currentBettors, setCurrentBettors] = useState([]);\n\n  // Admin info now comes via socket in contract state\n\n  // User-specific state\n  const [userStats, setUserStats] = useState({\n    betAmount: 0,\n    winningProbability: 0,\n    winChancePercentage: '0.00',\n    loading: false,\n    error: null\n  });\n\n  // Loading states\n  const [isPlacingBet, setIsPlacingBet] = useState(false);\n  const [hasInitialLoad, setHasInitialLoad] = useState(false);\n\n  // Essential refs for hook functionality\n  const prevIsActiveRef = useRef(contractState.isActive);\n\n  // Get wallet connection status\n  const {\n    isConnected,\n    address,\n    sendTransaction,\n    isLoading: walletLoading,\n    isRestoringConnection\n  } = useTonConnect();\n\n  // REMOVED: All bettor and contract data now comes via socket broadcasts\n\n  // REMOVED: All contract state now comes via socket broadcasts\n\n  // REMOVED: All address tracking and API calls - now handled via socket broadcasts\n\n  // User stats refresh - handled in consolidated polling system\n  // Removed separate useEffect to prevent duplicate API calls\n  // This fixes the issue where APIs were being called 4 times simultaneously\n\n  // Track round changes with ref to prevent re-renders\n  useEffect(() => {\n    var _contractState$timer;\n    const prevIsActive = prevIsActiveRef.current;\n    const currentIsActive = contractState.isActive;\n\n    // Detect new round start (inactive -> active)\n    // But only clear bettors if timer > 0 (actual new round, not waiting for winner)\n    if (!prevIsActive && currentIsActive && ((_contractState$timer = contractState.timer) === null || _contractState$timer === void 0 ? void 0 : _contractState$timer.timeRemaining) > 0) {\n      console.log('ðŸ”„ New round detected, clearing bettors list');\n      setCurrentBettors([]); // Clear bettors list for new round\n    }\n\n    // Update ref for next comparison\n    prevIsActiveRef.current = currentIsActive;\n  }, [contractState.isActive, (_contractState$timer2 = contractState.timer) === null || _contractState$timer2 === void 0 ? void 0 : _contractState$timer2.timeRemaining]);\n\n  // REMOVED: All API polling - now handled entirely via socket broadcasts\n\n  // Socket handling for contract state updates (prevent re-initialization)\n  useEffect(() => {\n    // Import socket service\n    const {\n      default: socketService\n    } = require('../services/socketService');\n    console.log('ðŸ”§ Hook: Setting up socket listeners (should only happen once)');\n\n    // Listen for full game updates to sync contract state\n    const handleFullGameUpdate = gameData => {\n      console.log('ðŸ”§ Hook: Received full game update:', gameData);\n      setContractState(prevState => {\n        var _gameData$timer$isAct, _gameData$timer, _gameData$timer$timeR, _gameData$timer2, _gameData$timer$round, _gameData$timer3, _gameData$currentRoun;\n        return {\n          ...prevState,\n          ...gameData,\n          // Ensure timer data is preserved/updated\n          timer: {\n            ...prevState.timer,\n            ...gameData.timer,\n            // Fallback to direct properties if timer object doesn't exist\n            isActive: (_gameData$timer$isAct = (_gameData$timer = gameData.timer) === null || _gameData$timer === void 0 ? void 0 : _gameData$timer.isActive) !== null && _gameData$timer$isAct !== void 0 ? _gameData$timer$isAct : gameData.isActive,\n            timeRemaining: (_gameData$timer$timeR = (_gameData$timer2 = gameData.timer) === null || _gameData$timer2 === void 0 ? void 0 : _gameData$timer2.timeRemaining) !== null && _gameData$timer$timeR !== void 0 ? _gameData$timer$timeR : gameData.timeRemaining,\n            roundNumber: (_gameData$timer$round = (_gameData$timer3 = gameData.timer) === null || _gameData$timer3 === void 0 ? void 0 : _gameData$timer3.roundNumber) !== null && _gameData$timer$round !== void 0 ? _gameData$timer$round : (_gameData$currentRoun = gameData.currentRound) === null || _gameData$currentRoun === void 0 ? void 0 : _gameData$currentRoun.roundNumber\n          }\n        };\n      });\n\n      // Update bettors if included in game data\n      if (gameData.bettors && Array.isArray(gameData.bettors)) {\n        console.log('ðŸ”§ Hook: Updating bettors from game data:', gameData.bettors.length, 'bettors');\n        setCurrentBettors(gameData.bettors);\n      }\n    };\n    const handleContractUpdate = contractData => {\n      console.log('ðŸ”§ Hook: Received contract update:', contractData);\n      setContractState(prevState => ({\n        ...prevState,\n        ...contractData\n      }));\n    };\n    const handleBettorsUpdate = bettorsData => {\n      console.log('ðŸ”§ Hook: Received bettors update:', bettorsData);\n      if (bettorsData.bettors) {\n        setCurrentBettors(bettorsData.bettors);\n      }\n    };\n\n    // Set up listeners (removed gameState to avoid duplicates with App.js)\n    socketService.on('fullGameUpdate', handleFullGameUpdate);\n    socketService.on('contractStateUpdate', handleContractUpdate);\n    socketService.on('bettorsUpdate', handleBettorsUpdate);\n    return () => {\n      socketService.off('fullGameUpdate', handleFullGameUpdate);\n      socketService.off('contractStateUpdate', handleContractUpdate);\n      socketService.off('bettorsUpdate', handleBettorsUpdate);\n    };\n  }, []);\n\n  // Place a bet (sends real transaction and notifies backend)\n  const placeBet = async betAmount => {\n    console.log(`ðŸŽ° placeBet() called with amount: ${betAmount} TON`);\n    if (!isConnected || !address) {\n      throw new Error('Wallet not connected');\n    }\n    if (!contractState.isActive) {\n      throw new Error('Jackpot is not active');\n    }\n    if (betAmount < 0.1) {\n      throw new Error('Minimum bet is 0.1 TON');\n    }\n    if (betAmount > 10) {\n      throw new Error('Maximum bet is 10 TON');\n    }\n    try {\n      setIsPlacingBet(true);\n      console.log(`ðŸŽ° Placing bet: ${betAmount} TON from ${address}`);\n      console.log(`ðŸ“‹ Contract state: active=${contractState.isActive}, jackpot=${contractState.totalJackpot}`);\n\n      // Build transaction for the smart contract using the contract service\n      console.log(`ðŸ”§ Building transaction with opcode 0x03...`);\n      const transaction = jackpotContract.buildBetTransaction(betAmount, \"EQDhuMbM_cT3dXuJulXmlkA12YF8k5VdpPc1UxkuEqLpCo9K\");\n      console.log(`ðŸ“¤ Sending transaction to contract:`, {\n        contractAddress: transaction.messages[0].address,\n        amount: transaction.messages[0].amount,\n        payloadLength: transaction.messages[0].payload.length\n      });\n\n      // Send transaction via TON Connect\n      const result = await sendTransaction(transaction);\n      console.log('âœ… Bet transaction sent to contract:', result);\n\n      // Show transaction notification\n      if (typeof window !== 'undefined' && window.showTransactionNotification) {\n        window.showTransactionNotification(`ðŸ’° Transaction sent! Your ${betAmount} TON bet will take effect shortly.`, 'success');\n      }\n\n      // Backend will automatically detect the bet through contract polling\n      console.log('âœ… Bet sent to contract - backend will automatically detect via polling');\n\n      // Simple success response - no bet verification polling\n      console.log('âœ… Bet placed successfully - relying on normal polling for updates');\n      return {\n        success: true,\n        txHash: result.boc || 'unknown',\n        amount: betAmount,\n        address: address\n      };\n    } catch (error) {\n      console.error('âŒ Bet placement failed:', error);\n\n      // Show error notification\n      if (typeof window !== 'undefined' && window.showTransactionNotification) {\n        window.showTransactionNotification(`âŒ Bet failed: ${error.message}`, 'error');\n      }\n      throw error;\n    } finally {\n      setIsPlacingBet(false);\n    }\n  };\n\n  // Helper function to format address\n  const formatAddress = addr => {\n    if (!addr) return null;\n    return `${addr.slice(0, 6)}...${addr.slice(-6)}`;\n  };\n\n  // Helper function to format TON amounts\n  const formatTonAmount = amount => {\n    if (!amount) return '0.000';\n    return parseFloat(amount).toFixed(3);\n  };\n  return {\n    // Contract state\n    contractState: {\n      ...contractState,\n      formattedJackpot: formatTonAmount(contractState.totalJackpot),\n      formattedLastPrize: formatTonAmount(contractState.lastPrizeAmount)\n    },\n    // Admin info (now included in contract state)\n\n    // User state\n    userStats: {\n      ...userStats,\n      formattedBetAmount: formatTonAmount(userStats.betAmount)\n    },\n    // Loading states\n    isPlacingBet,\n    isRestoringConnection,\n    walletLoading,\n    // Actions\n    placeBet,\n    // Utility\n    isConnected,\n    address: address ? formatAddress(address) : null,\n    fullAddress: address,\n    // Backend admin controls (for emergency use only)\n    emergencyControls: {\n      forceStartRound: adminKey => backendApi.forceStartRound(adminKey),\n      forceEndRound: adminKey => backendApi.forceEndRound(adminKey),\n      updateSettings: settings => backendApi.updateAdminSettings(settings)\n    },\n    // Current bettors\n    currentBettors\n  };\n};\n_s(useJackpotContract, \"HTn+zIjfqPweJMoF2eCrL6fqDCk=\", false, function () {\n  return [useTonConnect];\n});\nexport default useJackpotContract;","map":{"version":3,"names":["useState","useEffect","useRef","jackpotContract","backendApi","useTonConnect","socketService","useJackpotContract","_s","_contractState$timer2","console","log","contractState","setContractState","totalJackpot","isActive","betCount","lastWinner","lastWinnerAddress","lastPrizeAmount","contractBalance","timestamp","error","roundJustEnded","hasWinner","winnerAnnouncement","timer","timeRemaining","timeElapsed","roundNumber","roundDuration","bettors","currentBettors","setCurrentBettors","userStats","setUserStats","betAmount","winningProbability","winChancePercentage","loading","isPlacingBet","setIsPlacingBet","hasInitialLoad","setHasInitialLoad","prevIsActiveRef","isConnected","address","sendTransaction","isLoading","walletLoading","isRestoringConnection","_contractState$timer","prevIsActive","current","currentIsActive","default","require","handleFullGameUpdate","gameData","prevState","_gameData$timer$isAct","_gameData$timer","_gameData$timer$timeR","_gameData$timer2","_gameData$timer$round","_gameData$timer3","_gameData$currentRoun","currentRound","Array","isArray","length","handleContractUpdate","contractData","handleBettorsUpdate","bettorsData","on","off","placeBet","Error","transaction","buildBetTransaction","contractAddress","messages","amount","payloadLength","payload","result","window","showTransactionNotification","success","txHash","boc","message","formatAddress","addr","slice","formatTonAmount","parseFloat","toFixed","formattedJackpot","formattedLastPrize","formattedBetAmount","fullAddress","emergencyControls","forceStartRound","adminKey","forceEndRound","updateSettings","settings","updateAdminSettings"],"sources":["C:/Users/adams/Downloads/GLL/slotpot/src/hooks/useJackpotContract.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\nimport { jackpotContract } from '../services/jackpotContract';\nimport { backendApi } from '../services/backendApi';\nimport useTonConnect from './useTonConnect';\nimport socketService from '../services/socketService';\n\n// API polling removed - all data now comes via socket broadcasts\n\nconst useJackpotContract = () => {\n  console.log('ðŸ”§ useJackpotContract hook initializing...');\n  \n  // Contract state\n  const [contractState, setContractState] = useState({\n    totalJackpot: 0,\n    isActive: false,\n    betCount: 0,\n    lastWinner: null,\n    lastWinnerAddress: null,\n    lastPrizeAmount: 0,\n    contractBalance: 0,\n    timestamp: 0,\n    error: null,\n    // Winner detection\n    roundJustEnded: false,\n    hasWinner: false,\n    winnerAnnouncement: null,\n    // Timer information (now integrated)\n    timer: {\n      isActive: false,\n      timeRemaining: 0,\n      timeElapsed: 0,\n      roundNumber: 0\n    },\n    roundDuration: 300,\n    bettors: []\n  });\n\n  // Current round bettors\n  const [currentBettors, setCurrentBettors] = useState([]);\n\n  // Admin info now comes via socket in contract state\n\n  // User-specific state\n  const [userStats, setUserStats] = useState({\n    betAmount: 0,\n    winningProbability: 0,\n    winChancePercentage: '0.00',\n    loading: false,\n    error: null\n  });\n\n  // Loading states\n  const [isPlacingBet, setIsPlacingBet] = useState(false);\n  const [hasInitialLoad, setHasInitialLoad] = useState(false);\n\n  // Essential refs for hook functionality\n  const prevIsActiveRef = useRef(contractState.isActive);\n\n  // Get wallet connection status\n  const { \n    isConnected, \n    address, \n    sendTransaction, \n    isLoading: walletLoading,\n    isRestoringConnection \n  } = useTonConnect();\n\n  // REMOVED: All bettor and contract data now comes via socket broadcasts\n\n  // REMOVED: All contract state now comes via socket broadcasts\n\n  // REMOVED: All address tracking and API calls - now handled via socket broadcasts\n\n  // User stats refresh - handled in consolidated polling system\n  // Removed separate useEffect to prevent duplicate API calls\n  // This fixes the issue where APIs were being called 4 times simultaneously\n\n  // Track round changes with ref to prevent re-renders\n  useEffect(() => {\n    const prevIsActive = prevIsActiveRef.current;\n    const currentIsActive = contractState.isActive;\n    \n    // Detect new round start (inactive -> active)\n    // But only clear bettors if timer > 0 (actual new round, not waiting for winner)\n    if (!prevIsActive && currentIsActive && contractState.timer?.timeRemaining > 0) {\n      console.log('ðŸ”„ New round detected, clearing bettors list');\n      setCurrentBettors([]); // Clear bettors list for new round\n    }\n    \n    // Update ref for next comparison\n    prevIsActiveRef.current = currentIsActive;\n  }, [contractState.isActive, contractState.timer?.timeRemaining]);\n\n  // REMOVED: All API polling - now handled entirely via socket broadcasts\n\n  // Socket handling for contract state updates (prevent re-initialization)\n  useEffect(() => {\n    // Import socket service\n    const { default: socketService } = require('../services/socketService');\n    \n    console.log('ðŸ”§ Hook: Setting up socket listeners (should only happen once)');\n    \n    // Listen for full game updates to sync contract state\n    const handleFullGameUpdate = (gameData) => {\n      console.log('ðŸ”§ Hook: Received full game update:', gameData);\n      setContractState(prevState => ({\n        ...prevState,\n        ...gameData,\n        // Ensure timer data is preserved/updated\n        timer: {\n          ...prevState.timer,\n          ...gameData.timer,\n          // Fallback to direct properties if timer object doesn't exist\n          isActive: gameData.timer?.isActive ?? gameData.isActive,\n          timeRemaining: gameData.timer?.timeRemaining ?? gameData.timeRemaining,\n          roundNumber: gameData.timer?.roundNumber ?? gameData.currentRound?.roundNumber\n        }\n      }));\n      \n      // Update bettors if included in game data\n      if (gameData.bettors && Array.isArray(gameData.bettors)) {\n        console.log('ðŸ”§ Hook: Updating bettors from game data:', gameData.bettors.length, 'bettors');\n        setCurrentBettors(gameData.bettors);\n      }\n    };\n\n    const handleContractUpdate = (contractData) => {\n      console.log('ðŸ”§ Hook: Received contract update:', contractData);\n      setContractState(prevState => ({\n        ...prevState,\n        ...contractData\n      }));\n    };\n\n    const handleBettorsUpdate = (bettorsData) => {\n      console.log('ðŸ”§ Hook: Received bettors update:', bettorsData);\n      if (bettorsData.bettors) {\n        setCurrentBettors(bettorsData.bettors);\n      }\n    };\n\n    // Set up listeners (removed gameState to avoid duplicates with App.js)\n    socketService.on('fullGameUpdate', handleFullGameUpdate);\n    socketService.on('contractStateUpdate', handleContractUpdate);\n    socketService.on('bettorsUpdate', handleBettorsUpdate);\n\n    return () => {\n      socketService.off('fullGameUpdate', handleFullGameUpdate);\n      socketService.off('contractStateUpdate', handleContractUpdate);\n      socketService.off('bettorsUpdate', handleBettorsUpdate);\n    };\n  }, []);\n\n  // Place a bet (sends real transaction and notifies backend)\n  const placeBet = async (betAmount) => {\n    console.log(`ðŸŽ° placeBet() called with amount: ${betAmount} TON`);\n    \n    if (!isConnected || !address) {\n      throw new Error('Wallet not connected');\n    }\n\n    if (!contractState.isActive) {\n      throw new Error('Jackpot is not active');\n    }\n\n    if (betAmount < 0.1) {\n      throw new Error('Minimum bet is 0.1 TON');\n    }\n\n    if (betAmount > 10) {\n      throw new Error('Maximum bet is 10 TON');\n    }\n\n    try {\n      setIsPlacingBet(true);\n      console.log(`ðŸŽ° Placing bet: ${betAmount} TON from ${address}`);\n      console.log(`ðŸ“‹ Contract state: active=${contractState.isActive}, jackpot=${contractState.totalJackpot}`);\n\n      // Build transaction for the smart contract using the contract service\n      console.log(`ðŸ”§ Building transaction with opcode 0x03...`);\n      const transaction = jackpotContract.buildBetTransaction(betAmount, \"EQDhuMbM_cT3dXuJulXmlkA12YF8k5VdpPc1UxkuEqLpCo9K\");\n      \n      console.log(`ðŸ“¤ Sending transaction to contract:`, {\n        contractAddress: transaction.messages[0].address,\n        amount: transaction.messages[0].amount,\n        payloadLength: transaction.messages[0].payload.length\n      });\n      \n      // Send transaction via TON Connect\n      const result = await sendTransaction(transaction);\n      \n      console.log('âœ… Bet transaction sent to contract:', result);\n\n      // Show transaction notification\n      if (typeof window !== 'undefined' && window.showTransactionNotification) {\n        window.showTransactionNotification(`ðŸ’° Transaction sent! Your ${betAmount} TON bet will take effect shortly.`, 'success');\n      }\n\n      // Backend will automatically detect the bet through contract polling\n      console.log('âœ… Bet sent to contract - backend will automatically detect via polling');\n\n      // Simple success response - no bet verification polling\n      console.log('âœ… Bet placed successfully - relying on normal polling for updates');\n\n      return {\n        success: true,\n        txHash: result.boc || 'unknown',\n        amount: betAmount,\n        address: address\n      };\n    } catch (error) {\n      console.error('âŒ Bet placement failed:', error);\n      \n      // Show error notification\n      if (typeof window !== 'undefined' && window.showTransactionNotification) {\n        window.showTransactionNotification(`âŒ Bet failed: ${error.message}`, 'error');\n      }\n      \n      throw error;\n    } finally {\n      setIsPlacingBet(false);\n    }\n  };\n\n  // Helper function to format address\n  const formatAddress = (addr) => {\n    if (!addr) return null;\n    return `${addr.slice(0, 6)}...${addr.slice(-6)}`;\n  };\n\n  // Helper function to format TON amounts\n  const formatTonAmount = (amount) => {\n    if (!amount) return '0.000';\n    return parseFloat(amount).toFixed(3);\n  };\n\n  return {\n    // Contract state\n    contractState: {\n      ...contractState,\n      formattedJackpot: formatTonAmount(contractState.totalJackpot),\n      formattedLastPrize: formatTonAmount(contractState.lastPrizeAmount)\n    },\n    \n    // Admin info (now included in contract state)\n    \n    // User state\n    userStats: {\n      ...userStats,\n      formattedBetAmount: formatTonAmount(userStats.betAmount)\n    },\n    \n    // Loading states\n    isPlacingBet,\n    isRestoringConnection,\n    walletLoading,\n    \n    // Actions\n    placeBet,\n    \n    // Utility\n    isConnected,\n    address: address ? formatAddress(address) : null,\n    fullAddress: address,\n    \n    // Backend admin controls (for emergency use only)\n    emergencyControls: {\n      forceStartRound: (adminKey) => backendApi.forceStartRound(adminKey),\n      forceEndRound: (adminKey) => backendApi.forceEndRound(adminKey),\n      updateSettings: (settings) => backendApi.updateAdminSettings(settings)\n    },\n    \n    // Current bettors\n    currentBettors\n  };\n};\n\nexport default useJackpotContract;"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AACnD,SAASC,eAAe,QAAQ,6BAA6B;AAC7D,SAASC,UAAU,QAAQ,wBAAwB;AACnD,OAAOC,aAAa,MAAM,iBAAiB;AAC3C,OAAOC,aAAa,MAAM,2BAA2B;;AAErD;;AAEA,MAAMC,kBAAkB,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAAA,IAAAC,qBAAA;EAC/BC,OAAO,CAACC,GAAG,CAAC,4CAA4C,CAAC;;EAEzD;EACA,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGb,QAAQ,CAAC;IACjDc,YAAY,EAAE,CAAC;IACfC,QAAQ,EAAE,KAAK;IACfC,QAAQ,EAAE,CAAC;IACXC,UAAU,EAAE,IAAI;IAChBC,iBAAiB,EAAE,IAAI;IACvBC,eAAe,EAAE,CAAC;IAClBC,eAAe,EAAE,CAAC;IAClBC,SAAS,EAAE,CAAC;IACZC,KAAK,EAAE,IAAI;IACX;IACAC,cAAc,EAAE,KAAK;IACrBC,SAAS,EAAE,KAAK;IAChBC,kBAAkB,EAAE,IAAI;IACxB;IACAC,KAAK,EAAE;MACLX,QAAQ,EAAE,KAAK;MACfY,aAAa,EAAE,CAAC;MAChBC,WAAW,EAAE,CAAC;MACdC,WAAW,EAAE;IACf,CAAC;IACDC,aAAa,EAAE,GAAG;IAClBC,OAAO,EAAE;EACX,CAAC,CAAC;;EAEF;EACA,MAAM,CAACC,cAAc,EAAEC,iBAAiB,CAAC,GAAGjC,QAAQ,CAAC,EAAE,CAAC;;EAExD;;EAEA;EACA,MAAM,CAACkC,SAAS,EAAEC,YAAY,CAAC,GAAGnC,QAAQ,CAAC;IACzCoC,SAAS,EAAE,CAAC;IACZC,kBAAkB,EAAE,CAAC;IACrBC,mBAAmB,EAAE,MAAM;IAC3BC,OAAO,EAAE,KAAK;IACdjB,KAAK,EAAE;EACT,CAAC,CAAC;;EAEF;EACA,MAAM,CAACkB,YAAY,EAAEC,eAAe,CAAC,GAAGzC,QAAQ,CAAC,KAAK,CAAC;EACvD,MAAM,CAAC0C,cAAc,EAAEC,iBAAiB,CAAC,GAAG3C,QAAQ,CAAC,KAAK,CAAC;;EAE3D;EACA,MAAM4C,eAAe,GAAG1C,MAAM,CAACU,aAAa,CAACG,QAAQ,CAAC;;EAEtD;EACA,MAAM;IACJ8B,WAAW;IACXC,OAAO;IACPC,eAAe;IACfC,SAAS,EAAEC,aAAa;IACxBC;EACF,CAAC,GAAG7C,aAAa,CAAC,CAAC;;EAEnB;;EAEA;;EAEA;;EAEA;EACA;EACA;;EAEA;EACAJ,SAAS,CAAC,MAAM;IAAA,IAAAkD,oBAAA;IACd,MAAMC,YAAY,GAAGR,eAAe,CAACS,OAAO;IAC5C,MAAMC,eAAe,GAAG1C,aAAa,CAACG,QAAQ;;IAE9C;IACA;IACA,IAAI,CAACqC,YAAY,IAAIE,eAAe,IAAI,EAAAH,oBAAA,GAAAvC,aAAa,CAACc,KAAK,cAAAyB,oBAAA,uBAAnBA,oBAAA,CAAqBxB,aAAa,IAAG,CAAC,EAAE;MAC9EjB,OAAO,CAACC,GAAG,CAAC,8CAA8C,CAAC;MAC3DsB,iBAAiB,CAAC,EAAE,CAAC,CAAC,CAAC;IACzB;;IAEA;IACAW,eAAe,CAACS,OAAO,GAAGC,eAAe;EAC3C,CAAC,EAAE,CAAC1C,aAAa,CAACG,QAAQ,GAAAN,qBAAA,GAAEG,aAAa,CAACc,KAAK,cAAAjB,qBAAA,uBAAnBA,qBAAA,CAAqBkB,aAAa,CAAC,CAAC;;EAEhE;;EAEA;EACA1B,SAAS,CAAC,MAAM;IACd;IACA,MAAM;MAAEsD,OAAO,EAAEjD;IAAc,CAAC,GAAGkD,OAAO,CAAC,2BAA2B,CAAC;IAEvE9C,OAAO,CAACC,GAAG,CAAC,gEAAgE,CAAC;;IAE7E;IACA,MAAM8C,oBAAoB,GAAIC,QAAQ,IAAK;MACzChD,OAAO,CAACC,GAAG,CAAC,qCAAqC,EAAE+C,QAAQ,CAAC;MAC5D7C,gBAAgB,CAAC8C,SAAS;QAAA,IAAAC,qBAAA,EAAAC,eAAA,EAAAC,qBAAA,EAAAC,gBAAA,EAAAC,qBAAA,EAAAC,gBAAA,EAAAC,qBAAA;QAAA,OAAK;UAC7B,GAAGP,SAAS;UACZ,GAAGD,QAAQ;UACX;UACAhC,KAAK,EAAE;YACL,GAAGiC,SAAS,CAACjC,KAAK;YAClB,GAAGgC,QAAQ,CAAChC,KAAK;YACjB;YACAX,QAAQ,GAAA6C,qBAAA,IAAAC,eAAA,GAAEH,QAAQ,CAAChC,KAAK,cAAAmC,eAAA,uBAAdA,eAAA,CAAgB9C,QAAQ,cAAA6C,qBAAA,cAAAA,qBAAA,GAAIF,QAAQ,CAAC3C,QAAQ;YACvDY,aAAa,GAAAmC,qBAAA,IAAAC,gBAAA,GAAEL,QAAQ,CAAChC,KAAK,cAAAqC,gBAAA,uBAAdA,gBAAA,CAAgBpC,aAAa,cAAAmC,qBAAA,cAAAA,qBAAA,GAAIJ,QAAQ,CAAC/B,aAAa;YACtEE,WAAW,GAAAmC,qBAAA,IAAAC,gBAAA,GAAEP,QAAQ,CAAChC,KAAK,cAAAuC,gBAAA,uBAAdA,gBAAA,CAAgBpC,WAAW,cAAAmC,qBAAA,cAAAA,qBAAA,IAAAE,qBAAA,GAAIR,QAAQ,CAACS,YAAY,cAAAD,qBAAA,uBAArBA,qBAAA,CAAuBrC;UACrE;QACF,CAAC;MAAA,CAAC,CAAC;;MAEH;MACA,IAAI6B,QAAQ,CAAC3B,OAAO,IAAIqC,KAAK,CAACC,OAAO,CAACX,QAAQ,CAAC3B,OAAO,CAAC,EAAE;QACvDrB,OAAO,CAACC,GAAG,CAAC,2CAA2C,EAAE+C,QAAQ,CAAC3B,OAAO,CAACuC,MAAM,EAAE,SAAS,CAAC;QAC5FrC,iBAAiB,CAACyB,QAAQ,CAAC3B,OAAO,CAAC;MACrC;IACF,CAAC;IAED,MAAMwC,oBAAoB,GAAIC,YAAY,IAAK;MAC7C9D,OAAO,CAACC,GAAG,CAAC,oCAAoC,EAAE6D,YAAY,CAAC;MAC/D3D,gBAAgB,CAAC8C,SAAS,KAAK;QAC7B,GAAGA,SAAS;QACZ,GAAGa;MACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,MAAMC,mBAAmB,GAAIC,WAAW,IAAK;MAC3ChE,OAAO,CAACC,GAAG,CAAC,mCAAmC,EAAE+D,WAAW,CAAC;MAC7D,IAAIA,WAAW,CAAC3C,OAAO,EAAE;QACvBE,iBAAiB,CAACyC,WAAW,CAAC3C,OAAO,CAAC;MACxC;IACF,CAAC;;IAED;IACAzB,aAAa,CAACqE,EAAE,CAAC,gBAAgB,EAAElB,oBAAoB,CAAC;IACxDnD,aAAa,CAACqE,EAAE,CAAC,qBAAqB,EAAEJ,oBAAoB,CAAC;IAC7DjE,aAAa,CAACqE,EAAE,CAAC,eAAe,EAAEF,mBAAmB,CAAC;IAEtD,OAAO,MAAM;MACXnE,aAAa,CAACsE,GAAG,CAAC,gBAAgB,EAAEnB,oBAAoB,CAAC;MACzDnD,aAAa,CAACsE,GAAG,CAAC,qBAAqB,EAAEL,oBAAoB,CAAC;MAC9DjE,aAAa,CAACsE,GAAG,CAAC,eAAe,EAAEH,mBAAmB,CAAC;IACzD,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMI,QAAQ,GAAG,MAAOzC,SAAS,IAAK;IACpC1B,OAAO,CAACC,GAAG,CAAC,qCAAqCyB,SAAS,MAAM,CAAC;IAEjE,IAAI,CAACS,WAAW,IAAI,CAACC,OAAO,EAAE;MAC5B,MAAM,IAAIgC,KAAK,CAAC,sBAAsB,CAAC;IACzC;IAEA,IAAI,CAAClE,aAAa,CAACG,QAAQ,EAAE;MAC3B,MAAM,IAAI+D,KAAK,CAAC,uBAAuB,CAAC;IAC1C;IAEA,IAAI1C,SAAS,GAAG,GAAG,EAAE;MACnB,MAAM,IAAI0C,KAAK,CAAC,wBAAwB,CAAC;IAC3C;IAEA,IAAI1C,SAAS,GAAG,EAAE,EAAE;MAClB,MAAM,IAAI0C,KAAK,CAAC,uBAAuB,CAAC;IAC1C;IAEA,IAAI;MACFrC,eAAe,CAAC,IAAI,CAAC;MACrB/B,OAAO,CAACC,GAAG,CAAC,mBAAmByB,SAAS,aAAaU,OAAO,EAAE,CAAC;MAC/DpC,OAAO,CAACC,GAAG,CAAC,6BAA6BC,aAAa,CAACG,QAAQ,aAAaH,aAAa,CAACE,YAAY,EAAE,CAAC;;MAEzG;MACAJ,OAAO,CAACC,GAAG,CAAC,6CAA6C,CAAC;MAC1D,MAAMoE,WAAW,GAAG5E,eAAe,CAAC6E,mBAAmB,CAAC5C,SAAS,EAAE,kDAAkD,CAAC;MAEtH1B,OAAO,CAACC,GAAG,CAAC,qCAAqC,EAAE;QACjDsE,eAAe,EAAEF,WAAW,CAACG,QAAQ,CAAC,CAAC,CAAC,CAACpC,OAAO;QAChDqC,MAAM,EAAEJ,WAAW,CAACG,QAAQ,CAAC,CAAC,CAAC,CAACC,MAAM;QACtCC,aAAa,EAAEL,WAAW,CAACG,QAAQ,CAAC,CAAC,CAAC,CAACG,OAAO,CAACf;MACjD,CAAC,CAAC;;MAEF;MACA,MAAMgB,MAAM,GAAG,MAAMvC,eAAe,CAACgC,WAAW,CAAC;MAEjDrE,OAAO,CAACC,GAAG,CAAC,qCAAqC,EAAE2E,MAAM,CAAC;;MAE1D;MACA,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,2BAA2B,EAAE;QACvED,MAAM,CAACC,2BAA2B,CAAC,6BAA6BpD,SAAS,oCAAoC,EAAE,SAAS,CAAC;MAC3H;;MAEA;MACA1B,OAAO,CAACC,GAAG,CAAC,wEAAwE,CAAC;;MAErF;MACAD,OAAO,CAACC,GAAG,CAAC,mEAAmE,CAAC;MAEhF,OAAO;QACL8E,OAAO,EAAE,IAAI;QACbC,MAAM,EAAEJ,MAAM,CAACK,GAAG,IAAI,SAAS;QAC/BR,MAAM,EAAE/C,SAAS;QACjBU,OAAO,EAAEA;MACX,CAAC;IACH,CAAC,CAAC,OAAOxB,KAAK,EAAE;MACdZ,OAAO,CAACY,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;;MAE/C;MACA,IAAI,OAAOiE,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,2BAA2B,EAAE;QACvED,MAAM,CAACC,2BAA2B,CAAC,iBAAiBlE,KAAK,CAACsE,OAAO,EAAE,EAAE,OAAO,CAAC;MAC/E;MAEA,MAAMtE,KAAK;IACb,CAAC,SAAS;MACRmB,eAAe,CAAC,KAAK,CAAC;IACxB;EACF,CAAC;;EAED;EACA,MAAMoD,aAAa,GAAIC,IAAI,IAAK;IAC9B,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;IACtB,OAAO,GAAGA,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,MAAMD,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;EAClD,CAAC;;EAED;EACA,MAAMC,eAAe,GAAIb,MAAM,IAAK;IAClC,IAAI,CAACA,MAAM,EAAE,OAAO,OAAO;IAC3B,OAAOc,UAAU,CAACd,MAAM,CAAC,CAACe,OAAO,CAAC,CAAC,CAAC;EACtC,CAAC;EAED,OAAO;IACL;IACAtF,aAAa,EAAE;MACb,GAAGA,aAAa;MAChBuF,gBAAgB,EAAEH,eAAe,CAACpF,aAAa,CAACE,YAAY,CAAC;MAC7DsF,kBAAkB,EAAEJ,eAAe,CAACpF,aAAa,CAACO,eAAe;IACnE,CAAC;IAED;;IAEA;IACAe,SAAS,EAAE;MACT,GAAGA,SAAS;MACZmE,kBAAkB,EAAEL,eAAe,CAAC9D,SAAS,CAACE,SAAS;IACzD,CAAC;IAED;IACAI,YAAY;IACZU,qBAAqB;IACrBD,aAAa;IAEb;IACA4B,QAAQ;IAER;IACAhC,WAAW;IACXC,OAAO,EAAEA,OAAO,GAAG+C,aAAa,CAAC/C,OAAO,CAAC,GAAG,IAAI;IAChDwD,WAAW,EAAExD,OAAO;IAEpB;IACAyD,iBAAiB,EAAE;MACjBC,eAAe,EAAGC,QAAQ,IAAKrG,UAAU,CAACoG,eAAe,CAACC,QAAQ,CAAC;MACnEC,aAAa,EAAGD,QAAQ,IAAKrG,UAAU,CAACsG,aAAa,CAACD,QAAQ,CAAC;MAC/DE,cAAc,EAAGC,QAAQ,IAAKxG,UAAU,CAACyG,mBAAmB,CAACD,QAAQ;IACvE,CAAC;IAED;IACA5E;EACF,CAAC;AACH,CAAC;AAACxB,EAAA,CA3QID,kBAAkB;EAAA,QAyDlBF,aAAa;AAAA;AAoNnB,eAAeE,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}