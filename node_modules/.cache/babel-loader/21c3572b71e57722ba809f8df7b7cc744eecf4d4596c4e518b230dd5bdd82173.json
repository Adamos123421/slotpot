{"ast":null,"code":"import { io } from 'socket.io-client';\nclass SocketService {\n  constructor() {\n    this.socket = null;\n    this.eventHandlers = new Map();\n    this.isConnected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.gameState = {\n      isWaitingForWinner: false,\n      currentRound: null,\n      timeRemaining: null,\n      lastWinner: null,\n      jackpotValue: 0,\n      bettors: []\n    };\n  }\n  connect() {\n    var _this$socket, _this$socket2;\n    // Prevent multiple connections - return if already connected or connecting\n    if ((_this$socket = this.socket) !== null && _this$socket !== void 0 && _this$socket.connected || (_this$socket2 = this.socket) !== null && _this$socket2 !== void 0 && _this$socket2.connecting) {\n      console.log('🔌 Socket already connected/connecting, skipping duplicate connection');\n      return;\n    }\n    const socketUrl = process.env.REACT_APP_SOCKET_URL || 'http://localhost:5002';\n    console.log('🔌 Creating new socket connection to:', socketUrl);\n    this.socket = io(socketUrl, {\n      reconnection: true,\n      reconnectionDelay: 1000,\n      reconnectionDelayMax: 5000,\n      reconnectionAttempts: this.maxReconnectAttempts,\n      transports: ['websocket'],\n      withCredentials: true\n    });\n    this.setupEventHandlers();\n  }\n  setupEventHandlers() {\n    if (!this.socket) return;\n    this.socket.on('connect', () => {\n      console.log('🔌 Connected to socket server');\n      this.isConnected = true;\n      this.reconnectAttempts = 0;\n\n      // Request current game state on connect (with null check)\n      if (this.socket && this.socket.connected) {\n        this.socket.emit('getGameState');\n      }\n    });\n    this.socket.on('disconnect', () => {\n      console.log('🔌 Disconnected from socket server');\n      this.isConnected = false;\n    });\n    this.socket.on('connect_error', error => {\n      console.log('🚫 Connection error:', error);\n      this.reconnectAttempts++;\n      if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n        console.log('❌ Max reconnection attempts reached');\n        this.socket.disconnect();\n      }\n    });\n\n    // Game specific events\n    this.socket.on('gameState', data => {\n      console.log('🎮 Received game state:', data);\n      this.gameState = {\n        ...this.gameState,\n        ...data\n      };\n\n      // If joining when timer is 0 and no winner yet, show waiting state\n      if (data.timeRemaining === 0 && !data.lastWinner) {\n        console.log('⏰ User joined during winner selection - showing waiting state');\n        this.gameState.isWaitingForWinner = true;\n        this.emit('waitingForWinner', true);\n      }\n      this.emit('gameState', this.gameState);\n    });\n    this.socket.on('winner', data => {\n      console.log('🏆 Winner announced:', data);\n      this.gameState.lastWinner = data;\n      this.gameState.isWaitingForWinner = false;\n      this.emit('winner', data);\n    });\n\n    // Handle direct winner announcements (reliable delivery)\n    this.socket.on('winnerAnnouncement', data => {\n      console.log('🎯 Direct winner announcement received:', data);\n      this.gameState.lastWinner = data;\n      this.gameState.isWaitingForWinner = false;\n      this.gameState.winnerAnnouncement = data;\n      this.emit('winnerAnnouncement', data);\n    });\n    this.socket.on('newBet', data => {\n      console.log('💰 New bet received:', data);\n      // Update local game state with new bet\n      if (!this.gameState.bettors.find(b => b.address === data.address)) {\n        this.gameState.bettors.push(data);\n      }\n      this.gameState.jackpotValue += parseFloat(data.amount) - 0.5; // Account for fee\n      this.emit('newBet', data);\n    });\n    this.socket.on('timer', data => {\n      console.log('⏰ Timer update:', data);\n      this.gameState.timeRemaining = data.timeRemaining;\n      this.gameState.currentRound = data.roundNumber;\n\n      // If timer hits 0 and we weren't already waiting, set waiting state\n      if (data.timeRemaining === 0 && !this.gameState.isWaitingForWinner) {\n        console.log('⏰ Timer ended - setting waiting for winner state');\n        this.gameState.isWaitingForWinner = true;\n        this.emit('waitingForWinner', true);\n      }\n      this.emit('timer', data);\n    });\n\n    // Handle round reset\n    this.socket.on('roundReset', () => {\n      console.log('🔄 Round reset');\n      this.gameState = {\n        ...this.gameState,\n        isWaitingForWinner: false,\n        bettors: [],\n        jackpotValue: 0,\n        lastWinner: null\n      };\n      this.emit('roundReset');\n    });\n\n    // Handle new round start\n    this.socket.on('newRound', data => {\n      console.log('🎰 New round started:', data);\n      this.gameState = {\n        ...this.gameState,\n        isWaitingForWinner: false,\n        isPostWinnerLoading: false,\n        bettors: [],\n        jackpotValue: 0,\n        lastWinner: null,\n        currentRound: data.roundNumber,\n        timeRemaining: data.timeRemaining\n      };\n      this.emit('newRound', data);\n      this.emit('gameState', this.gameState);\n    });\n\n    // Handle comprehensive game data updates\n    this.socket.on('fullGameUpdate', data => {\n      console.log('🎮 Full game data update:', data);\n      this.gameState = {\n        ...this.gameState,\n        ...data\n      };\n      this.emit('fullGameUpdate', data);\n      this.emit('gameState', this.gameState);\n    });\n\n    // Handle legacy bettors update for backwards compatibility\n    this.socket.on('bettorsUpdate', data => {\n      console.log('💰 Bettors update:', data);\n      this.gameState.bettors = data.bettors || [];\n      this.gameState.jackpotValue = data.totalPot || 0;\n      this.gameState.betCount = data.betCount || 0;\n      this.emit('bettorsUpdate', data);\n      this.emit('gameState', this.gameState);\n    });\n  }\n  on(event, callback) {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, new Set());\n    }\n    const handlers = this.eventHandlers.get(event);\n\n    // Prevent duplicate handlers\n    if (handlers.has(callback)) {\n      console.warn(`🔌 Duplicate listener for '${event}' event prevented`);\n      return;\n    }\n    handlers.add(callback);\n    console.log(`🔌 Added listener for '${event}' event (${handlers.size} total)`);\n  }\n  off(event, callback) {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      const wasDeleted = handlers.delete(callback);\n      if (wasDeleted) {\n        console.log(`🔌 Removed listener for '${event}' event (${handlers.size} remaining)`);\n      }\n    }\n  }\n  emit(event, data) {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.forEach(handler => handler(data));\n    }\n  }\n  placeBet(betData) {\n    var _this$socket3;\n    if (!((_this$socket3 = this.socket) !== null && _this$socket3 !== void 0 && _this$socket3.connected)) {\n      console.error('Cannot place bet: Socket not connected');\n      return;\n    }\n    this.socket.emit('placeBet', betData);\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n      this.isConnected = false;\n    }\n  }\n  reconnect() {\n    this.disconnect();\n    this.connect();\n  }\n  getGameState() {\n    return this.gameState;\n  }\n  isWaitingForWinner() {\n    return this.gameState.isWaitingForWinner;\n  }\n  isPostWinnerLoading() {\n    return this.gameState.isPostWinnerLoading || false;\n  }\n  getCurrentRound() {\n    return this.gameState.currentRound;\n  }\n}\n\n// Create singleton instance\nconst socketService = new SocketService();\nexport default socketService;","map":{"version":3,"names":["io","SocketService","constructor","socket","eventHandlers","Map","isConnected","reconnectAttempts","maxReconnectAttempts","gameState","isWaitingForWinner","currentRound","timeRemaining","lastWinner","jackpotValue","bettors","connect","_this$socket","_this$socket2","connected","connecting","console","log","socketUrl","process","env","REACT_APP_SOCKET_URL","reconnection","reconnectionDelay","reconnectionDelayMax","reconnectionAttempts","transports","withCredentials","setupEventHandlers","on","emit","error","disconnect","data","winnerAnnouncement","find","b","address","push","parseFloat","amount","roundNumber","isPostWinnerLoading","totalPot","betCount","event","callback","has","set","Set","handlers","get","warn","add","size","off","wasDeleted","delete","forEach","handler","placeBet","betData","_this$socket3","reconnect","getGameState","getCurrentRound","socketService"],"sources":["C:/Users/adams/Downloads/GLL/slotpot/src/services/socketService.js"],"sourcesContent":["import { io } from 'socket.io-client';\r\n\r\nclass SocketService {\r\n  constructor() {\r\n    this.socket = null;\r\n    this.eventHandlers = new Map();\r\n    this.isConnected = false;\r\n    this.reconnectAttempts = 0;\r\n    this.maxReconnectAttempts = 5;\r\n    this.gameState = {\r\n      isWaitingForWinner: false,\r\n      currentRound: null,\r\n      timeRemaining: null,\r\n      lastWinner: null,\r\n      jackpotValue: 0,\r\n      bettors: []\r\n    };\r\n  }\r\n\r\n  connect() {\r\n    // Prevent multiple connections - return if already connected or connecting\r\n    if (this.socket?.connected || this.socket?.connecting) {\r\n      console.log('🔌 Socket already connected/connecting, skipping duplicate connection');\r\n      return;\r\n    }\r\n\r\n    const socketUrl = process.env.REACT_APP_SOCKET_URL || 'http://localhost:5002';\r\n    \r\n    console.log('🔌 Creating new socket connection to:', socketUrl);\r\n    this.socket = io(socketUrl, {\r\n      reconnection: true,\r\n      reconnectionDelay: 1000,\r\n      reconnectionDelayMax: 5000,\r\n      reconnectionAttempts: this.maxReconnectAttempts,\r\n      transports: ['websocket'],\r\n      withCredentials: true\r\n    });\r\n\r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  setupEventHandlers() {\r\n    if (!this.socket) return;\r\n\r\n    this.socket.on('connect', () => {\r\n      console.log('🔌 Connected to socket server');\r\n      this.isConnected = true;\r\n      this.reconnectAttempts = 0;\r\n      \r\n      // Request current game state on connect (with null check)\r\n      if (this.socket && this.socket.connected) {\r\n        this.socket.emit('getGameState');\r\n      }\r\n    });\r\n\r\n    this.socket.on('disconnect', () => {\r\n      console.log('🔌 Disconnected from socket server');\r\n      this.isConnected = false;\r\n    });\r\n\r\n    this.socket.on('connect_error', (error) => {\r\n      console.log('🚫 Connection error:', error);\r\n      this.reconnectAttempts++;\r\n      \r\n      if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n        console.log('❌ Max reconnection attempts reached');\r\n        this.socket.disconnect();\r\n      }\r\n    });\r\n\r\n    // Game specific events\r\n    this.socket.on('gameState', (data) => {\r\n      console.log('🎮 Received game state:', data);\r\n      \r\n      this.gameState = {\r\n        ...this.gameState,\r\n        ...data\r\n      };\r\n      \r\n      // If joining when timer is 0 and no winner yet, show waiting state\r\n      if (data.timeRemaining === 0 && !data.lastWinner) {\r\n        console.log('⏰ User joined during winner selection - showing waiting state');\r\n        this.gameState.isWaitingForWinner = true;\r\n        this.emit('waitingForWinner', true);\r\n      }\r\n      \r\n      this.emit('gameState', this.gameState);\r\n    });\r\n\r\n    this.socket.on('winner', (data) => {\r\n      console.log('🏆 Winner announced:', data);\r\n      this.gameState.lastWinner = data;\r\n      this.gameState.isWaitingForWinner = false;\r\n      this.emit('winner', data);\r\n    });\r\n\r\n    // Handle direct winner announcements (reliable delivery)\r\n    this.socket.on('winnerAnnouncement', (data) => {\r\n      console.log('🎯 Direct winner announcement received:', data);\r\n      this.gameState.lastWinner = data;\r\n      this.gameState.isWaitingForWinner = false;\r\n      this.gameState.winnerAnnouncement = data;\r\n      this.emit('winnerAnnouncement', data);\r\n    });\r\n\r\n    this.socket.on('newBet', (data) => {\r\n      console.log('💰 New bet received:', data);\r\n      // Update local game state with new bet\r\n      if (!this.gameState.bettors.find(b => b.address === data.address)) {\r\n        this.gameState.bettors.push(data);\r\n      }\r\n      this.gameState.jackpotValue += (parseFloat(data.amount) - 0.5); // Account for fee\r\n      this.emit('newBet', data);\r\n    });\r\n\r\n    this.socket.on('timer', (data) => {\r\n      console.log('⏰ Timer update:', data);\r\n      this.gameState.timeRemaining = data.timeRemaining;\r\n      this.gameState.currentRound = data.roundNumber;\r\n      \r\n      // If timer hits 0 and we weren't already waiting, set waiting state\r\n      if (data.timeRemaining === 0 && !this.gameState.isWaitingForWinner) {\r\n        console.log('⏰ Timer ended - setting waiting for winner state');\r\n        this.gameState.isWaitingForWinner = true;\r\n        this.emit('waitingForWinner', true);\r\n      }\r\n      \r\n      this.emit('timer', data);\r\n    });\r\n\r\n    // Handle round reset\r\n    this.socket.on('roundReset', () => {\r\n      console.log('🔄 Round reset');\r\n      this.gameState = {\r\n        ...this.gameState,\r\n        isWaitingForWinner: false,\r\n        bettors: [],\r\n        jackpotValue: 0,\r\n        lastWinner: null\r\n      };\r\n      this.emit('roundReset');\r\n    });\r\n\r\n    // Handle new round start\r\n    this.socket.on('newRound', (data) => {\r\n      console.log('🎰 New round started:', data);\r\n      this.gameState = {\r\n        ...this.gameState,\r\n        isWaitingForWinner: false,\r\n        isPostWinnerLoading: false,\r\n        bettors: [],\r\n        jackpotValue: 0,\r\n        lastWinner: null,\r\n        currentRound: data.roundNumber,\r\n        timeRemaining: data.timeRemaining\r\n      };\r\n      this.emit('newRound', data);\r\n      this.emit('gameState', this.gameState);\r\n    });\r\n\r\n    // Handle comprehensive game data updates\r\n    this.socket.on('fullGameUpdate', (data) => {\r\n      console.log('🎮 Full game data update:', data);\r\n      this.gameState = {\r\n        ...this.gameState,\r\n        ...data\r\n      };\r\n      this.emit('fullGameUpdate', data);\r\n      this.emit('gameState', this.gameState);\r\n    });\r\n\r\n    // Handle legacy bettors update for backwards compatibility\r\n    this.socket.on('bettorsUpdate', (data) => {\r\n      console.log('💰 Bettors update:', data);\r\n      this.gameState.bettors = data.bettors || [];\r\n      this.gameState.jackpotValue = data.totalPot || 0;\r\n      this.gameState.betCount = data.betCount || 0;\r\n      this.emit('bettorsUpdate', data);\r\n      this.emit('gameState', this.gameState);\r\n    });\r\n  }\r\n\r\n  on(event, callback) {\r\n    if (!this.eventHandlers.has(event)) {\r\n      this.eventHandlers.set(event, new Set());\r\n    }\r\n    \r\n    const handlers = this.eventHandlers.get(event);\r\n    \r\n    // Prevent duplicate handlers\r\n    if (handlers.has(callback)) {\r\n      console.warn(`🔌 Duplicate listener for '${event}' event prevented`);\r\n      return;\r\n    }\r\n    \r\n    handlers.add(callback);\r\n    console.log(`🔌 Added listener for '${event}' event (${handlers.size} total)`);\r\n  }\r\n\r\n  off(event, callback) {\r\n    const handlers = this.eventHandlers.get(event);\r\n    if (handlers) {\r\n      const wasDeleted = handlers.delete(callback);\r\n      if (wasDeleted) {\r\n        console.log(`🔌 Removed listener for '${event}' event (${handlers.size} remaining)`);\r\n      }\r\n    }\r\n  }\r\n\r\n  emit(event, data) {\r\n    const handlers = this.eventHandlers.get(event);\r\n    if (handlers) {\r\n      handlers.forEach(handler => handler(data));\r\n    }\r\n  }\r\n\r\n  placeBet(betData) {\r\n    if (!this.socket?.connected) {\r\n      console.error('Cannot place bet: Socket not connected');\r\n      return;\r\n    }\r\n    this.socket.emit('placeBet', betData);\r\n  }\r\n\r\n  disconnect() {\r\n    if (this.socket) {\r\n      this.socket.disconnect();\r\n      this.socket = null;\r\n      this.isConnected = false;\r\n    }\r\n  }\r\n\r\n  reconnect() {\r\n    this.disconnect();\r\n    this.connect();\r\n  }\r\n\r\n  getGameState() {\r\n    return this.gameState;\r\n  }\r\n\r\n  isWaitingForWinner() {\r\n    return this.gameState.isWaitingForWinner;\r\n  }\r\n\r\n  isPostWinnerLoading() {\r\n    return this.gameState.isPostWinnerLoading || false;\r\n  }\r\n\r\n  getCurrentRound() {\r\n    return this.gameState.currentRound;\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nconst socketService = new SocketService();\r\nexport default socketService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}