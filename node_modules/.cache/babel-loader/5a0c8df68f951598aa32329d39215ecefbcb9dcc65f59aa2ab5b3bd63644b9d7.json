{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\adams\\\\OneDrive\\\\Desktop\\\\Work\\\\slotpot\\\\src\\\\components\\\\SimpleCarousel.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { TonIcon } from './IconComponents';\nimport soundService from '../services/soundService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SimpleCarousel = ({\n  players,\n  isSpinning,\n  onSpinComplete,\n  contractWinner,\n  totalJackpotValue\n}) => {\n  _s();\n  const [wheelState, setWheelState] = useState('idle'); // 'idle', 'waiting', 'spinning', 'winner', 'finished'\n  const [lockedPlayers, setLockedPlayers] = useState([]); // Lock players during animation\n  const wheelRef = useRef();\n  const idleAnimationRef = useRef();\n  const currentPosition = useRef(0);\n  const winnerShowcaseTimeoutRef = useRef();\n\n  // Card dimensions (matching roulette example)\n  const CARD_WIDTH = 81; // 75px + 3px margin on each side\n\n  // Lock players when spinning starts to prevent them from changing during animation\n  useEffect(() => {\n    if (isSpinning && contractWinner && players.length > 0) {\n      console.log('üîí Locking players for animation:', players);\n      setLockedPlayers([...players]);\n    }\n  }, [isSpinning, contractWinner, players]);\n\n  // Use locked players during animation, regular players otherwise\n  const effectivePlayers = wheelState === 'spinning' || wheelState === 'winner' ? lockedPlayers : players;\n\n  // Render individual player card HTML\n  const renderPlayerCard = useCallback((player, key) => {\n    if (!player) {\n      return `\n        <div class=\"waiting-card\">\n          <div class=\"avatar-container\">\n            ?\n          </div>\n          <div class=\"waiting-text\">Waiting</div>\n          <div class=\"waiting-amount\">0.000</div>\n        </div>\n      `;\n    }\n\n    // Always show the amount if it exists, regardless of isRealPlayer\n    const amount = player.bet || player.amount || 0;\n    const isActive = amount > 0;\n    const avatar = player.avatar && player.avatar !== '‚ùì' && player.avatar !== 'üë§' ? player.avatar : `https://robohash.org/${player.address || player.name}.png?size=100x100`;\n    const username = player.username || player.displayName || player.name || 'Player';\n    const bet = amount.toFixed(3);\n    return `\n      <div class=\"player-card ${isActive ? 'active' : 'inactive'}\" data-key=\"${key}\">\n        <div class=\"card-content\">\n          <div class=\"avatar-container\">\n            <img src=\"${avatar}\" alt=\"${username}\" class=\"player-avatar\" />\n          </div>\n          <div class=\"player-info\">\n            <p class=\"player-name\">${username}</p>\n            <div class=\"bet-info\">\n              <div class=\"coin-icon ${!isActive ? 'grayscale' : ''}\"></div>\n              <span class=\"bet-amount\">${bet}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }, []);\n\n  // Initialize wheel with player rows for infinite scrolling\n  const initWheel = useCallback(() => {\n    if (!wheelRef.current || !effectivePlayers.length) return;\n    const wheel = wheelRef.current;\n    wheel.innerHTML = ''; // Clear existing content\n\n    // Create one continuous row with multiple player cycles for smooth infinite scroll\n    const row = document.createElement('div');\n    row.className = 'roulette-row';\n\n    // Create enough copies to ensure smooth infinite scrolling (50 copies)\n    for (let copyIndex = 0; copyIndex < 50; copyIndex++) {\n      effectivePlayers.forEach((player, playerIndex) => {\n        const card = document.createElement('div');\n        card.className = 'roulette-card';\n        card.innerHTML = renderPlayerCard(player, `${copyIndex}-${playerIndex}`);\n        row.appendChild(card);\n      });\n    }\n    wheel.appendChild(row);\n  }, [effectivePlayers, renderPlayerCard]);\n\n  // Idle movement - constant speed with true infinite scroll\n  const startIdleMovement = useCallback(() => {\n    if (!wheelRef.current || wheelState !== 'idle') return;\n    const animate = () => {\n      var _wheelRef$current;\n      if (wheelState !== 'idle') return;\n      currentPosition.current -= 0.5; // Slower, smoother movement (0.5px per frame)\n\n      // True infinite scroll - reset when we've scrolled through several player cycles\n      // Use actual card spacing for consistency\n      const firstCard = (_wheelRef$current = wheelRef.current) === null || _wheelRef$current === void 0 ? void 0 : _wheelRef$current.querySelector('.roulette-card');\n      const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n      const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n      const totalCardSpacing = actualCardWidth + cardMargin;\n      const cycleWidth = effectivePlayers.length * totalCardSpacing;\n      const resetPoint = -(cycleWidth * 10); // Reset after 10 cycles\n\n      if (currentPosition.current <= resetPoint) {\n        // Reset to a position that maintains visual continuity\n        currentPosition.current = -(cycleWidth * 5); // Reset to middle area\n      }\n      if (wheelRef.current) {\n        wheelRef.current.style.transform = `translate3d(${currentPosition.current}px, 0px, 0px)`;\n      }\n      idleAnimationRef.current = requestAnimationFrame(animate);\n    };\n    idleAnimationRef.current = requestAnimationFrame(animate);\n  }, [wheelState, effectivePlayers.length, CARD_WIDTH]);\n\n  // Stop idle movement\n  const stopIdleMovement = useCallback(() => {\n    if (idleAnimationRef.current) {\n      cancelAnimationFrame(idleAnimationRef.current);\n      idleAnimationRef.current = null;\n    }\n  }, []);\n\n  // Find winner position in player array\n  const findWinnerPosition = useCallback(winner => {\n    if (!winner || !effectivePlayers.length) return -1;\n    console.log('Looking for winner:', winner);\n    console.log('Available players:', effectivePlayers);\n    for (let i = 0; i < effectivePlayers.length; i++) {\n      const player = effectivePlayers[i];\n      if (player && player.address && (player.address === winner.winner || player.address === winner.fullAddress) || player && player.fullAddress && (player.fullAddress === winner.winner || player.fullAddress === winner.fullAddress) || player && player.username && player.username === winner.username || player && player.displayName && player.displayName === winner.displayName) {\n        console.log(`Found winner at position ${i}:`, player);\n        return i;\n      }\n    }\n    console.warn('Winner not found in player list');\n    return -1;\n  }, [effectivePlayers]);\n\n  // Spin wheel function with improved accuracy\n  const spinWheel = useCallback(targetWinner => {\n    if (wheelState === 'spinning' || !wheelRef.current) return;\n    console.log('Starting spin with winner:', targetWinner);\n\n    // Play launch sound when spin starts\n    soundService.playLaunch();\n    setWheelState('spinning');\n    stopIdleMovement();\n    const winnerPosition = findWinnerPosition(targetWinner);\n    if (winnerPosition === -1) {\n      console.warn('Winner not found in player list, spinning randomly');\n      // If winner not found, still spin but land on first player\n      const fallbackPosition = 0;\n      performSpin(fallbackPosition, targetWinner);\n      return;\n    }\n    performSpin(winnerPosition, targetWinner);\n  }, [wheelState, stopIdleMovement, findWinnerPosition, effectivePlayers.length, onSpinComplete, CARD_WIDTH]);\n\n  // Separate function to perform the actual spin animation\n  const performSpin = useCallback((winnerPosition, targetWinner) => {\n    const wheel = wheelRef.current;\n    if (!wheel) return;\n\n    // Calculate precise landing position\n    const wheelWidth = wheel.offsetWidth;\n    const centerOffset = wheelWidth / 2;\n    const firstCard = wheel.querySelector('.roulette-card');\n    const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n    const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n    const totalCardSpacing = actualCardWidth + cardMargin;\n    console.log(`üìè Card measurements: width=${actualCardWidth}px, margin=${cardMargin}px, total=${totalCardSpacing}px`);\n    console.log(`üéØ Winner found at array position: ${winnerPosition}`);\n\n    // CLASSIC SLOT MACHINE ANIMATION: Fast slide then slow down to winner\n    const cycleLength = effectivePlayers.length * totalCardSpacing;\n    const currentAbsolutePosition = Math.abs(currentPosition.current);\n\n    // Calculate how far we need to slide to get the winner centered\n    // We want to slide fast past the winner, then slow down and land on it\n    const winnerOffset = winnerPosition * totalCardSpacing;\n\n    // Slide at least 3 full cycles to create that \"fast spinning\" effect\n    // Then land precisely on the winner in the next visible cycle\n    const minimumSpinDistance = cycleLength * 3; // At least 3 full cycles\n    const targetCycle = Math.ceil((currentAbsolutePosition + minimumSpinDistance) / cycleLength);\n    const finalWinnerPosition = targetCycle * cycleLength + winnerOffset;\n    const finalPosition = -(finalWinnerPosition + actualCardWidth / 2 - centerOffset);\n    console.log(`üé∞ Classic slot machine calculation:`);\n    console.log(`   - Current position: ${currentPosition.current}px`);\n    console.log(`   - Winner position in array: ${winnerPosition}`);\n    console.log(`   - Winner offset: ${winnerOffset}px`);\n    console.log(`   - Minimum spin distance: ${minimumSpinDistance}px`);\n    console.log(`   - Target cycle: ${targetCycle}`);\n    console.log(`   - Final winner position: ${finalWinnerPosition}px`);\n    console.log(`   - Final position: ${finalPosition}px`);\n    console.log(`   - Total slide distance: ${Math.abs(finalPosition - currentPosition.current)}px`);\n\n    // Start ticking sound for the spinning effect\n    let tickInterval = setInterval(() => {\n      soundService.playSpinWithVolume(0.3);\n    }, 100); // Fast ticking initially\n\n    // STAGE 1: Fast spinning for 2 seconds\n    wheel.style.transitionTimingFunction = 'linear';\n    wheel.style.transitionDuration = '2000ms';\n\n    // Slide 80% of the way during fast phase\n    const fastPhasePosition = currentPosition.current + (finalPosition - currentPosition.current) * 0.8;\n    wheel.style.transform = `translate3d(${fastPhasePosition}px, 0px, 0px)`;\n    currentPosition.current = fastPhasePosition;\n\n    // STAGE 2: Slow down dramatically for final 20% over 3 seconds\n    setTimeout(() => {\n      // Slower ticking sound\n      clearInterval(tickInterval);\n      tickInterval = setInterval(() => {\n        soundService.playSpinWithVolume(0.4);\n      }, 300); // Much slower ticking\n\n      wheel.style.transitionTimingFunction = 'cubic-bezier(0.05, 0.1, 0.05, 1)';\n      wheel.style.transitionDuration = '3000ms';\n      wheel.style.transform = `translate3d(${finalPosition}px, 0px, 0px)`;\n      currentPosition.current = finalPosition;\n\n      // Stop ticking after slowdown completes\n      setTimeout(() => {\n        clearInterval(tickInterval);\n      }, 3000);\n    }, 2000); // Wait 2 seconds for fast phase\n\n    // After total animation (2s + 3s = 5s), show winner\n    setTimeout(() => {\n      console.log('Classic slot machine animation completed, showing winner');\n      setWheelState('winner');\n\n      // Highlight the winner card\n      const allCards = wheel.querySelectorAll('.roulette-card');\n      console.log(`üéØ Highlighting winner at position ${winnerPosition} out of ${effectivePlayers.length} players`);\n      allCards.forEach((card, index) => {\n        const cardPlayerIndex = index % effectivePlayers.length;\n        if (cardPlayerIndex === winnerPosition) {\n          card.classList.add('winner-highlight');\n          console.log(`‚ú® Highlighted card at index ${index} (player ${cardPlayerIndex})`);\n        }\n      });\n\n      // After showcasing winner for 4 seconds, go to finished state\n      winnerShowcaseTimeoutRef.current = setTimeout(() => {\n        console.log('Winner showcase complete, entering finished state');\n\n        // Remove winner highlights\n        const highlightedCards = wheel.querySelectorAll('.winner-highlight');\n        highlightedCards.forEach(card => {\n          card.classList.remove('winner-highlight');\n        });\n\n        // Reset transition styles\n        wheel.style.transitionTimingFunction = '';\n        wheel.style.transitionDuration = '';\n\n        // Clear locked players\n        setLockedPlayers([]);\n        setWheelState('finished');\n        onSpinComplete === null || onSpinComplete === void 0 ? void 0 : onSpinComplete(targetWinner);\n      }, 4000); // Show winner for 4 seconds\n    }, 5000); // Wait 5 seconds for both phases (2s fast + 3s slow)\n  }, [effectivePlayers.length, CARD_WIDTH, onSpinComplete]);\n\n  // Handle state changes\n  useEffect(() => {\n    if (isSpinning && contractWinner && wheelState === 'waiting') {\n      // Backend responded with winner, start spinning\n      console.log('Starting roulette spin with winner:', contractWinner);\n      spinWheel(contractWinner);\n    } else if (isSpinning && !contractWinner && wheelState === 'idle') {\n      // Bet placed, stop and wait for backend\n      console.log('Stopping wheel, waiting for winner...');\n      setWheelState('waiting');\n      stopIdleMovement();\n    } else if (!isSpinning && wheelState !== 'idle' && wheelState !== 'winner' && wheelState !== 'finished') {\n      // Reset to idle state (but don't interrupt winner showcase or finished state)\n      console.log('Resetting to idle state');\n      setWheelState('idle');\n    }\n  }, [isSpinning, contractWinner, wheelState, spinWheel, stopIdleMovement]);\n\n  // Detect new game start and reset from finished state to idle\n  useEffect(() => {\n    // If we're in finished state and there's no winner (new game starting), reset to idle\n    if (wheelState === 'finished' && !contractWinner && !isSpinning) {\n      console.log('New game detected - resetting from finished to idle');\n      setWheelState('idle');\n    }\n  }, [wheelState, contractWinner, isSpinning]);\n\n  // Start/stop idle movement based on state\n  useEffect(() => {\n    if (wheelState === 'idle') {\n      startIdleMovement();\n    } else {\n      stopIdleMovement();\n    }\n    return () => stopIdleMovement();\n  }, [wheelState, startIdleMovement, stopIdleMovement]);\n\n  // Initialize wheel when effective players change (but not during winner showcase)\n  useEffect(() => {\n    // Don't reinitialize during winner showcase or finished state to preserve highlighting\n    if (wheelState !== 'winner' && wheelState !== 'finished') {\n      initWheel();\n    }\n  }, [initWheel, wheelState]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (winnerShowcaseTimeoutRef.current) {\n        clearTimeout(winnerShowcaseTimeoutRef.current);\n      }\n    };\n  }, []);\n  if (!effectivePlayers || effectivePlayers.length === 0) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"simple-carousel\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"carousel-message\",\n        children: \"Waiting for players to join...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 363,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 362,\n      columnNumber: 7\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"roulette-wrapper\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"roulette-selector\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 373,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: wheelRef,\n      className: \"roulette-wheel\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 376,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"wheel-state-indicator\",\n      children: [wheelState === 'idle' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFB0\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 380,\n        columnNumber: 35\n      }, this), wheelState === 'waiting' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\u23F3\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 381,\n        columnNumber: 38\n      }, this), wheelState === 'spinning' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFAF\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 382,\n        columnNumber: 39\n      }, this), wheelState === 'winner' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDF89\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 383,\n        columnNumber: 37\n      }, this), wheelState === 'finished' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFC1\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 384,\n        columnNumber: 39\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 379,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"absolute -top-1/4 -right-1/3 h-full opacity-75 will-change-transform z-[3] pointer-events-none\",\n      style: {\n        maskImage: 'linear-gradient(black, transparent 50%)'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"img\", {\n        src: \"/img/glare.webp\",\n        className: \"w-full object-cover object-center\",\n        alt: \"\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 392,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 388,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 371,\n    columnNumber: 5\n  }, this);\n};\n_s(SimpleCarousel, \"VIxi7lGLuxZ4CmPOzTtmWajujkE=\");\n_c = SimpleCarousel;\nexport default SimpleCarousel;\nvar _c;\n$RefreshReg$(_c, \"SimpleCarousel\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","TonIcon","soundService","jsxDEV","_jsxDEV","SimpleCarousel","players","isSpinning","onSpinComplete","contractWinner","totalJackpotValue","_s","wheelState","setWheelState","lockedPlayers","setLockedPlayers","wheelRef","idleAnimationRef","currentPosition","winnerShowcaseTimeoutRef","CARD_WIDTH","length","console","log","effectivePlayers","renderPlayerCard","player","key","amount","bet","isActive","avatar","address","name","username","displayName","toFixed","initWheel","current","wheel","innerHTML","row","document","createElement","className","copyIndex","forEach","playerIndex","card","appendChild","startIdleMovement","animate","_wheelRef$current","firstCard","querySelector","actualCardWidth","offsetWidth","cardMargin","parseInt","getComputedStyle","marginLeft","marginRight","totalCardSpacing","cycleWidth","resetPoint","style","transform","requestAnimationFrame","stopIdleMovement","cancelAnimationFrame","findWinnerPosition","winner","i","fullAddress","warn","spinWheel","targetWinner","playLaunch","winnerPosition","fallbackPosition","performSpin","wheelWidth","centerOffset","cycleLength","currentAbsolutePosition","Math","abs","winnerOffset","minimumSpinDistance","targetCycle","ceil","finalWinnerPosition","finalPosition","tickInterval","setInterval","playSpinWithVolume","transitionTimingFunction","transitionDuration","fastPhasePosition","setTimeout","clearInterval","allCards","querySelectorAll","index","cardPlayerIndex","classList","add","highlightedCards","remove","clearTimeout","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","maskImage","src","alt","_c","$RefreshReg$"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/src/components/SimpleCarousel.js"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { TonIcon } from './IconComponents';\nimport soundService from '../services/soundService';\n\nconst SimpleCarousel = ({ \n  players, \n  isSpinning, \n  onSpinComplete, \n  contractWinner,\n  totalJackpotValue \n}) => {\n  const [wheelState, setWheelState] = useState('idle'); // 'idle', 'waiting', 'spinning', 'winner', 'finished'\n  const [lockedPlayers, setLockedPlayers] = useState([]); // Lock players during animation\n  const wheelRef = useRef();\n  const idleAnimationRef = useRef();\n  const currentPosition = useRef(0);\n  const winnerShowcaseTimeoutRef = useRef();\n  \n  // Card dimensions (matching roulette example)\n  const CARD_WIDTH = 81; // 75px + 3px margin on each side\n  \n  // Lock players when spinning starts to prevent them from changing during animation\n  useEffect(() => {\n    if (isSpinning && contractWinner && players.length > 0) {\n      console.log('üîí Locking players for animation:', players);\n      setLockedPlayers([...players]);\n    }\n  }, [isSpinning, contractWinner, players]);\n  \n  // Use locked players during animation, regular players otherwise\n  const effectivePlayers = wheelState === 'spinning' || wheelState === 'winner' ? lockedPlayers : players;\n  \n  // Render individual player card HTML\n  const renderPlayerCard = useCallback((player, key) => {\n    if (!player) {\n      return `\n        <div class=\"waiting-card\">\n          <div class=\"avatar-container\">\n            ?\n          </div>\n          <div class=\"waiting-text\">Waiting</div>\n          <div class=\"waiting-amount\">0.000</div>\n        </div>\n      `;\n    }\n    \n    // Always show the amount if it exists, regardless of isRealPlayer\n    const amount = player.bet || player.amount || 0;\n    const isActive = amount > 0;\n    const avatar = player.avatar && player.avatar !== '‚ùì' && player.avatar !== 'üë§' ? \n      player.avatar : \n      `https://robohash.org/${player.address || player.name}.png?size=100x100`;\n    const username = player.username || player.displayName || player.name || 'Player';\n    const bet = amount.toFixed(3);\n    \n    return `\n      <div class=\"player-card ${isActive ? 'active' : 'inactive'}\" data-key=\"${key}\">\n        <div class=\"card-content\">\n          <div class=\"avatar-container\">\n            <img src=\"${avatar}\" alt=\"${username}\" class=\"player-avatar\" />\n          </div>\n          <div class=\"player-info\">\n            <p class=\"player-name\">${username}</p>\n            <div class=\"bet-info\">\n              <div class=\"coin-icon ${!isActive ? 'grayscale' : ''}\"></div>\n              <span class=\"bet-amount\">${bet}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }, []);\n\n  // Initialize wheel with player rows for infinite scrolling\n  const initWheel = useCallback(() => {\n    if (!wheelRef.current || !effectivePlayers.length) return;\n    \n    const wheel = wheelRef.current;\n    wheel.innerHTML = ''; // Clear existing content\n    \n    // Create one continuous row with multiple player cycles for smooth infinite scroll\n    const row = document.createElement('div');\n    row.className = 'roulette-row';\n    \n    // Create enough copies to ensure smooth infinite scrolling (50 copies)\n    for (let copyIndex = 0; copyIndex < 50; copyIndex++) {\n      effectivePlayers.forEach((player, playerIndex) => {\n        const card = document.createElement('div');\n        card.className = 'roulette-card';\n        card.innerHTML = renderPlayerCard(player, `${copyIndex}-${playerIndex}`);\n        row.appendChild(card);\n      });\n    }\n    \n    wheel.appendChild(row);\n  }, [effectivePlayers, renderPlayerCard]);\n\n  // Idle movement - constant speed with true infinite scroll\n  const startIdleMovement = useCallback(() => {\n    if (!wheelRef.current || wheelState !== 'idle') return;\n    \n    const animate = () => {\n      if (wheelState !== 'idle') return;\n      \n      currentPosition.current -= 0.5; // Slower, smoother movement (0.5px per frame)\n      \n      // True infinite scroll - reset when we've scrolled through several player cycles\n      // Use actual card spacing for consistency\n      const firstCard = wheelRef.current?.querySelector('.roulette-card');\n      const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n      const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n      const totalCardSpacing = actualCardWidth + cardMargin;\n      \n      const cycleWidth = effectivePlayers.length * totalCardSpacing;\n      const resetPoint = -(cycleWidth * 10); // Reset after 10 cycles\n      \n      if (currentPosition.current <= resetPoint) {\n        // Reset to a position that maintains visual continuity\n        currentPosition.current = -(cycleWidth * 5); // Reset to middle area\n      }\n      \n      if (wheelRef.current) {\n        wheelRef.current.style.transform = `translate3d(${currentPosition.current}px, 0px, 0px)`;\n      }\n      \n      idleAnimationRef.current = requestAnimationFrame(animate);\n    };\n    \n    idleAnimationRef.current = requestAnimationFrame(animate);\n  }, [wheelState, effectivePlayers.length, CARD_WIDTH]);\n\n  // Stop idle movement\n  const stopIdleMovement = useCallback(() => {\n    if (idleAnimationRef.current) {\n      cancelAnimationFrame(idleAnimationRef.current);\n      idleAnimationRef.current = null;\n    }\n  }, []);\n\n  // Find winner position in player array\n  const findWinnerPosition = useCallback((winner) => {\n    if (!winner || !effectivePlayers.length) return -1;\n    \n    console.log('Looking for winner:', winner);\n    console.log('Available players:', effectivePlayers);\n    \n    for (let i = 0; i < effectivePlayers.length; i++) {\n      const player = effectivePlayers[i];\n      if (\n        (player && player.address && (player.address === winner.winner || player.address === winner.fullAddress)) ||\n        (player && player.fullAddress && (player.fullAddress === winner.winner || player.fullAddress === winner.fullAddress)) ||\n        (player && player.username && player.username === winner.username) ||\n        (player && player.displayName && player.displayName === winner.displayName)\n      ) {\n        console.log(`Found winner at position ${i}:`, player);\n        return i;\n      }\n    }\n    console.warn('Winner not found in player list');\n    return -1;\n  }, [effectivePlayers]);\n\n  // Spin wheel function with improved accuracy\n  const spinWheel = useCallback((targetWinner) => {\n    if (wheelState === 'spinning' || !wheelRef.current) return;\n    \n    console.log('Starting spin with winner:', targetWinner);\n    \n    // Play launch sound when spin starts\n    soundService.playLaunch();\n    \n    setWheelState('spinning');\n    stopIdleMovement();\n    \n    const winnerPosition = findWinnerPosition(targetWinner);\n    if (winnerPosition === -1) {\n      console.warn('Winner not found in player list, spinning randomly');\n      // If winner not found, still spin but land on first player\n      const fallbackPosition = 0;\n      performSpin(fallbackPosition, targetWinner);\n            return;\n          }\n          \n    performSpin(winnerPosition, targetWinner);\n    \n  }, [wheelState, stopIdleMovement, findWinnerPosition, effectivePlayers.length, onSpinComplete, CARD_WIDTH]);\n\n  // Separate function to perform the actual spin animation\n  const performSpin = useCallback((winnerPosition, targetWinner) => {\n    const wheel = wheelRef.current;\n    if (!wheel) return;\n\n    // Calculate precise landing position\n    const wheelWidth = wheel.offsetWidth;\n    const centerOffset = wheelWidth / 2;\n    const firstCard = wheel.querySelector('.roulette-card');\n    const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n    const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n    const totalCardSpacing = actualCardWidth + cardMargin;\n    \n    console.log(`üìè Card measurements: width=${actualCardWidth}px, margin=${cardMargin}px, total=${totalCardSpacing}px`);\n    console.log(`üéØ Winner found at array position: ${winnerPosition}`);\n    \n    // CLASSIC SLOT MACHINE ANIMATION: Fast slide then slow down to winner\n    const cycleLength = effectivePlayers.length * totalCardSpacing;\n    const currentAbsolutePosition = Math.abs(currentPosition.current);\n    \n    // Calculate how far we need to slide to get the winner centered\n    // We want to slide fast past the winner, then slow down and land on it\n    const winnerOffset = winnerPosition * totalCardSpacing;\n    \n    // Slide at least 3 full cycles to create that \"fast spinning\" effect\n    // Then land precisely on the winner in the next visible cycle\n    const minimumSpinDistance = cycleLength * 3; // At least 3 full cycles\n    const targetCycle = Math.ceil((currentAbsolutePosition + minimumSpinDistance) / cycleLength);\n    const finalWinnerPosition = (targetCycle * cycleLength) + winnerOffset;\n    const finalPosition = -(finalWinnerPosition + (actualCardWidth / 2) - centerOffset);\n    \n    console.log(`üé∞ Classic slot machine calculation:`);\n    console.log(`   - Current position: ${currentPosition.current}px`);\n    console.log(`   - Winner position in array: ${winnerPosition}`);\n    console.log(`   - Winner offset: ${winnerOffset}px`);\n    console.log(`   - Minimum spin distance: ${minimumSpinDistance}px`);\n    console.log(`   - Target cycle: ${targetCycle}`);\n    console.log(`   - Final winner position: ${finalWinnerPosition}px`);\n    console.log(`   - Final position: ${finalPosition}px`);\n    console.log(`   - Total slide distance: ${Math.abs(finalPosition - currentPosition.current)}px`);\n    \n    // Start ticking sound for the spinning effect\n    let tickInterval = setInterval(() => {\n      soundService.playSpinWithVolume(0.3);\n    }, 100); // Fast ticking initially\n    \n    // STAGE 1: Fast spinning for 2 seconds\n    wheel.style.transitionTimingFunction = 'linear';\n    wheel.style.transitionDuration = '2000ms';\n    \n    // Slide 80% of the way during fast phase\n    const fastPhasePosition = currentPosition.current + ((finalPosition - currentPosition.current) * 0.8);\n    wheel.style.transform = `translate3d(${fastPhasePosition}px, 0px, 0px)`;\n    currentPosition.current = fastPhasePosition;\n    \n    // STAGE 2: Slow down dramatically for final 20% over 3 seconds\n    setTimeout(() => {\n      // Slower ticking sound\n      clearInterval(tickInterval);\n      tickInterval = setInterval(() => {\n        soundService.playSpinWithVolume(0.4);\n      }, 300); // Much slower ticking\n      \n      wheel.style.transitionTimingFunction = 'cubic-bezier(0.05, 0.1, 0.05, 1)';\n      wheel.style.transitionDuration = '3000ms';\n      wheel.style.transform = `translate3d(${finalPosition}px, 0px, 0px)`;\n      currentPosition.current = finalPosition;\n      \n      // Stop ticking after slowdown completes\n      setTimeout(() => {\n        clearInterval(tickInterval);\n      }, 3000);\n      \n    }, 2000); // Wait 2 seconds for fast phase\n    \n    // After total animation (2s + 3s = 5s), show winner\n    setTimeout(() => {\n      console.log('Classic slot machine animation completed, showing winner');\n      setWheelState('winner');\n      \n      // Highlight the winner card\n      const allCards = wheel.querySelectorAll('.roulette-card');\n      console.log(`üéØ Highlighting winner at position ${winnerPosition} out of ${effectivePlayers.length} players`);\n      \n      allCards.forEach((card, index) => {\n        const cardPlayerIndex = index % effectivePlayers.length;\n        if (cardPlayerIndex === winnerPosition) {\n          card.classList.add('winner-highlight');\n          console.log(`‚ú® Highlighted card at index ${index} (player ${cardPlayerIndex})`);\n        }\n      });\n      \n      // After showcasing winner for 4 seconds, go to finished state\n      winnerShowcaseTimeoutRef.current = setTimeout(() => {\n        console.log('Winner showcase complete, entering finished state');\n        \n        // Remove winner highlights\n        const highlightedCards = wheel.querySelectorAll('.winner-highlight');\n        highlightedCards.forEach(card => {\n          card.classList.remove('winner-highlight');\n        });\n        \n        // Reset transition styles\n        wheel.style.transitionTimingFunction = '';\n        wheel.style.transitionDuration = '';\n        \n        // Clear locked players\n        setLockedPlayers([]);\n        \n        setWheelState('finished');\n        onSpinComplete?.(targetWinner);\n      }, 4000); // Show winner for 4 seconds\n      \n    }, 5000); // Wait 5 seconds for both phases (2s fast + 3s slow)\n    \n  }, [effectivePlayers.length, CARD_WIDTH, onSpinComplete]);\n\n  // Handle state changes\n  useEffect(() => {\n    if (isSpinning && contractWinner && wheelState === 'waiting') {\n      // Backend responded with winner, start spinning\n      console.log('Starting roulette spin with winner:', contractWinner);\n      spinWheel(contractWinner);\n    } else if (isSpinning && !contractWinner && wheelState === 'idle') {\n      // Bet placed, stop and wait for backend\n      console.log('Stopping wheel, waiting for winner...');\n      setWheelState('waiting');\n      stopIdleMovement();\n    } else if (!isSpinning && wheelState !== 'idle' && wheelState !== 'winner' && wheelState !== 'finished') {\n      // Reset to idle state (but don't interrupt winner showcase or finished state)\n      console.log('Resetting to idle state');\n      setWheelState('idle');\n    }\n  }, [isSpinning, contractWinner, wheelState, spinWheel, stopIdleMovement]);\n\n  // Detect new game start and reset from finished state to idle\n  useEffect(() => {\n    // If we're in finished state and there's no winner (new game starting), reset to idle\n    if (wheelState === 'finished' && !contractWinner && !isSpinning) {\n      console.log('New game detected - resetting from finished to idle');\n      setWheelState('idle');\n    }\n  }, [wheelState, contractWinner, isSpinning]);\n\n  // Start/stop idle movement based on state\n  useEffect(() => {\n    if (wheelState === 'idle') {\n      startIdleMovement();\n    } else {\n      stopIdleMovement();\n    }\n    \n    return () => stopIdleMovement();\n  }, [wheelState, startIdleMovement, stopIdleMovement]);\n\n  // Initialize wheel when effective players change (but not during winner showcase)\n  useEffect(() => {\n    // Don't reinitialize during winner showcase or finished state to preserve highlighting\n    if (wheelState !== 'winner' && wheelState !== 'finished') {\n      initWheel();\n    }\n  }, [initWheel, wheelState]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (winnerShowcaseTimeoutRef.current) {\n        clearTimeout(winnerShowcaseTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  if (!effectivePlayers || effectivePlayers.length === 0) {\n    return (\n      <div className=\"simple-carousel\">\n        <div className=\"carousel-message\">\n          Waiting for players to join...\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"roulette-wrapper\">\n      {/* Center selector line */}\n      <div className=\"roulette-selector\"></div>\n      \n      {/* Spinning wheel */}\n      <div ref={wheelRef} className=\"roulette-wheel\"></div>\n      \n      {/* State indicator */}\n      <div className=\"wheel-state-indicator\">\n        {wheelState === 'idle' && <span>üé∞</span>}\n        {wheelState === 'waiting' && <span>‚è≥</span>}\n        {wheelState === 'spinning' && <span>üéØ</span>}\n        {wheelState === 'winner' && <span>üéâ</span>}\n        {wheelState === 'finished' && <span>üèÅ</span>}\n      </div>\n      \n      {/* Glare Effect */}\n      <div \n        className=\"absolute -top-1/4 -right-1/3 h-full opacity-75 will-change-transform z-[3] pointer-events-none\"\n        style={{ maskImage: 'linear-gradient(black, transparent 50%)' }}\n      >\n        <img src=\"/img/glare.webp\" className=\"w-full object-cover object-center\" alt=\"\" />\n              </div>\n    </div>\n  );\n};\n\nexport default SimpleCarousel; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}