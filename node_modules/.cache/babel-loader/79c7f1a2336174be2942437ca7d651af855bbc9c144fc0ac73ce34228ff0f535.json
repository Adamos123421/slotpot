{"ast":null,"code":"import { Address, beginCell, Cell, toNano } from '@ton/core';\nimport { TonClient } from '@ton/ton';\n\n// Contract configuration\nexport const JACKPOT_CONTRACT_CONFIG = {\n  // ‚ö†Ô∏è IMPORTANT: Replace this with your actual deployed contract address!\n  // This is just a placeholder - transactions will fail with wrong address\n  address: process.env.REACT_APP_CONTRACT_ADDRESS || \"REPLACE_WITH_YOUR_ACTUAL_CONTRACT_ADDRESS\",\n  // Admin configuration - in production, use environment variables\n  adminMnemonic: \"cabin flame border diary parent web extend stable hungry cabin alley cable bulk nasty learn toe recipe pluck memory twist wheel boost execute caution\".split(' ') || [],\n  // TON Client configuration\n  endpoint: process.env.REACT_APP_TON_ENDPOINT || 'https://toncenter.com/api/v2/jsonRPC',\n  apiKey: \"cb6a181146fafbe2adc51d3a21d27341aa8a93cbf581e03a80e9e7203a3abd65\"\n};\n\n// Message constructors for contract interactions\nexport const ContractMessages = {\n  // Admin messages\n  startJackpot: (queryId = 0) => {\n    return beginCell().storeUint(0x12345678, 32) // Replace with actual op code\n    .storeUint(queryId, 64).endCell();\n  },\n  endJackpot: (queryId = 0) => {\n    return beginCell().storeUint(0x87654321, 32) // Replace with actual op code  \n    .storeUint(queryId, 64).endCell();\n  },\n  placeBet: (queryId = 0) => {\n    return beginCell().storeUint(0x03, 32) // PlaceBet opcode as specified in contract\n    .storeUint(queryId, 64) // query_id as uint64\n    .endCell();\n  }\n};\nexport class JackpotContract {\n  constructor() {\n    this.client = new TonClient({\n      endpoint: JACKPOT_CONTRACT_CONFIG.endpoint,\n      apiKey: JACKPOT_CONTRACT_CONFIG.apiKey\n    });\n    this.contractAddress = Address.parse(\"EQAO-eknIHULYsinQdpEb8oPVQy6eUXz0-zAPTKi1QTAJkjo\");\n\n    // Debug contract address on initialization\n    console.log('üèóÔ∏è JackpotContract initialized:', {\n      configAddress: JACKPOT_CONTRACT_CONFIG.address,\n      parsedAddress: this.contractAddress.toString(),\n      fromEnv: !!process.env.REACT_APP_CONTRACT_ADDRESS\n    });\n  }\n\n  // Contract getters - these call the smart contract's get methods\n  async getTotalJackpot() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getTotalJackpot\");\n\n      // Parse the result from stack\n      const jackpotAmount = result.stack.readBigNumber();\n      return Number(jackpotAmount) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching jackpot amount:', error);\n      return 0;\n    }\n  }\n  async isJackpotActive() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"isJackpotActive\");\n      return result.stack.readBoolean();\n    } catch (error) {\n      console.error('Error fetching jackpot status:', error);\n      return false;\n    }\n  }\n  async getBetCount() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getBetCount\");\n      return result.stack.readNumber();\n    } catch (error) {\n      console.error('Error fetching bet count:', error);\n      return 0;\n    }\n  }\n  async getBettorAmount(bettorAddress) {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getBettorAmount\", [{\n        type: 'slice',\n        cell: beginCell().storeAddress(Address.parse(bettorAddress)).endCell()\n      }]);\n      const amount = result.stack.readBigNumber();\n      return Number(amount) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching bettor amount:', error);\n      return 0;\n    }\n  }\n  async getWinningProbability(bettorAddress) {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getWinningProbability\", [{\n        type: 'slice',\n        cell: beginCell().storeAddress(Address.parse(bettorAddress)).endCell()\n      }]);\n      const probability = result.stack.readNumber();\n      return probability / 100; // Convert from basis points to percentage\n    } catch (error) {\n      console.error('Error fetching winning probability:', error);\n      return 0;\n    }\n  }\n  async getAllBettors() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getAllBettors\");\n\n      // Parse the dictionary result\n      // This will return a map of addresses to amounts\n      const bettorsDict = result.stack.readCellOpt();\n      if (!bettorsDict) return {};\n\n      // Parse the dictionary - implementation depends on exact contract structure\n      // For now, return empty object - you'll need to implement dictionary parsing\n      return {};\n    } catch (error) {\n      console.error('Error fetching all bettors:', error);\n      return {};\n    }\n  }\n  async getLastWinner() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getLastWinner\");\n      const winnerCell = result.stack.readCellOpt();\n      if (!winnerCell) return null;\n\n      // Parse address from cell\n      const slice = winnerCell.beginParse();\n      const winnerAddress = slice.loadAddress();\n      return winnerAddress === null || winnerAddress === void 0 ? void 0 : winnerAddress.toString();\n    } catch (error) {\n      console.error('Error fetching last winner:', error);\n      return null;\n    }\n  }\n  async getLastPrizeAmount() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getLastPrizeAmount\");\n      const prizeAmount = result.stack.readBigNumber();\n      return Number(prizeAmount) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching last prize amount:', error);\n      return 0;\n    }\n  }\n  async getContractBalance() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getBalance\");\n      const balance = result.stack.readBigNumber();\n      return Number(balance) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching contract balance:', error);\n      return 0;\n    }\n  }\n\n  // Transaction builders for sending to the contract\n  buildBetTransaction(betAmount, senderAddress) {\n    // Ensure betAmount is a valid number\n    console.log(`üîç buildBetTransaction input:`, {\n      betAmount,\n      type: typeof betAmount\n    });\n    const numericBetAmount = Number(betAmount);\n    console.log(`üîç After Number() conversion:`, {\n      numericBetAmount,\n      isNaN: isNaN(numericBetAmount)\n    });\n    if (isNaN(numericBetAmount)) {\n      console.log('Invalid bet amount:', betAmount);\n      throw new Error(`Invalid bet amount: ${betAmount}`);\n    }\n\n    // Add 0.05 TON fee to the bet amount for the transaction\n    const totalAmount = numericBetAmount + 0.05;\n    console.log(`üîç totalAmount calculation:`, {\n      numericBetAmount,\n      totalAmount\n    });\n    // Ensure proper string formatting for toNano function\n    const totalAmountString = totalAmount.toFixed(9); // Use 9 decimal places for precision\n    console.log(`üîç totalAmountString:`, totalAmountString);\n    const totalAmountNano = toNano(totalAmountString);\n    // Generate unique query_id for this bet\n    const queryId = Date.now() * 1000 + Math.floor(Math.random() * 1000);\n    console.log(`üîß Building bet transaction:`, {\n      userBetAmount: numericBetAmount + ' TON',\n      feeAmount: '0.05 TON',\n      totalAmount: totalAmount + ' TON',\n      totalAmountNano: totalAmountNano.toString(),\n      queryId,\n      senderAddress,\n      contractAddress: this.contractAddress.toString(),\n      // Check if contract address equals sender address (this would be wrong!)\n      addressesMatch: this.contractAddress.toString() === senderAddress,\n      usingEnvAddress: !!process.env.REACT_APP_CONTRACT_ADDRESS\n    });\n    const payload = ContractMessages.placeBet(queryId);\n    console.log(`üì¶ PlaceBet message payload:`, payload.toBoc().toString('base64'));\n\n    // Verify the message structure immediately\n    try {\n      const cell = payload;\n      const slice = cell.beginParse();\n      const opCode = slice.loadUint(32);\n      const decodedQueryId = slice.loadUint(64);\n      console.log(`‚úÖ Message verification:`, {\n        opCode: `0x${opCode.toString(16).padStart(2, '0')}`,\n        queryId: decodedQueryId,\n        isCorrectOpCode: opCode === 0x03,\n        matches: queryId === decodedQueryId\n      });\n    } catch (error) {\n      console.error('‚ùå Message verification failed:', error);\n    }\n    const transaction = {\n      validUntil: Math.floor(Date.now() / 1000) + 600,\n      // 10 minutes\n      messages: [{\n        address: this.contractAddress.toString(),\n        amount: totalAmountNano.toString(),\n        payload: payload.toBoc().toString('base64')\n      }]\n    };\n    console.log(`üéØ Final transaction will be sent to:`, {\n      destinationAddress: transaction.messages[0].address,\n      amount: transaction.messages[0].amount + ' nanotons',\n      userBetAmount: numericBetAmount + ' TON',\n      feeAmount: '0.05 TON',\n      totalAmount: totalAmount + ' TON',\n      senderAddress: senderAddress,\n      isGoingToContract: transaction.messages[0].address !== senderAddress\n    });\n    return transaction;\n  }\n  buildStartJackpotTransaction() {\n    return {\n      validUntil: Math.floor(Date.now() / 1000) + 600,\n      // 10 minutes\n      messages: [{\n        address: this.contractAddress.toString(),\n        amount: toNano('0.05').toString(),\n        // Gas fee\n        payload: ContractMessages.startJackpot(Date.now()).toBoc().toString('base64')\n      }]\n    };\n  }\n  buildEndJackpotTransaction() {\n    return {\n      validUntil: Math.floor(Date.now() / 1000) + 600,\n      // 10 minutes\n      messages: [{\n        address: this.contractAddress.toString(),\n        amount: toNano('0.05').toString(),\n        // Gas fee\n        payload: ContractMessages.endJackpot(Date.now()).toBoc().toString('base64')\n      }]\n    };\n  }\n\n  // Utility method to get comprehensive contract state\n  async getContractState() {\n    try {\n      const [totalJackpot, isActive, betCount, lastWinner, lastPrizeAmount, contractBalance] = await Promise.all([this.getTotalJackpot(), this.isJackpotActive(), this.getBetCount(), this.getLastWinner(), this.getLastPrizeAmount(), this.getContractBalance()]);\n      return {\n        totalJackpot,\n        isActive,\n        betCount,\n        lastWinner,\n        lastPrizeAmount,\n        contractBalance,\n        timestamp: Date.now()\n      };\n    } catch (error) {\n      console.error('Error fetching contract state:', error);\n      return {\n        totalJackpot: 0,\n        isActive: false,\n        betCount: 0,\n        lastWinner: null,\n        lastPrizeAmount: 0,\n        contractBalance: 0,\n        timestamp: Date.now(),\n        error: error.message\n      };\n    }\n  }\n}\n\n// Create a singleton instance\nexport const jackpotContract = new JackpotContract();\n\n// Export utility functions\nexport const formatTonAmount = amount => {\n  return Number(amount).toFixed(3);\n};\nexport const formatAddress = address => {\n  if (!address) return '';\n  return `${address.slice(0, 6)}...${address.slice(-4)}`;\n};\n\n// Utility function to decode and verify PlaceBet message\nexport const decodePlaceBetMessage = base64Payload => {\n  try {\n    const cell = Cell.fromBase64(base64Payload);\n    const slice = cell.beginParse();\n    const opCode = slice.loadUint(32);\n    const queryId = slice.loadUint(64);\n    console.log(`üîç Decoded PlaceBet message:`, {\n      opCode: `0x${opCode.toString(16).padStart(2, '0')}`,\n      queryId,\n      isCorrectOpCode: opCode === 0x03\n    });\n    return {\n      opCode,\n      queryId,\n      isValid: opCode === 0x03\n    };\n  } catch (error) {\n    console.error('Error decoding PlaceBet message:', error);\n    return null;\n  }\n};","map":{"version":3,"names":["Address","beginCell","Cell","toNano","TonClient","JACKPOT_CONTRACT_CONFIG","address","process","env","REACT_APP_CONTRACT_ADDRESS","adminMnemonic","split","endpoint","REACT_APP_TON_ENDPOINT","apiKey","ContractMessages","startJackpot","queryId","storeUint","endCell","endJackpot","placeBet","JackpotContract","constructor","client","contractAddress","parse","console","log","configAddress","parsedAddress","toString","fromEnv","getTotalJackpot","result","runMethod","jackpotAmount","stack","readBigNumber","Number","error","isJackpotActive","readBoolean","getBetCount","readNumber","getBettorAmount","bettorAddress","type","cell","storeAddress","amount","getWinningProbability","probability","getAllBettors","bettorsDict","readCellOpt","getLastWinner","winnerCell","slice","beginParse","winnerAddress","loadAddress","getLastPrizeAmount","prizeAmount","getContractBalance","balance","buildBetTransaction","betAmount","senderAddress","numericBetAmount","isNaN","Error","totalAmount","totalAmountString","toFixed","totalAmountNano","Date","now","Math","floor","random","userBetAmount","feeAmount","addressesMatch","usingEnvAddress","payload","toBoc","opCode","loadUint","decodedQueryId","padStart","isCorrectOpCode","matches","transaction","validUntil","messages","destinationAddress","isGoingToContract","buildStartJackpotTransaction","buildEndJackpotTransaction","getContractState","totalJackpot","isActive","betCount","lastWinner","lastPrizeAmount","contractBalance","Promise","all","timestamp","message","jackpotContract","formatTonAmount","formatAddress","decodePlaceBetMessage","base64Payload","fromBase64","isValid"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/src/services/jackpotContract.js"],"sourcesContent":["import { Address, beginCell, Cell, toNano } from '@ton/core';\nimport { TonClient } from '@ton/ton';\n\n// Contract configuration\nexport const JACKPOT_CONTRACT_CONFIG = {\n  // ‚ö†Ô∏è IMPORTANT: Replace this with your actual deployed contract address!\n  // This is just a placeholder - transactions will fail with wrong address\n  address: process.env.REACT_APP_CONTRACT_ADDRESS || \"REPLACE_WITH_YOUR_ACTUAL_CONTRACT_ADDRESS\",\n  \n  // Admin configuration - in production, use environment variables\n  adminMnemonic: \"cabin flame border diary parent web extend stable hungry cabin alley cable bulk nasty learn toe recipe pluck memory twist wheel boost execute caution\".split(' ') || [],\n  \n  // TON Client configuration\n  endpoint: process.env.REACT_APP_TON_ENDPOINT || 'https://toncenter.com/api/v2/jsonRPC',\n  apiKey: \"cb6a181146fafbe2adc51d3a21d27341aa8a93cbf581e03a80e9e7203a3abd65\"\n};\n\n// Message constructors for contract interactions\nexport const ContractMessages = {\n  // Admin messages\n  startJackpot: (queryId = 0) => {\n    return beginCell()\n      .storeUint(0x12345678, 32) // Replace with actual op code\n      .storeUint(queryId, 64)\n      .endCell();\n  },\n\n  endJackpot: (queryId = 0) => {\n    return beginCell()\n      .storeUint(0x87654321, 32) // Replace with actual op code  \n      .storeUint(queryId, 64)\n      .endCell();\n  },\n\n  placeBet: (queryId = 0) => {\n    return beginCell()\n      .storeUint(0x03, 32) // PlaceBet opcode as specified in contract\n      .storeUint(queryId, 64) // query_id as uint64\n      .endCell();\n  }\n};\n\nexport class JackpotContract {\n  constructor() {\n    this.client = new TonClient({\n      endpoint: JACKPOT_CONTRACT_CONFIG.endpoint,\n      apiKey: JACKPOT_CONTRACT_CONFIG.apiKey\n    });\n    \n    this.contractAddress = Address.parse(\"EQAO-eknIHULYsinQdpEb8oPVQy6eUXz0-zAPTKi1QTAJkjo\");\n    \n    // Debug contract address on initialization\n    console.log('üèóÔ∏è JackpotContract initialized:', {\n      configAddress: JACKPOT_CONTRACT_CONFIG.address,\n      parsedAddress: this.contractAddress.toString(),\n      fromEnv: !!process.env.REACT_APP_CONTRACT_ADDRESS\n    });\n  }\n\n  // Contract getters - these call the smart contract's get methods\n  async getTotalJackpot() {\n    try {\n      const result = await this.client.runMethod(\n        this.contractAddress,\n        \"getTotalJackpot\"\n      );\n      \n      // Parse the result from stack\n      const jackpotAmount = result.stack.readBigNumber();\n      return Number(jackpotAmount) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching jackpot amount:', error);\n      return 0;\n    }\n  }\n\n  async isJackpotActive() {\n    try {\n      const result = await this.client.runMethod(\n        this.contractAddress,\n        \"isJackpotActive\"\n      );\n      \n      return result.stack.readBoolean();\n    } catch (error) {\n      console.error('Error fetching jackpot status:', error);\n      return false;\n    }\n  }\n\n  async getBetCount() {\n    try {\n      const result = await this.client.runMethod(\n        this.contractAddress,\n        \"getBetCount\"\n      );\n      \n      return result.stack.readNumber();\n    } catch (error) {\n      console.error('Error fetching bet count:', error);\n      return 0;\n    }\n  }\n\n  async getBettorAmount(bettorAddress) {\n    try {\n      const result = await this.client.runMethod(\n        this.contractAddress,\n        \"getBettorAmount\",\n        [\n          { type: 'slice', cell: beginCell().storeAddress(Address.parse(bettorAddress)).endCell() }\n        ]\n      );\n      \n      const amount = result.stack.readBigNumber();\n      return Number(amount) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching bettor amount:', error);\n      return 0;\n    }\n  }\n\n  async getWinningProbability(bettorAddress) {\n    try {\n      const result = await this.client.runMethod(\n        this.contractAddress,\n        \"getWinningProbability\",\n        [\n          { type: 'slice', cell: beginCell().storeAddress(Address.parse(bettorAddress)).endCell() }\n        ]\n      );\n      \n      const probability = result.stack.readNumber();\n      return probability / 100; // Convert from basis points to percentage\n    } catch (error) {\n      console.error('Error fetching winning probability:', error);\n      return 0;\n    }\n  }\n\n  async getAllBettors() {\n    try {\n      const result = await this.client.runMethod(\n        this.contractAddress,\n        \"getAllBettors\"\n      );\n      \n      // Parse the dictionary result\n      // This will return a map of addresses to amounts\n      const bettorsDict = result.stack.readCellOpt();\n      \n      if (!bettorsDict) return {};\n      \n      // Parse the dictionary - implementation depends on exact contract structure\n      // For now, return empty object - you'll need to implement dictionary parsing\n      return {};\n    } catch (error) {\n      console.error('Error fetching all bettors:', error);\n      return {};\n    }\n  }\n\n  async getLastWinner() {\n    try {\n      const result = await this.client.runMethod(\n        this.contractAddress,\n        \"getLastWinner\"\n      );\n      \n      const winnerCell = result.stack.readCellOpt();\n      if (!winnerCell) return null;\n      \n      // Parse address from cell\n      const slice = winnerCell.beginParse();\n      const winnerAddress = slice.loadAddress();\n      \n      return winnerAddress?.toString();\n    } catch (error) {\n      console.error('Error fetching last winner:', error);\n      return null;\n    }\n  }\n\n  async getLastPrizeAmount() {\n    try {\n      const result = await this.client.runMethod(\n        this.contractAddress,\n        \"getLastPrizeAmount\"\n      );\n      \n      const prizeAmount = result.stack.readBigNumber();\n      return Number(prizeAmount) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching last prize amount:', error);\n      return 0;\n    }\n  }\n\n  async getContractBalance() {\n    try {\n      const result = await this.client.runMethod(\n        this.contractAddress,\n        \"getBalance\"\n      );\n      \n      const balance = result.stack.readBigNumber();\n      return Number(balance) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching contract balance:', error);\n      return 0;\n    }\n  }\n\n  // Transaction builders for sending to the contract\n  buildBetTransaction(betAmount, senderAddress) {\n    // Ensure betAmount is a valid number\n    console.log(`üîç buildBetTransaction input:`, { betAmount, type: typeof betAmount });\n    const numericBetAmount = Number(betAmount);\n    console.log(`üîç After Number() conversion:`, { numericBetAmount, isNaN: isNaN(numericBetAmount) });\n    if (isNaN(numericBetAmount)) {\n      console.log('Invalid bet amount:', betAmount);\n      throw new Error(`Invalid bet amount: ${betAmount}`);\n    }\n    \n    // Add 0.05 TON fee to the bet amount for the transaction\n    const totalAmount = numericBetAmount + 0.05;\n    console.log(`üîç totalAmount calculation:`, { numericBetAmount, totalAmount });\n    // Ensure proper string formatting for toNano function\n    const totalAmountString = totalAmount.toFixed(9); // Use 9 decimal places for precision\n    console.log(`üîç totalAmountString:`, totalAmountString);\n    const totalAmountNano = toNano(totalAmountString);\n    // Generate unique query_id for this bet\n    const queryId = Date.now() * 1000 + Math.floor(Math.random() * 1000);\n    \n    console.log(`üîß Building bet transaction:`, {\n      userBetAmount: numericBetAmount + ' TON',\n      feeAmount: '0.05 TON',\n      totalAmount: totalAmount + ' TON',\n      totalAmountNano: totalAmountNano.toString(),\n      queryId,\n      senderAddress,\n      contractAddress: this.contractAddress.toString(),\n      // Check if contract address equals sender address (this would be wrong!)\n      addressesMatch: this.contractAddress.toString() === senderAddress,\n      usingEnvAddress: !!process.env.REACT_APP_CONTRACT_ADDRESS\n    });\n    \n    const payload = ContractMessages.placeBet(queryId);\n    console.log(`üì¶ PlaceBet message payload:`, payload.toBoc().toString('base64'));\n    \n    // Verify the message structure immediately\n    try {\n      const cell = payload;\n      const slice = cell.beginParse();\n      const opCode = slice.loadUint(32);\n      const decodedQueryId = slice.loadUint(64);\n      \n      console.log(`‚úÖ Message verification:`, {\n        opCode: `0x${opCode.toString(16).padStart(2, '0')}`,\n        queryId: decodedQueryId,\n        isCorrectOpCode: opCode === 0x03,\n        matches: queryId === decodedQueryId\n      });\n    } catch (error) {\n      console.error('‚ùå Message verification failed:', error);\n    }\n    \n    const transaction = {\n      validUntil: Math.floor(Date.now() / 1000) + 600, // 10 minutes\n      messages: [\n        {\n          address: this.contractAddress.toString(),\n          amount: totalAmountNano.toString(),\n          payload: payload.toBoc().toString('base64')\n        }\n      ]\n    };\n    \n    console.log(`üéØ Final transaction will be sent to:`, {\n      destinationAddress: transaction.messages[0].address,\n      amount: transaction.messages[0].amount + ' nanotons',\n      userBetAmount: numericBetAmount + ' TON',\n      feeAmount: '0.05 TON',\n      totalAmount: totalAmount + ' TON',\n      senderAddress: senderAddress,\n      isGoingToContract: transaction.messages[0].address !== senderAddress\n    });\n    \n    return transaction;\n  }\n\n  buildStartJackpotTransaction() {\n    return {\n      validUntil: Math.floor(Date.now() / 1000) + 600, // 10 minutes\n      messages: [\n        {\n          address: this.contractAddress.toString(),\n          amount: toNano('0.05').toString(), // Gas fee\n          payload: ContractMessages.startJackpot(Date.now()).toBoc().toString('base64')\n        }\n      ]\n    };\n  }\n\n  buildEndJackpotTransaction() {\n    return {\n      validUntil: Math.floor(Date.now() / 1000) + 600, // 10 minutes\n      messages: [\n        {\n          address: this.contractAddress.toString(),\n          amount: toNano('0.05').toString(), // Gas fee\n          payload: ContractMessages.endJackpot(Date.now()).toBoc().toString('base64')\n        }\n      ]\n    };\n  }\n\n  // Utility method to get comprehensive contract state\n  async getContractState() {\n    try {\n      const [\n        totalJackpot,\n        isActive,\n        betCount,\n        lastWinner,\n        lastPrizeAmount,\n        contractBalance\n      ] = await Promise.all([\n        this.getTotalJackpot(),\n        this.isJackpotActive(),\n        this.getBetCount(),\n        this.getLastWinner(),\n        this.getLastPrizeAmount(),\n        this.getContractBalance()\n      ]);\n\n      return {\n        totalJackpot,\n        isActive,\n        betCount,\n        lastWinner,\n        lastPrizeAmount,\n        contractBalance,\n        timestamp: Date.now()\n      };\n    } catch (error) {\n      console.error('Error fetching contract state:', error);\n      return {\n        totalJackpot: 0,\n        isActive: false,\n        betCount: 0,\n        lastWinner: null,\n        lastPrizeAmount: 0,\n        contractBalance: 0,\n        timestamp: Date.now(),\n        error: error.message\n      };\n    }\n  }\n}\n\n// Create a singleton instance\nexport const jackpotContract = new JackpotContract();\n\n// Export utility functions\nexport const formatTonAmount = (amount) => {\n  return Number(amount).toFixed(3);\n};\n\nexport const formatAddress = (address) => {\n  if (!address) return '';\n  return `${address.slice(0, 6)}...${address.slice(-4)}`;\n};\n\n// Utility function to decode and verify PlaceBet message\nexport const decodePlaceBetMessage = (base64Payload) => {\n  try {\n    const cell = Cell.fromBase64(base64Payload);\n    const slice = cell.beginParse();\n    \n    const opCode = slice.loadUint(32);\n    const queryId = slice.loadUint(64);\n    \n    console.log(`üîç Decoded PlaceBet message:`, {\n      opCode: `0x${opCode.toString(16).padStart(2, '0')}`,\n      queryId,\n      isCorrectOpCode: opCode === 0x03\n    });\n    \n    return {\n      opCode,\n      queryId,\n      isValid: opCode === 0x03\n    };\n  } catch (error) {\n    console.error('Error decoding PlaceBet message:', error);\n    return null;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}