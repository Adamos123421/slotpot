{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeInternalKey = exports.serializeInternalKey = void 0;\nconst Address_1 = require(\"../../address/Address\");\nconst BitString_1 = require(\"../../boc/BitString\");\nconst paddedBits_1 = require(\"../../boc/utils/paddedBits\");\nfunction serializeInternalKey(value) {\n  if (typeof value === 'number') {\n    if (!Number.isSafeInteger(value)) {\n      throw Error('Invalid key type: not a safe integer: ' + value);\n    }\n    return 'n:' + value.toString(10);\n  } else if (typeof value === 'bigint') {\n    return 'b:' + value.toString(10);\n  } else if (Address_1.Address.isAddress(value)) {\n    return 'a:' + value.toString();\n  } else if (Buffer.isBuffer(value)) {\n    return 'f:' + value.toString('hex');\n  } else if (BitString_1.BitString.isBitString(value)) {\n    return 'B:' + value.toString();\n  } else {\n    throw Error('Invalid key type');\n  }\n}\nexports.serializeInternalKey = serializeInternalKey;\nfunction deserializeInternalKey(value) {\n  let k = value.slice(0, 2);\n  let v = value.slice(2);\n  if (k === 'n:') {\n    return parseInt(v, 10);\n  } else if (k === 'b:') {\n    return BigInt(v);\n  } else if (k === 'a:') {\n    return Address_1.Address.parse(v);\n  } else if (k === 'f:') {\n    return Buffer.from(v, 'hex');\n  } else if (k === 'B:') {\n    const lastDash = v.slice(-1) == \"_\";\n    const isPadded = lastDash || v.length % 2 != 0;\n    if (isPadded) {\n      let charLen = lastDash ? v.length - 1 : v.length;\n      const padded = v.substr(0, charLen) + \"0\"; //Padding\n      if (!lastDash && (charLen & 1) !== 0) {\n        // Four bit nibmle without padding\n        return new BitString_1.BitString(Buffer.from(padded, 'hex'), 0, charLen << 2);\n      } else {\n        return (0, paddedBits_1.paddedBufferToBits)(Buffer.from(padded, 'hex'));\n      }\n    } else {\n      return new BitString_1.BitString(Buffer.from(v, 'hex'), 0, v.length << 2);\n    }\n  }\n  throw Error('Invalid key type: ' + k);\n}\nexports.deserializeInternalKey = deserializeInternalKey;","map":{"version":3,"names":["Object","defineProperty","exports","value","deserializeInternalKey","serializeInternalKey","Address_1","require","BitString_1","paddedBits_1","Number","isSafeInteger","Error","toString","Address","isAddress","Buffer","isBuffer","BitString","isBitString","k","slice","v","parseInt","BigInt","parse","from","lastDash","isPadded","length","charLen","padded","substr","paddedBufferToBits"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/dict/utils/internalKeySerializer.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeInternalKey = exports.serializeInternalKey = void 0;\nconst Address_1 = require(\"../../address/Address\");\nconst BitString_1 = require(\"../../boc/BitString\");\nconst paddedBits_1 = require(\"../../boc/utils/paddedBits\");\nfunction serializeInternalKey(value) {\n    if (typeof value === 'number') {\n        if (!Number.isSafeInteger(value)) {\n            throw Error('Invalid key type: not a safe integer: ' + value);\n        }\n        return 'n:' + value.toString(10);\n    }\n    else if (typeof value === 'bigint') {\n        return 'b:' + value.toString(10);\n    }\n    else if (Address_1.Address.isAddress(value)) {\n        return 'a:' + value.toString();\n    }\n    else if (Buffer.isBuffer(value)) {\n        return 'f:' + value.toString('hex');\n    }\n    else if (BitString_1.BitString.isBitString(value)) {\n        return 'B:' + value.toString();\n    }\n    else {\n        throw Error('Invalid key type');\n    }\n}\nexports.serializeInternalKey = serializeInternalKey;\nfunction deserializeInternalKey(value) {\n    let k = value.slice(0, 2);\n    let v = value.slice(2);\n    if (k === 'n:') {\n        return parseInt(v, 10);\n    }\n    else if (k === 'b:') {\n        return BigInt(v);\n    }\n    else if (k === 'a:') {\n        return Address_1.Address.parse(v);\n    }\n    else if (k === 'f:') {\n        return Buffer.from(v, 'hex');\n    }\n    else if (k === 'B:') {\n        const lastDash = v.slice(-1) == \"_\";\n        const isPadded = lastDash || v.length % 2 != 0;\n        if (isPadded) {\n            let charLen = lastDash ? v.length - 1 : v.length;\n            const padded = v.substr(0, charLen) + \"0\"; //Padding\n            if ((!lastDash) && ((charLen & 1) !== 0)) {\n                // Four bit nibmle without padding\n                return new BitString_1.BitString(Buffer.from(padded, 'hex'), 0, charLen << 2);\n            }\n            else {\n                return (0, paddedBits_1.paddedBufferToBits)(Buffer.from(padded, 'hex'));\n            }\n        }\n        else {\n            return new BitString_1.BitString(Buffer.from(v, 'hex'), 0, v.length << 2);\n        }\n    }\n    throw Error('Invalid key type: ' + k);\n}\nexports.deserializeInternalKey = deserializeInternalKey;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}