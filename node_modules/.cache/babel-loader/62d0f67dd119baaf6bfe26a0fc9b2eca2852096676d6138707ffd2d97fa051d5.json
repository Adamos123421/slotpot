{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitBuilder = void 0;\nconst Address_1 = require(\"../address/Address\");\nconst ExternalAddress_1 = require(\"../address/ExternalAddress\");\nconst BitString_1 = require(\"./BitString\");\n/**\n * Class for building bit strings\n */\nclass BitBuilder {\n  constructor() {\n    let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1023;\n    this._buffer = Buffer.alloc(Math.ceil(size / 8));\n    this._length = 0;\n  }\n  /**\n   * Current number of bits written\n   */\n  get length() {\n    return this._length;\n  }\n  /**\n   * Write a single bit\n   * @param value bit to write, true or positive number for 1, false or zero or negative for 0\n   */\n  writeBit(value) {\n    // Check overflow\n    let n = this._length;\n    if (n > this._buffer.length * 8) {\n      throw new Error(\"BitBuilder overflow\");\n    }\n    // Set bit\n    if (typeof value === 'boolean' && value === true || typeof value === 'number' && value > 0) {\n      this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;\n    }\n    // Advance\n    this._length++;\n  }\n  /**\n   * Copy bits from BitString\n   * @param src source bits\n   */\n  writeBits(src) {\n    for (let i = 0; i < src.length; i++) {\n      this.writeBit(src.at(i));\n    }\n  }\n  /**\n   * Write bits from buffer\n   * @param src source buffer\n   */\n  writeBuffer(src) {\n    // Special case for aligned offsets\n    if (this._length % 8 === 0) {\n      if (this._length + src.length * 8 > this._buffer.length * 8) {\n        throw new Error(\"BitBuilder overflow\");\n      }\n      src.copy(this._buffer, this._length / 8);\n      this._length += src.length * 8;\n    } else {\n      for (let i = 0; i < src.length; i++) {\n        this.writeUint(src[i], 8);\n      }\n    }\n  }\n  /**\n   * Write uint value\n   * @param value value as bigint or number\n   * @param bits number of bits to write\n   */\n  writeUint(value, bits) {\n    if (bits < 0 || !Number.isSafeInteger(bits)) {\n      throw Error(\"invalid bit length. Got \".concat(bits));\n    }\n    const v = BigInt(value);\n    if (bits === 0) {\n      if (v !== 0n) {\n        throw Error(\"value is not zero for \".concat(bits, \" bits. Got \").concat(value));\n      } else {\n        return;\n      }\n    }\n    const vBits = 1n << BigInt(bits);\n    if (v < 0 || v >= vBits) {\n      throw Error(\"bitLength is too small for a value \".concat(value, \". Got \").concat(bits));\n    }\n    if (this._length + bits > this._buffer.length * 8) {\n      throw new Error(\"BitBuilder overflow\");\n    }\n    const tillByte = 8 - this._length % 8;\n    if (tillByte > 0) {\n      const bidx = Math.floor(this._length / 8);\n      if (bits < tillByte) {\n        const wb = Number(v);\n        this._buffer[bidx] |= wb << tillByte - bits;\n        this._length += bits;\n      } else {\n        const wb = Number(v >> BigInt(bits - tillByte));\n        this._buffer[bidx] |= wb;\n        this._length += tillByte;\n      }\n    }\n    bits -= tillByte;\n    while (bits > 0) {\n      if (bits >= 8) {\n        this._buffer[this._length / 8] = Number(v >> BigInt(bits - 8) & 0xffn);\n        this._length += 8;\n        bits -= 8;\n      } else {\n        this._buffer[this._length / 8] = Number(v << BigInt(8 - bits) & 0xffn);\n        this._length += bits;\n        bits = 0;\n      }\n    }\n  }\n  /**\n   * Write int value\n   * @param value value as bigint or number\n   * @param bits number of bits to write\n   */\n  writeInt(value, bits) {\n    let v = BigInt(value);\n    if (bits < 0 || !Number.isSafeInteger(bits)) {\n      throw Error(\"invalid bit length. Got \".concat(bits));\n    }\n    // Corner case for zero bits\n    if (bits === 0) {\n      if (value !== 0n) {\n        throw Error(\"value is not zero for \".concat(bits, \" bits. Got \").concat(value));\n      } else {\n        return;\n      }\n    }\n    // Corner case for one bit\n    if (bits === 1) {\n      if (value !== -1n && value !== 0n) {\n        throw Error(\"value is not zero or -1 for \".concat(bits, \" bits. Got \").concat(value));\n      } else {\n        this.writeBit(value === -1n);\n        return;\n      }\n    }\n    // Check input\n    let vBits = 1n << BigInt(bits) - 1n;\n    if (v < -vBits || v >= vBits) {\n      throw Error(\"value is out of range for \".concat(bits, \" bits. Got \").concat(value));\n    }\n    // Write sign\n    if (v < 0) {\n      this.writeBit(true);\n      v = vBits + v;\n    } else {\n      this.writeBit(false);\n    }\n    // Write value\n    this.writeUint(v, bits - 1);\n  }\n  /**\n   * Wrtie var uint value, used for serializing coins\n   * @param value value to write as bigint or number\n   * @param bits header bits to write size\n   */\n  writeVarUint(value, bits) {\n    let v = BigInt(value);\n    if (bits < 0 || !Number.isSafeInteger(bits)) {\n      throw Error(\"invalid bit length. Got \".concat(bits));\n    }\n    if (v < 0) {\n      throw Error(\"value is negative. Got \".concat(value));\n    }\n    // Corner case for zero\n    if (v === 0n) {\n      // Write zero size\n      this.writeUint(0, bits);\n      return;\n    }\n    // Calculate size\n    const sizeBytes = Math.ceil(v.toString(2).length / 8); // Fastest way in most environments\n    const sizeBits = sizeBytes * 8;\n    // Write size\n    this.writeUint(sizeBytes, bits);\n    // Write number\n    this.writeUint(v, sizeBits);\n  }\n  /**\n   * Wrtie var int value, used for serializing coins\n   * @param value value to write as bigint or number\n   * @param bits header bits to write size\n   */\n  writeVarInt(value, bits) {\n    let v = BigInt(value);\n    if (bits < 0 || !Number.isSafeInteger(bits)) {\n      throw Error(\"invalid bit length. Got \".concat(bits));\n    }\n    // Corner case for zero\n    if (v === 0n) {\n      // Write zero size\n      this.writeUint(0, bits);\n      return;\n    }\n    // Calculate size\n    let v2 = v > 0 ? v : -v;\n    const sizeBytes = 1 + Math.ceil(v2.toString(2).length / 8); // Fastest way in most environments\n    const sizeBits = sizeBytes * 8;\n    // Write size\n    this.writeUint(sizeBytes, bits);\n    // Write number\n    this.writeInt(v, sizeBits);\n  }\n  /**\n   * Write coins in var uint format\n   * @param amount amount to write\n   */\n  writeCoins(amount) {\n    this.writeVarUint(amount, 4);\n  }\n  /**\n   * Write address\n   * @param address write address or address external\n   */\n  writeAddress(address) {\n    // Is empty address\n    if (address === null || address === undefined) {\n      this.writeUint(0, 2); // Empty address\n      return;\n    }\n    // Is Internal Address\n    if (Address_1.Address.isAddress(address)) {\n      this.writeUint(2, 2); // Internal address\n      this.writeUint(0, 1); // No anycast\n      this.writeInt(address.workChain, 8);\n      this.writeBuffer(address.hash);\n      return;\n    }\n    // Is External Address\n    if (ExternalAddress_1.ExternalAddress.isAddress(address)) {\n      this.writeUint(1, 2); // External address\n      this.writeUint(address.bits, 9);\n      this.writeUint(address.value, address.bits);\n      return;\n    }\n    // Invalid address\n    throw Error(\"Invalid address. Got \".concat(address));\n  }\n  /**\n   * Build BitString\n   * @returns result bit string\n   */\n  build() {\n    return new BitString_1.BitString(this._buffer, 0, this._length);\n  }\n  /**\n   * Build into Buffer\n   * @returns result buffer\n   */\n  buffer() {\n    if (this._length % 8 !== 0) {\n      throw new Error(\"BitBuilder buffer is not byte aligned\");\n    }\n    return this._buffer.subarray(0, this._length / 8);\n  }\n}\nexports.BitBuilder = BitBuilder;","map":{"version":3,"names":["Object","defineProperty","exports","value","BitBuilder","Address_1","require","ExternalAddress_1","BitString_1","constructor","size","arguments","length","undefined","_buffer","Buffer","alloc","Math","ceil","_length","writeBit","n","Error","writeBits","src","i","at","writeBuffer","copy","writeUint","bits","Number","isSafeInteger","concat","v","BigInt","vBits","tillByte","bidx","floor","wb","writeInt","writeVarUint","sizeBytes","toString","sizeBits","writeVarInt","v2","writeCoins","amount","writeAddress","address","Address","isAddress","workChain","hash","ExternalAddress","build","BitString","buffer","subarray"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/boc/BitBuilder.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitBuilder = void 0;\nconst Address_1 = require(\"../address/Address\");\nconst ExternalAddress_1 = require(\"../address/ExternalAddress\");\nconst BitString_1 = require(\"./BitString\");\n/**\n * Class for building bit strings\n */\nclass BitBuilder {\n    constructor(size = 1023) {\n        this._buffer = Buffer.alloc(Math.ceil(size / 8));\n        this._length = 0;\n    }\n    /**\n     * Current number of bits written\n     */\n    get length() {\n        return this._length;\n    }\n    /**\n     * Write a single bit\n     * @param value bit to write, true or positive number for 1, false or zero or negative for 0\n     */\n    writeBit(value) {\n        // Check overflow\n        let n = this._length;\n        if (n > this._buffer.length * 8) {\n            throw new Error(\"BitBuilder overflow\");\n        }\n        // Set bit\n        if ((typeof value === 'boolean' && value === true) || (typeof value === 'number' && value > 0)) {\n            this._buffer[(n / 8) | 0] |= 1 << (7 - (n % 8));\n        }\n        // Advance\n        this._length++;\n    }\n    /**\n     * Copy bits from BitString\n     * @param src source bits\n     */\n    writeBits(src) {\n        for (let i = 0; i < src.length; i++) {\n            this.writeBit(src.at(i));\n        }\n    }\n    /**\n     * Write bits from buffer\n     * @param src source buffer\n     */\n    writeBuffer(src) {\n        // Special case for aligned offsets\n        if (this._length % 8 === 0) {\n            if (this._length + src.length * 8 > this._buffer.length * 8) {\n                throw new Error(\"BitBuilder overflow\");\n            }\n            src.copy(this._buffer, this._length / 8);\n            this._length += src.length * 8;\n        }\n        else {\n            for (let i = 0; i < src.length; i++) {\n                this.writeUint(src[i], 8);\n            }\n        }\n    }\n    /**\n     * Write uint value\n     * @param value value as bigint or number\n     * @param bits number of bits to write\n     */\n    writeUint(value, bits) {\n        if (bits < 0 || !Number.isSafeInteger(bits)) {\n            throw Error(`invalid bit length. Got ${bits}`);\n        }\n        const v = BigInt(value);\n        if (bits === 0) {\n            if (v !== 0n) {\n                throw Error(`value is not zero for ${bits} bits. Got ${value}`);\n            }\n            else {\n                return;\n            }\n        }\n        const vBits = (1n << BigInt(bits));\n        if (v < 0 || v >= vBits) {\n            throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);\n        }\n        if (this._length + bits > this._buffer.length * 8) {\n            throw new Error(\"BitBuilder overflow\");\n        }\n        const tillByte = 8 - (this._length % 8);\n        if (tillByte > 0) {\n            const bidx = Math.floor(this._length / 8);\n            if (bits < tillByte) {\n                const wb = Number(v);\n                this._buffer[bidx] |= wb << (tillByte - bits);\n                this._length += bits;\n            }\n            else {\n                const wb = Number(v >> BigInt(bits - tillByte));\n                this._buffer[bidx] |= wb;\n                this._length += tillByte;\n            }\n        }\n        bits -= tillByte;\n        while (bits > 0) {\n            if (bits >= 8) {\n                this._buffer[this._length / 8] = Number((v >> BigInt(bits - 8)) & 0xffn);\n                this._length += 8;\n                bits -= 8;\n            }\n            else {\n                this._buffer[this._length / 8] = Number((v << BigInt(8 - bits)) & 0xffn);\n                this._length += bits;\n                bits = 0;\n            }\n        }\n    }\n    /**\n     * Write int value\n     * @param value value as bigint or number\n     * @param bits number of bits to write\n     */\n    writeInt(value, bits) {\n        let v = BigInt(value);\n        if (bits < 0 || !Number.isSafeInteger(bits)) {\n            throw Error(`invalid bit length. Got ${bits}`);\n        }\n        // Corner case for zero bits\n        if (bits === 0) {\n            if (value !== 0n) {\n                throw Error(`value is not zero for ${bits} bits. Got ${value}`);\n            }\n            else {\n                return;\n            }\n        }\n        // Corner case for one bit\n        if (bits === 1) {\n            if (value !== -1n && value !== 0n) {\n                throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);\n            }\n            else {\n                this.writeBit(value === -1n);\n                return;\n            }\n        }\n        // Check input\n        let vBits = 1n << (BigInt(bits) - 1n);\n        if (v < -vBits || v >= vBits) {\n            throw Error(`value is out of range for ${bits} bits. Got ${value}`);\n        }\n        // Write sign\n        if (v < 0) {\n            this.writeBit(true);\n            v = vBits + v;\n        }\n        else {\n            this.writeBit(false);\n        }\n        // Write value\n        this.writeUint(v, bits - 1);\n    }\n    /**\n     * Wrtie var uint value, used for serializing coins\n     * @param value value to write as bigint or number\n     * @param bits header bits to write size\n     */\n    writeVarUint(value, bits) {\n        let v = BigInt(value);\n        if (bits < 0 || !Number.isSafeInteger(bits)) {\n            throw Error(`invalid bit length. Got ${bits}`);\n        }\n        if (v < 0) {\n            throw Error(`value is negative. Got ${value}`);\n        }\n        // Corner case for zero\n        if (v === 0n) {\n            // Write zero size\n            this.writeUint(0, bits);\n            return;\n        }\n        // Calculate size\n        const sizeBytes = Math.ceil((v.toString(2).length) / 8); // Fastest way in most environments\n        const sizeBits = sizeBytes * 8;\n        // Write size\n        this.writeUint(sizeBytes, bits);\n        // Write number\n        this.writeUint(v, sizeBits);\n    }\n    /**\n     * Wrtie var int value, used for serializing coins\n     * @param value value to write as bigint or number\n     * @param bits header bits to write size\n     */\n    writeVarInt(value, bits) {\n        let v = BigInt(value);\n        if (bits < 0 || !Number.isSafeInteger(bits)) {\n            throw Error(`invalid bit length. Got ${bits}`);\n        }\n        // Corner case for zero\n        if (v === 0n) {\n            // Write zero size\n            this.writeUint(0, bits);\n            return;\n        }\n        // Calculate size\n        let v2 = v > 0 ? v : -v;\n        const sizeBytes = 1 + Math.ceil((v2.toString(2).length) / 8); // Fastest way in most environments\n        const sizeBits = sizeBytes * 8;\n        // Write size\n        this.writeUint(sizeBytes, bits);\n        // Write number\n        this.writeInt(v, sizeBits);\n    }\n    /**\n     * Write coins in var uint format\n     * @param amount amount to write\n     */\n    writeCoins(amount) {\n        this.writeVarUint(amount, 4);\n    }\n    /**\n     * Write address\n     * @param address write address or address external\n     */\n    writeAddress(address) {\n        // Is empty address\n        if (address === null || address === undefined) {\n            this.writeUint(0, 2); // Empty address\n            return;\n        }\n        // Is Internal Address\n        if (Address_1.Address.isAddress(address)) {\n            this.writeUint(2, 2); // Internal address\n            this.writeUint(0, 1); // No anycast\n            this.writeInt(address.workChain, 8);\n            this.writeBuffer(address.hash);\n            return;\n        }\n        // Is External Address\n        if (ExternalAddress_1.ExternalAddress.isAddress(address)) {\n            this.writeUint(1, 2); // External address\n            this.writeUint(address.bits, 9);\n            this.writeUint(address.value, address.bits);\n            return;\n        }\n        // Invalid address\n        throw Error(`Invalid address. Got ${address}`);\n    }\n    /**\n     * Build BitString\n     * @returns result bit string\n     */\n    build() {\n        return new BitString_1.BitString(this._buffer, 0, this._length);\n    }\n    /**\n     * Build into Buffer\n     * @returns result buffer\n     */\n    buffer() {\n        if (this._length % 8 !== 0) {\n            throw new Error(\"BitBuilder buffer is not byte aligned\");\n        }\n        return this._buffer.subarray(0, this._length / 8);\n    }\n}\nexports.BitBuilder = BitBuilder;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,UAAU,GAAG,KAAK,CAAC;AAC3B,MAAMC,SAAS,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC/C,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,4BAA4B,CAAC;AAC/D,MAAME,WAAW,GAAGF,OAAO,CAAC,aAAa,CAAC;AAC1C;AACA;AACA;AACA,MAAMF,UAAU,CAAC;EACbK,WAAWA,CAAA,EAAc;IAAA,IAAbC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IACnB,IAAI,CAACG,OAAO,GAAGC,MAAM,CAACC,KAAK,CAACC,IAAI,CAACC,IAAI,CAACR,IAAI,GAAG,CAAC,CAAC,CAAC;IAChD,IAAI,CAACS,OAAO,GAAG,CAAC;EACpB;EACA;AACJ;AACA;EACI,IAAIP,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAACO,OAAO;EACvB;EACA;AACJ;AACA;AACA;EACIC,QAAQA,CAACjB,KAAK,EAAE;IACZ;IACA,IAAIkB,CAAC,GAAG,IAAI,CAACF,OAAO;IACpB,IAAIE,CAAC,GAAG,IAAI,CAACP,OAAO,CAACF,MAAM,GAAG,CAAC,EAAE;MAC7B,MAAM,IAAIU,KAAK,CAAC,qBAAqB,CAAC;IAC1C;IACA;IACA,IAAK,OAAOnB,KAAK,KAAK,SAAS,IAAIA,KAAK,KAAK,IAAI,IAAM,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,GAAG,CAAE,EAAE;MAC5F,IAAI,CAACW,OAAO,CAAEO,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC,IAAI,CAAC,IAAK,CAAC,GAAIA,CAAC,GAAG,CAAG;IACnD;IACA;IACA,IAAI,CAACF,OAAO,EAAE;EAClB;EACA;AACJ;AACA;AACA;EACII,SAASA,CAACC,GAAG,EAAE;IACX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,CAACZ,MAAM,EAAEa,CAAC,EAAE,EAAE;MACjC,IAAI,CAACL,QAAQ,CAACI,GAAG,CAACE,EAAE,CAACD,CAAC,CAAC,CAAC;IAC5B;EACJ;EACA;AACJ;AACA;AACA;EACIE,WAAWA,CAACH,GAAG,EAAE;IACb;IACA,IAAI,IAAI,CAACL,OAAO,GAAG,CAAC,KAAK,CAAC,EAAE;MACxB,IAAI,IAAI,CAACA,OAAO,GAAGK,GAAG,CAACZ,MAAM,GAAG,CAAC,GAAG,IAAI,CAACE,OAAO,CAACF,MAAM,GAAG,CAAC,EAAE;QACzD,MAAM,IAAIU,KAAK,CAAC,qBAAqB,CAAC;MAC1C;MACAE,GAAG,CAACI,IAAI,CAAC,IAAI,CAACd,OAAO,EAAE,IAAI,CAACK,OAAO,GAAG,CAAC,CAAC;MACxC,IAAI,CAACA,OAAO,IAAIK,GAAG,CAACZ,MAAM,GAAG,CAAC;IAClC,CAAC,MACI;MACD,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,CAACZ,MAAM,EAAEa,CAAC,EAAE,EAAE;QACjC,IAAI,CAACI,SAAS,CAACL,GAAG,CAACC,CAAC,CAAC,EAAE,CAAC,CAAC;MAC7B;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;EACII,SAASA,CAAC1B,KAAK,EAAE2B,IAAI,EAAE;IACnB,IAAIA,IAAI,GAAG,CAAC,IAAI,CAACC,MAAM,CAACC,aAAa,CAACF,IAAI,CAAC,EAAE;MACzC,MAAMR,KAAK,4BAAAW,MAAA,CAA4BH,IAAI,CAAE,CAAC;IAClD;IACA,MAAMI,CAAC,GAAGC,MAAM,CAAChC,KAAK,CAAC;IACvB,IAAI2B,IAAI,KAAK,CAAC,EAAE;MACZ,IAAII,CAAC,KAAK,EAAE,EAAE;QACV,MAAMZ,KAAK,0BAAAW,MAAA,CAA0BH,IAAI,iBAAAG,MAAA,CAAc9B,KAAK,CAAE,CAAC;MACnE,CAAC,MACI;QACD;MACJ;IACJ;IACA,MAAMiC,KAAK,GAAI,EAAE,IAAID,MAAM,CAACL,IAAI,CAAE;IAClC,IAAII,CAAC,GAAG,CAAC,IAAIA,CAAC,IAAIE,KAAK,EAAE;MACrB,MAAMd,KAAK,uCAAAW,MAAA,CAAuC9B,KAAK,YAAA8B,MAAA,CAASH,IAAI,CAAE,CAAC;IAC3E;IACA,IAAI,IAAI,CAACX,OAAO,GAAGW,IAAI,GAAG,IAAI,CAAChB,OAAO,CAACF,MAAM,GAAG,CAAC,EAAE;MAC/C,MAAM,IAAIU,KAAK,CAAC,qBAAqB,CAAC;IAC1C;IACA,MAAMe,QAAQ,GAAG,CAAC,GAAI,IAAI,CAAClB,OAAO,GAAG,CAAE;IACvC,IAAIkB,QAAQ,GAAG,CAAC,EAAE;MACd,MAAMC,IAAI,GAAGrB,IAAI,CAACsB,KAAK,CAAC,IAAI,CAACpB,OAAO,GAAG,CAAC,CAAC;MACzC,IAAIW,IAAI,GAAGO,QAAQ,EAAE;QACjB,MAAMG,EAAE,GAAGT,MAAM,CAACG,CAAC,CAAC;QACpB,IAAI,CAACpB,OAAO,CAACwB,IAAI,CAAC,IAAIE,EAAE,IAAKH,QAAQ,GAAGP,IAAK;QAC7C,IAAI,CAACX,OAAO,IAAIW,IAAI;MACxB,CAAC,MACI;QACD,MAAMU,EAAE,GAAGT,MAAM,CAACG,CAAC,IAAIC,MAAM,CAACL,IAAI,GAAGO,QAAQ,CAAC,CAAC;QAC/C,IAAI,CAACvB,OAAO,CAACwB,IAAI,CAAC,IAAIE,EAAE;QACxB,IAAI,CAACrB,OAAO,IAAIkB,QAAQ;MAC5B;IACJ;IACAP,IAAI,IAAIO,QAAQ;IAChB,OAAOP,IAAI,GAAG,CAAC,EAAE;MACb,IAAIA,IAAI,IAAI,CAAC,EAAE;QACX,IAAI,CAAChB,OAAO,CAAC,IAAI,CAACK,OAAO,GAAG,CAAC,CAAC,GAAGY,MAAM,CAAEG,CAAC,IAAIC,MAAM,CAACL,IAAI,GAAG,CAAC,CAAC,GAAI,KAAK,CAAC;QACxE,IAAI,CAACX,OAAO,IAAI,CAAC;QACjBW,IAAI,IAAI,CAAC;MACb,CAAC,MACI;QACD,IAAI,CAAChB,OAAO,CAAC,IAAI,CAACK,OAAO,GAAG,CAAC,CAAC,GAAGY,MAAM,CAAEG,CAAC,IAAIC,MAAM,CAAC,CAAC,GAAGL,IAAI,CAAC,GAAI,KAAK,CAAC;QACxE,IAAI,CAACX,OAAO,IAAIW,IAAI;QACpBA,IAAI,GAAG,CAAC;MACZ;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;EACIW,QAAQA,CAACtC,KAAK,EAAE2B,IAAI,EAAE;IAClB,IAAII,CAAC,GAAGC,MAAM,CAAChC,KAAK,CAAC;IACrB,IAAI2B,IAAI,GAAG,CAAC,IAAI,CAACC,MAAM,CAACC,aAAa,CAACF,IAAI,CAAC,EAAE;MACzC,MAAMR,KAAK,4BAAAW,MAAA,CAA4BH,IAAI,CAAE,CAAC;IAClD;IACA;IACA,IAAIA,IAAI,KAAK,CAAC,EAAE;MACZ,IAAI3B,KAAK,KAAK,EAAE,EAAE;QACd,MAAMmB,KAAK,0BAAAW,MAAA,CAA0BH,IAAI,iBAAAG,MAAA,CAAc9B,KAAK,CAAE,CAAC;MACnE,CAAC,MACI;QACD;MACJ;IACJ;IACA;IACA,IAAI2B,IAAI,KAAK,CAAC,EAAE;MACZ,IAAI3B,KAAK,KAAK,CAAC,EAAE,IAAIA,KAAK,KAAK,EAAE,EAAE;QAC/B,MAAMmB,KAAK,gCAAAW,MAAA,CAAgCH,IAAI,iBAAAG,MAAA,CAAc9B,KAAK,CAAE,CAAC;MACzE,CAAC,MACI;QACD,IAAI,CAACiB,QAAQ,CAACjB,KAAK,KAAK,CAAC,EAAE,CAAC;QAC5B;MACJ;IACJ;IACA;IACA,IAAIiC,KAAK,GAAG,EAAE,IAAKD,MAAM,CAACL,IAAI,CAAC,GAAG,EAAG;IACrC,IAAII,CAAC,GAAG,CAACE,KAAK,IAAIF,CAAC,IAAIE,KAAK,EAAE;MAC1B,MAAMd,KAAK,8BAAAW,MAAA,CAA8BH,IAAI,iBAAAG,MAAA,CAAc9B,KAAK,CAAE,CAAC;IACvE;IACA;IACA,IAAI+B,CAAC,GAAG,CAAC,EAAE;MACP,IAAI,CAACd,QAAQ,CAAC,IAAI,CAAC;MACnBc,CAAC,GAAGE,KAAK,GAAGF,CAAC;IACjB,CAAC,MACI;MACD,IAAI,CAACd,QAAQ,CAAC,KAAK,CAAC;IACxB;IACA;IACA,IAAI,CAACS,SAAS,CAACK,CAAC,EAAEJ,IAAI,GAAG,CAAC,CAAC;EAC/B;EACA;AACJ;AACA;AACA;AACA;EACIY,YAAYA,CAACvC,KAAK,EAAE2B,IAAI,EAAE;IACtB,IAAII,CAAC,GAAGC,MAAM,CAAChC,KAAK,CAAC;IACrB,IAAI2B,IAAI,GAAG,CAAC,IAAI,CAACC,MAAM,CAACC,aAAa,CAACF,IAAI,CAAC,EAAE;MACzC,MAAMR,KAAK,4BAAAW,MAAA,CAA4BH,IAAI,CAAE,CAAC;IAClD;IACA,IAAII,CAAC,GAAG,CAAC,EAAE;MACP,MAAMZ,KAAK,2BAAAW,MAAA,CAA2B9B,KAAK,CAAE,CAAC;IAClD;IACA;IACA,IAAI+B,CAAC,KAAK,EAAE,EAAE;MACV;MACA,IAAI,CAACL,SAAS,CAAC,CAAC,EAAEC,IAAI,CAAC;MACvB;IACJ;IACA;IACA,MAAMa,SAAS,GAAG1B,IAAI,CAACC,IAAI,CAAEgB,CAAC,CAACU,QAAQ,CAAC,CAAC,CAAC,CAAChC,MAAM,GAAI,CAAC,CAAC,CAAC,CAAC;IACzD,MAAMiC,QAAQ,GAAGF,SAAS,GAAG,CAAC;IAC9B;IACA,IAAI,CAACd,SAAS,CAACc,SAAS,EAAEb,IAAI,CAAC;IAC/B;IACA,IAAI,CAACD,SAAS,CAACK,CAAC,EAAEW,QAAQ,CAAC;EAC/B;EACA;AACJ;AACA;AACA;AACA;EACIC,WAAWA,CAAC3C,KAAK,EAAE2B,IAAI,EAAE;IACrB,IAAII,CAAC,GAAGC,MAAM,CAAChC,KAAK,CAAC;IACrB,IAAI2B,IAAI,GAAG,CAAC,IAAI,CAACC,MAAM,CAACC,aAAa,CAACF,IAAI,CAAC,EAAE;MACzC,MAAMR,KAAK,4BAAAW,MAAA,CAA4BH,IAAI,CAAE,CAAC;IAClD;IACA;IACA,IAAII,CAAC,KAAK,EAAE,EAAE;MACV;MACA,IAAI,CAACL,SAAS,CAAC,CAAC,EAAEC,IAAI,CAAC;MACvB;IACJ;IACA;IACA,IAAIiB,EAAE,GAAGb,CAAC,GAAG,CAAC,GAAGA,CAAC,GAAG,CAACA,CAAC;IACvB,MAAMS,SAAS,GAAG,CAAC,GAAG1B,IAAI,CAACC,IAAI,CAAE6B,EAAE,CAACH,QAAQ,CAAC,CAAC,CAAC,CAAChC,MAAM,GAAI,CAAC,CAAC,CAAC,CAAC;IAC9D,MAAMiC,QAAQ,GAAGF,SAAS,GAAG,CAAC;IAC9B;IACA,IAAI,CAACd,SAAS,CAACc,SAAS,EAAEb,IAAI,CAAC;IAC/B;IACA,IAAI,CAACW,QAAQ,CAACP,CAAC,EAAEW,QAAQ,CAAC;EAC9B;EACA;AACJ;AACA;AACA;EACIG,UAAUA,CAACC,MAAM,EAAE;IACf,IAAI,CAACP,YAAY,CAACO,MAAM,EAAE,CAAC,CAAC;EAChC;EACA;AACJ;AACA;AACA;EACIC,YAAYA,CAACC,OAAO,EAAE;IAClB;IACA,IAAIA,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAKtC,SAAS,EAAE;MAC3C,IAAI,CAACgB,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MACtB;IACJ;IACA;IACA,IAAIxB,SAAS,CAAC+C,OAAO,CAACC,SAAS,CAACF,OAAO,CAAC,EAAE;MACtC,IAAI,CAACtB,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MACtB,IAAI,CAACA,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MACtB,IAAI,CAACY,QAAQ,CAACU,OAAO,CAACG,SAAS,EAAE,CAAC,CAAC;MACnC,IAAI,CAAC3B,WAAW,CAACwB,OAAO,CAACI,IAAI,CAAC;MAC9B;IACJ;IACA;IACA,IAAIhD,iBAAiB,CAACiD,eAAe,CAACH,SAAS,CAACF,OAAO,CAAC,EAAE;MACtD,IAAI,CAACtB,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MACtB,IAAI,CAACA,SAAS,CAACsB,OAAO,CAACrB,IAAI,EAAE,CAAC,CAAC;MAC/B,IAAI,CAACD,SAAS,CAACsB,OAAO,CAAChD,KAAK,EAAEgD,OAAO,CAACrB,IAAI,CAAC;MAC3C;IACJ;IACA;IACA,MAAMR,KAAK,yBAAAW,MAAA,CAAyBkB,OAAO,CAAE,CAAC;EAClD;EACA;AACJ;AACA;AACA;EACIM,KAAKA,CAAA,EAAG;IACJ,OAAO,IAAIjD,WAAW,CAACkD,SAAS,CAAC,IAAI,CAAC5C,OAAO,EAAE,CAAC,EAAE,IAAI,CAACK,OAAO,CAAC;EACnE;EACA;AACJ;AACA;AACA;EACIwC,MAAMA,CAAA,EAAG;IACL,IAAI,IAAI,CAACxC,OAAO,GAAG,CAAC,KAAK,CAAC,EAAE;MACxB,MAAM,IAAIG,KAAK,CAAC,uCAAuC,CAAC;IAC5D;IACA,OAAO,IAAI,CAACR,OAAO,CAAC8C,QAAQ,CAAC,CAAC,EAAE,IAAI,CAACzC,OAAO,GAAG,CAAC,CAAC;EACrD;AACJ;AACAjB,OAAO,CAACE,UAAU,GAAGA,UAAU","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}