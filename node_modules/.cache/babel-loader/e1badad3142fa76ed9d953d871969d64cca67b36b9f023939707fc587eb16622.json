{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\adams\\\\OneDrive\\\\Desktop\\\\Work\\\\slotpot\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nimport { TonConnectUIProvider } from '@tonconnect/ui-react';\nimport Chat from './components/Chat';\nimport GameArea from './components/GameArea';\nimport MobileChat from './components/MobileChat';\nimport WalletConnection from './components/WalletConnection';\nimport WinnerBroadcast from './components/WinnerBroadcast';\nimport SimpleCarousel from './components/SimpleCarousel';\nimport useTelegramWebApp from './hooks/useTelegramWebApp';\nimport useJackpotContract from './hooks/useJackpotContract';\nimport socketService from './services/socketService';\nimport winnerCoordinator from './services/winnerCoordinator';\nimport { uiOptions } from './config/tonconnect';\nimport { MessageCircle, Trophy, Users, DollarSign } from 'lucide-react';\nimport './App.css';\nimport './components/Header.css';\n\n// TON Connect manifest URL - use remote manifest to avoid 500 errors\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst manifestUrl = \"https://raw.githubusercontent.com/Vodka2134156/kzsks/main/manifest.json\";\nfunction AppContent() {\n  _s();\n  var _contractState$timer2;\n  // Local UI state\n  const [currentRound, setCurrentRound] = useState(53408);\n  const [timeRemaining, setTimeRemaining] = useState(30);\n  const [activeTab, setActiveTab] = useState('jackpot');\n  const [betAmount, setBetAmount] = useState(0.11);\n  const [showWinnerAnnouncement, setShowWinnerAnnouncement] = useState(false);\n\n  // Winner state management (moved from GameArea.js)\n  const [waitingForWinner, setWaitingForWinner] = useState(false);\n  const [contractWinner, setContractWinner] = useState(null);\n  const [postWinnerLoading, setPostWinnerLoading] = useState(false);\n  const [, setIsAnyWinnerDisplayActive] = useState(false);\n  const [showWinnerVisually, setShowWinnerVisually] = useState(false); // Controls when winner card appears\n  const [isInWinnerState, setIsInWinnerState] = useState(false); // Blocks new winner broadcasts\n\n  // Bettors state (managed centrally to avoid duplicates)\n  const [gameBettors, setGameBettors] = useState([]);\n  const [previousRoundBettors, setPreviousRoundBettors] = useState([]); // Store bettors for winner matching\n  const [slotSpinning, setSlotSpinning] = useState(false);\n  // Note: carouselRef removed - now using Swiper component\n\n  // Refs to avoid stale closures in socket handlers\n  const gameBettorsRef = useRef([]);\n  const contractWinnerRef = useRef(null);\n  const showWinnerAnnouncementRef = useRef(false);\n  const lastWinnerTimestampRef = useRef(null);\n  const waitingForWinnerRef = useRef(false);\n  const previousRoundBettorsRef = useRef([]);\n  const timeRemainingRef = useRef(30);\n  const showWinnerVisuallyRef = useRef(false);\n  const isInWinnerStateRef = useRef(false);\n\n  // Keep refs in sync with state\n  useEffect(() => {\n    gameBettorsRef.current = gameBettors;\n  }, [gameBettors]);\n  useEffect(() => {\n    contractWinnerRef.current = contractWinner;\n\n    // Log winner detection only once when contractWinner changes\n    if (contractWinner) {\n      console.log('🏆 WINNER DETECTED FROM BACKEND!', {\n        winnerAddress: contractWinner.winner || contractWinner.fullAddress,\n        winnerName: contractWinner.username || contractWinner.displayName || 'Player',\n        prize: contractWinner.prize,\n        contractWinner\n      });\n      console.log('🎬 ANIMATION SHOULD START NOW - waiting for carousel to detect winner');\n    } else {\n      console.log('❌ WINNER CLEARED - contractWinner set to null');\n    }\n  }, [contractWinner]);\n  useEffect(() => {\n    showWinnerAnnouncementRef.current = showWinnerAnnouncement;\n  }, [showWinnerAnnouncement]);\n  useEffect(() => {\n    waitingForWinnerRef.current = waitingForWinner;\n  }, [waitingForWinner]);\n  useEffect(() => {\n    previousRoundBettorsRef.current = previousRoundBettors;\n  }, [previousRoundBettors]);\n  useEffect(() => {\n    timeRemainingRef.current = timeRemaining;\n  }, [timeRemaining]);\n  useEffect(() => {\n    showWinnerVisuallyRef.current = showWinnerVisually;\n  }, [showWinnerVisually]);\n  useEffect(() => {\n    isInWinnerStateRef.current = isInWinnerState;\n  }, [isInWinnerState]);\n\n  // Centralized winner announcement manager\n  const showWinnerAnnouncements = useCallback((winnerData, source = 'unknown') => {\n    const winnerTimestamp = winnerData.timestamp;\n\n    // Block winner broadcasts if already in winner state\n    if (isInWinnerStateRef.current) {\n      console.log(`🚫 BLOCKED - Already in winner state, ignoring winner broadcast from ${source}`);\n      return false;\n    }\n\n    // Use coordinator to check if should block (pass full winner data for better duplicate detection)\n    if (winnerCoordinator.shouldBlock(winnerTimestamp, winnerData)) {\n      console.log(`🔄 Winner announcement blocked by coordinator (${source})`);\n      return false;\n    }\n    console.log(`🎉 Showing winner announcements from ${source}:`, winnerData);\n    console.log(`🎯 Entering winner state - blocking future winner broadcasts`);\n\n    // Enter winner state to block future broadcasts\n    setIsInWinnerState(true);\n\n    // Set coordination flag via coordinator (pass full winner data)\n    winnerCoordinator.setActive(true, winnerTimestamp, winnerData);\n    setIsAnyWinnerDisplayActive(true);\n    lastWinnerTimestampRef.current = winnerTimestamp;\n\n    // Show App.js winner notification\n    setContractWinner(winnerData);\n    setShowWinnerAnnouncement(true);\n    setWaitingForWinner(false);\n\n    // Start animation - winner visual will appear after animation lands on winner\n    setTimeout(() => {\n      console.log('🎬 Animation should have landed on winner - showing winner visually');\n      setShowWinnerVisually(true);\n    }, 3000); // Give animation time to land properly\n\n    // Winner will stay visible until new round starts (no automatic timeout)\n    console.log('🏆 Winner display will persist until new round is declared by backend');\n    return true;\n  }, []);\n\n  // Telegram integration\n  const {\n    user,\n    hapticFeedback,\n    showAlert,\n    hasRealUserData\n  } = useTelegramWebApp();\n\n  // Smart contract integration\n  const {\n    contractState,\n    userStats,\n    adminInfo: rawAdminInfo,\n    isLoadingContract,\n    isPlacingBet,\n    placeBet,\n    isConnected,\n    address\n  } = useJackpotContract();\n\n  // SAFETY: Ensure adminInfo is always properly structured and never an object that could be rendered\n  const adminInfo = useMemo(() => {\n    var _rawAdminInfo$current;\n    if (!rawAdminInfo || typeof rawAdminInfo !== 'object') {\n      return {\n        isAutoManaged: false,\n        roundDuration: 300,\n        minBetsToEnd: 1,\n        timerActive: false,\n        timeRemaining: 0\n      };\n    }\n\n    // Extract only primitive values to prevent accidental object rendering\n    return {\n      isAutoManaged: Boolean(rawAdminInfo.isAutoManaged),\n      roundDuration: Number(rawAdminInfo.roundDuration) || 300,\n      minBetsToEnd: Number(rawAdminInfo.minBetsToEnd) || 1,\n      timerActive: Boolean(rawAdminInfo.timerActive),\n      timeRemaining: Number(rawAdminInfo.timeRemaining) || 0,\n      // Ensure currentRound is always a number, never an object\n      currentRound: typeof rawAdminInfo.currentRound === 'object' ? ((_rawAdminInfo$current = rawAdminInfo.currentRound) === null || _rawAdminInfo$current === void 0 ? void 0 : _rawAdminInfo$current.roundNumber) || 0 : Number(rawAdminInfo.currentRound) || 0\n    };\n  }, [rawAdminInfo]);\n\n  // SAFETY: Ensure contractState timer properties are never objects that could be accidentally rendered\n  const safeContractState = useMemo(() => {\n    var _contractState$curren;\n    if (!contractState) return contractState;\n    return {\n      ...contractState,\n      // Ensure timer object properties are always primitives\n      timer: contractState.timer ? {\n        isActive: Boolean(contractState.timer.isActive),\n        timeRemaining: Number(contractState.timer.timeRemaining) || 0,\n        timeElapsed: Number(contractState.timer.timeElapsed) || 0,\n        roundNumber: Number(contractState.timer.roundNumber) || 0,\n        timerExpired: Boolean(contractState.timer.timerExpired)\n      } : undefined,\n      // Ensure currentRound is always a number if it exists\n      currentRound: typeof contractState.currentRound === 'object' ? ((_contractState$curren = contractState.currentRound) === null || _contractState$curren === void 0 ? void 0 : _contractState$curren.roundNumber) || 0 : contractState.currentRound\n    };\n  }, [contractState]);\n\n  // Use real contract data or fallback to simulated data\n  const jackpotValue = contractState.totalJackpot;\n  const isLive = contractState.isActive;\n\n  // Calculate user stats from gameBettors data\n  const userBetTotal = useMemo(() => {\n    if (!isConnected || !address || !gameBettors.length) return 0;\n    return gameBettors.filter(bettor => bettor.address === address || bettor.walletAddress === address).reduce((total, bettor) => total + (bettor.amount || 0), 0);\n  }, [gameBettors, address, isConnected]);\n  const userWinChance = useMemo(() => {\n    if (!isConnected || !address || userBetTotal === 0) return 0;\n\n    // Calculate current round total from gameBettors for immediate updates\n    const currentRoundTotal = gameBettors.reduce((total, bettor) => total + (bettor.amount || 0), 0);\n\n    // Use the live total from current bettors, fallback to contract jackpot value\n    const liveJackpotValue = currentRoundTotal > 0 ? currentRoundTotal : jackpotValue;\n    if (!liveJackpotValue) return 0;\n    return userBetTotal / liveJackpotValue * 100;\n  }, [userBetTotal, jackpotValue, gameBettors, isConnected, address]);\n\n  // Use automation timer or fallback to UI timer\n  useEffect(() => {\n    var _contractState$timer;\n    // Always sync with backend timer when it changes\n    if (((_contractState$timer = contractState.timer) === null || _contractState$timer === void 0 ? void 0 : _contractState$timer.timeRemaining) !== undefined) {\n      setTimeRemaining(contractState.timer.timeRemaining);\n    } else {\n      setTimeRemaining(30);\n    }\n  }, [(_contractState$timer2 = contractState.timer) === null || _contractState$timer2 === void 0 ? void 0 : _contractState$timer2.timeRemaining]);\n\n  // Local countdown timer (runs between backend updates)\n  useEffect(() => {\n    // Only run countdown when game is live\n    if (!isLive) return;\n    console.log('⏰ Starting local countdown timer...');\n    const countdown = setInterval(() => {\n      setTimeRemaining(prev => {\n        // Continue countdown even at 0 but don't go negative\n        if (prev > 0) {\n          const newTime = prev - 1;\n          console.log('⏰ Local countdown:', newTime);\n\n          // When we reach 0, trigger \"analyzing bets\" state locally\n          if (newTime === 0) {\n            console.log('⏰ Local timer reached 0, entering analyzing state...');\n            setWaitingForWinner(true); // This will show \"Analyzing Bets...\"\n          }\n          return newTime;\n        }\n\n        // Stay at 0 once we reach it (don't go negative)\n        return 0;\n      });\n    }, 1000);\n    return () => {\n      console.log('⏰ Stopping local countdown timer...');\n      clearInterval(countdown);\n    };\n  }, [isLive]); // Restart when isLive changes\n\n  // Smooth infinite carousel effect\n  useEffect(() => {\n    var _window$Telegram4;\n    const carousel = carouselRef.current;\n    if (!carousel) {\n      console.log('⚠️ CAROUSEL REF NOT READY - animation cannot start');\n      return;\n    }\n    console.log('🎠 CAROUSEL ANIMATION STARTING with ref:', carousel);\n\n    // Disable CSS transitions for smooth JS animation\n    carousel.style.transition = 'none';\n    let animationId;\n    let currentPosition = 0;\n    let winnerPositionFound = false;\n    let winnerCardVisible = false;\n    let targetPosition = null; // For dramatic slow-down effect\n    let animationPhase = 'normal'; // 'normal', 'fast-spin', 'slow-reveal'\n    // FIXED: Dynamic card width calculation to match carousel rendering\n    // This must match the card width used in the actual carousel\n    const getDynamicCardWidth = () => {\n      var _window$Telegram;\n      const isInTelegram = (_window$Telegram = window.Telegram) === null || _window$Telegram === void 0 ? void 0 : _window$Telegram.WebApp;\n      const screenWidth = isInTelegram ? window.Telegram.WebApp.viewportWidth || window.innerWidth : window.innerWidth;\n\n      // Match the logic from GameArea.js carousel rendering\n      const baseCardWidth = screenWidth <= 480 ? 120 : 150;\n      const gap = screenWidth <= 480 ? 15 : 20;\n      const cardPlusGap = baseCardWidth + gap;\n\n      // Only log on first calculation or significant changes\n      if (process.env.NODE_ENV === 'development') {\n        console.log('📐 Card width:', cardPlusGap, 'px', isInTelegram ? '(Telegram)' : '(Web)');\n      }\n      return cardPlusGap;\n    };\n    const cardWidth = getDynamicCardWidth();\n\n    // OPTIMIZED: Cache DOM elements to avoid repeated queries\n    let cachedTargetArrow = null;\n\n    // Use refs to get current values without causing re-renders\n    const getCurrentBettors = () => gameBettorsRef.current;\n    const getPreviousBettors = () => previousRoundBettorsRef.current;\n    const getContractWinner = () => contractWinnerRef.current;\n    const getWaitingForWinner = () => waitingForWinnerRef.current;\n    const getTimeRemaining = () => timeRemainingRef.current;\n    const getShowWinnerVisually = () => showWinnerVisuallyRef.current;\n    const getBettorsForAnimation = () => {\n      const currentBettors = getCurrentBettors();\n      const prevBettors = getPreviousBettors();\n      const currentWinnerData = getContractWinner();\n      const isWaitingData = getWaitingForWinner();\n\n      // FIXED: Use the EXACT SAME logic as the carousel rendering\n      const bettorsToShow = currentWinnerData || isWaitingData ? prevBettors.length > 0 ? prevBettors : currentBettors : currentBettors.length > 0 ? currentBettors : [];\n      console.log('🎠 getBettorsForAnimation - FIXED DATA FLOW:');\n      console.log('  - Context: contractWinner:', !!currentWinnerData, 'waitingForWinner:', isWaitingData);\n      console.log('  - Available: currentBettors:', currentBettors.length, 'prevBettors:', prevBettors.length);\n      console.log('  - Using bettorsToShow:', bettorsToShow.length, 'bettors');\n\n      // Ensure we have at least 6 items to show (fill with waiting slots if needed) - SAME AS CAROUSEL\n      const allItems = [...bettorsToShow, ...Array.from({\n        length: Math.max(0, 6 - bettorsToShow.length)\n      }, () => null)];\n      console.log('🎠 getBettorsForAnimation - Created array with:', allItems.length, 'items total');\n      console.log('🎠 Real players:', allItems.filter(item => item !== null).length);\n      console.log('🎠 Waiting slots:', allItems.filter(item => item === null).length);\n      return allItems;\n    };\n\n    // FIX: Infinite scroll reset logic with dynamic recalculation\n    // The carousel renders 3 identical sets of cards for seamless infinite scroll\n    const singleSetLength = 6; // Fixed to match carousel rendering (6 items minimum)\n\n    // Function to recalculate scroll parameters (for viewport changes)\n    const calculateScrollParameters = () => {\n      const currentCardWidth = getDynamicCardWidth();\n      const singleSetWidth = currentCardWidth * singleSetLength;\n      const resetTriggerPoint = singleSetWidth * 2; // After 2 complete sets (12 cards)\n      const resetToPosition = singleSetWidth; // Reset back to start of second set\n\n      return {\n        cardWidth: currentCardWidth,\n        singleSetWidth,\n        resetTriggerPoint,\n        resetToPosition\n      };\n    };\n\n    // Initial calculation\n    let scrollParams = calculateScrollParameters();\n    if (process.env.NODE_ENV === 'development') {\n      console.log('🎠 Carousel animation started - Card width:', scrollParams.cardWidth, 'px');\n    }\n    const animate = () => {\n      // Get current values using refs\n      const currentWinner = getContractWinner();\n      const isWaiting = getWaitingForWinner();\n      const timeLeft = getTimeRemaining();\n\n      // PHASE 1: Normal scrolling or waiting phase\n      if (!currentWinner) {\n        if (isWaiting && timeLeft === 0) {\n          // Fast spin while waiting for winner announcement\n          if (animationPhase !== 'fast-spin') {\n            animationPhase = 'fast-spin';\n          }\n          currentPosition += 12; // Fast spin\n          if (currentPosition >= scrollParams.resetTriggerPoint) {\n            currentPosition = scrollParams.resetToPosition;\n          }\n          carousel.style.transform = `translateX(-${currentPosition}px)`;\n          animationId = requestAnimationFrame(animate);\n          return;\n        } else {\n          // Normal carousel movement when not waiting\n          if (animationPhase !== 'normal') {\n            animationPhase = 'normal';\n          }\n          currentPosition += 2;\n          if (currentPosition >= scrollParams.resetTriggerPoint) {\n            currentPosition = scrollParams.resetToPosition;\n          }\n          carousel.style.transform = `translateX(-${currentPosition}px)`;\n          animationId = requestAnimationFrame(animate);\n          return;\n        }\n      }\n\n      // Transition to slow-reveal when winner detected\n      if (currentWinner && animationPhase !== 'slow-reveal') {\n        if (process.env.NODE_ENV === 'development') {\n          console.log('🔄 Winner detected, calculating position...');\n        }\n      }\n\n      // PHASE 2: When winner is announced, calculate precise target position\n      if (currentWinner && animationPhase !== 'slow-reveal' && targetPosition === null) {\n        // CRITICAL: Recalculate scroll parameters for current viewport before positioning\n        scrollParams = calculateScrollParameters();\n        animationPhase = 'slow-reveal';\n\n        // Get current bettors for animation (must match carousel rendering exactly)\n        const currentBettors = getCurrentBettors();\n        const prevBettors = getPreviousBettors();\n        const showWinnerVisuallyNow = getShowWinnerVisually();\n\n        // ENHANCED DEBUG: Track data states\n        console.log('🎯 WINNER DETECTION - DATA STATES:');\n        console.log('  - currentBettors:', currentBettors.length, currentBettors);\n        console.log('  - prevBettors:', prevBettors.length, prevBettors);\n        console.log('  - showWinnerVisually:', showWinnerVisuallyNow);\n        console.log('  - contractWinner:', currentWinner);\n\n        // FIXED: When winner is announced, current bettors are often reset/cleared\n        // So we should prioritize previousRoundBettors which contains the actual winner data\n        const bettorsToShow = currentWinner || isWaiting ? prevBettors.length > 0 ? prevBettors : currentBettors : currentBettors.length > 0 ? currentBettors : [];\n        console.log('🎯 BETTOR DATA DEBUG:');\n        console.log('  - Decision logic: winner announced OR waiting =', currentWinner || isWaiting);\n        console.log('  - Using bettorsToShow:', bettorsToShow.length, bettorsToShow);\n\n        // Ensure we have at least 6 items (same as carousel rendering)\n        const allItems = [...bettorsToShow, ...Array.from({\n          length: Math.max(0, 6 - bettorsToShow.length)\n        }, () => null)];\n\n        // Create infinite items EXACTLY like the carousel does\n        const infiniteItems = [...allItems, ...allItems, ...allItems];\n        console.log('🎯 DEBUG CAROUSEL STRUCTURE:');\n        console.log('  - bettorsToShow:', bettorsToShow.length);\n        console.log('  - allItems:', allItems.length);\n        console.log('  - infiniteItems:', infiniteItems.length);\n        console.log('  - currentPosition:', currentPosition);\n        console.log('  - cardWidth:', scrollParams.cardWidth);\n\n        // Find winner in the INFINITE items array (this is what's actually rendered)\n        let winnerIndex = -1;\n        console.log('🎯 WINNER SEARCH RESULTS:');\n        console.log('  - Looking for winner:', {\n          winner: currentWinner.winner,\n          fullAddress: currentWinner.fullAddress,\n          address: currentWinner.address,\n          username: currentWinner.username,\n          displayName: currentWinner.displayName\n        });\n        console.log('  - Available infiniteItems:', infiniteItems.map((item, i) => ({\n          index: i,\n          address: item === null || item === void 0 ? void 0 : item.address,\n          username: item === null || item === void 0 ? void 0 : item.username,\n          displayName: item === null || item === void 0 ? void 0 : item.displayName,\n          amount: item === null || item === void 0 ? void 0 : item.amount\n        })));\n\n        // ENHANCED WINNER MATCHING - Try more combinations\n        for (let i = 0; i < infiniteItems.length; i++) {\n          const bettor = infiniteItems[i];\n          if (!bettor) continue;\n          console.log(`🔍 Checking item ${i}:`, {\n            bettor_address: bettor.address,\n            bettor_username: bettor.username,\n            bettor_displayName: bettor.displayName,\n            winner_winner: currentWinner.winner,\n            winner_fullAddress: currentWinner.fullAddress,\n            winner_address: currentWinner.address,\n            winner_username: currentWinner.username,\n            winner_displayName: currentWinner.displayName\n          });\n          const isMatch =\n          // Address matching\n          bettor.address && currentWinner.winner && bettor.address === currentWinner.winner || bettor.address && currentWinner.fullAddress && bettor.address === currentWinner.fullAddress || bettor.address && currentWinner.address && bettor.address === currentWinner.address ||\n          // Username matching\n          bettor.username && currentWinner.username && bettor.username === currentWinner.username || bettor.username && currentWinner.displayName && bettor.username === currentWinner.displayName || bettor.displayName && currentWinner.username && bettor.displayName === currentWinner.username || bettor.displayName && currentWinner.displayName && bettor.displayName === currentWinner.displayName;\n          if (isMatch) {\n            winnerIndex = i;\n            console.log('🎯 WINNER FOUND at infiniteItems index:', winnerIndex, 'bettor:', bettor);\n            console.log('🎯 Match reason:', {\n              addressMatch: bettor.address === currentWinner.winner || bettor.address === currentWinner.fullAddress,\n              usernameMatch: bettor.username === currentWinner.username || bettor.displayName === currentWinner.username\n            });\n            break;\n          }\n        }\n        console.log('  - Winner found at index:', winnerIndex);\n        if (winnerIndex === -1) {\n          console.log('⚠️ Winner not found in infiniteItems, using enhanced fallback positioning');\n\n          // ENHANCED FALLBACK: Create proper winner data and inject it\n          const winnerData = {\n            address: currentWinner.winner || currentWinner.fullAddress || currentWinner.address || 'unknown',\n            username: currentWinner.username || currentWinner.displayName || 'Winner',\n            displayName: currentWinner.displayName || currentWinner.username || 'Winner',\n            amount: currentWinner.prize || currentWinner.amount || 0,\n            isWinner: true,\n            injected: true // Flag to indicate this was injected\n          };\n\n          // Find the best position to inject the winner\n          const firstEmptyIndex = allItems.findIndex(item => item === null);\n          let injectionIndex = firstEmptyIndex !== -1 ? firstEmptyIndex : 0;\n\n          // If no empty slots, replace the first non-null item\n          if (firstEmptyIndex === -1 && allItems.length > 0) {\n            injectionIndex = 0;\n            console.log('🔄 No empty slots found, replacing first item at index 0');\n          }\n\n          // Update all three sets in infiniteItems with winner data\n          infiniteItems[injectionIndex] = {\n            ...winnerData\n          };\n          infiniteItems[injectionIndex + allItems.length] = {\n            ...winnerData\n          };\n          infiniteItems[injectionIndex + allItems.length * 2] = {\n            ...winnerData\n          };\n          winnerIndex = injectionIndex;\n          console.log('✅ Enhanced fallback - Injected winner data:');\n          console.log('  - Position:', winnerIndex);\n          console.log('  - Winner data:', winnerData);\n          console.log('  - Injection reason:', firstEmptyIndex !== -1 ? 'Empty slot available' : 'Replaced existing item');\n        }\n        if (winnerIndex !== -1) {\n          // DEBUGGING: Check current DOM state\n          const carousel = document.querySelector('.carousel-track');\n          const targetArrow = document.querySelector('.carousel-target-arrow');\n          const carouselContainer = document.querySelector('.players-carousel');\n          if (carousel && targetArrow && carouselContainer) {\n            const carouselRect = carousel.getBoundingClientRect();\n            const arrowRect = targetArrow.getBoundingClientRect();\n            const containerRect = carouselContainer.getBoundingClientRect();\n            console.log('🎯 DOM DEBUG:');\n            console.log('  - Carousel rect:', carouselRect);\n            console.log('  - Arrow rect:', arrowRect);\n            console.log('  - Container rect:', containerRect);\n            console.log('  - Current transform:', carousel.style.transform);\n          }\n\n          // Calculate arrow center position relative to the track\n          let arrowCenterOffset = 200; // Default fallback\n\n          if (targetArrow && carouselContainer) {\n            var _window$Telegram2;\n            const containerRect = carouselContainer.getBoundingClientRect();\n            const arrowRect = targetArrow.getBoundingClientRect();\n\n            // Arrow center relative to container\n            const arrowCenterInContainer = arrowRect.left - containerRect.left + arrowRect.width / 2;\n            // Track padding shifts everything right by 12px\n            arrowCenterOffset = arrowCenterInContainer - 12;\n\n            // LANDSCAPE MODE FIX: Adjust for different card sizes in landscape\n            const isLandscape = window.innerWidth > window.innerHeight;\n            const isInTelegram = (_window$Telegram2 = window.Telegram) === null || _window$Telegram2 === void 0 ? void 0 : _window$Telegram2.WebApp;\n            if (isLandscape) {\n              // Landscape mode requires significant positioning adjustment\n              // The card width calculation and actual rendering differ significantly in landscape\n              const landscapeOffset = containerRect.width * 0.15; // Adjust based on container width\n              arrowCenterOffset -= landscapeOffset;\n              console.log('🎯 LANDSCAPE ADJUSTMENT: Applied dynamic offset of', landscapeOffset, 'px for landscape mode');\n              console.log('   Container width:', containerRect.width, 'px');\n            }\n            if (isInTelegram) {\n              // Telegram has slightly different layout - fine-tune based on testing\n              const telegramAdjustment = isLandscape ? 40 : 40; // Consistent adjustment for both orientations\n              arrowCenterOffset -= telegramAdjustment;\n              console.log(`🎯 TELEGRAM ADJUSTMENT: Applied -${telegramAdjustment}px offset for Telegram WebApp in ${isLandscape ? 'landscape' : 'portrait'}`);\n            }\n            console.log('🎯 ENHANCED ARROW POSITIONING:');\n            console.log('  - Container rect:', containerRect);\n            console.log('  - Arrow rect:', arrowRect);\n            console.log('  - Arrow center in container:', arrowCenterInContainer);\n            console.log('  - Raw arrow center offset:', arrowCenterInContainer - 12);\n            console.log('  - Landscape mode:', isLandscape);\n            console.log('  - Final arrow center offset (with all adjustments):', arrowCenterOffset);\n            console.log('  - Environment:', isInTelegram ? 'Telegram WebApp' : 'Web Browser');\n          }\n\n          // FIXED: Calculate the correct target position in the infinite scroll\n          // We want the winner to appear under the arrow, regardless of where it was found\n\n          // Find which \"set\" of the infinite scroll we should target\n          // We want to go through at least one full cycle for drama, then land on winner\n          const singleSetLength = allItems.length;\n          const currentPositionInCards = currentPosition / scrollParams.cardWidth;\n\n          // Calculate which set we should target (aim for 2nd or 3rd set for drama)\n          let targetSetIndex = 1; // Default to second set\n          if (currentPositionInCards < singleSetLength) {\n            targetSetIndex = 1; // We're in first set, go to second\n          } else if (currentPositionInCards < singleSetLength * 2) {\n            targetSetIndex = 2; // We're in second set, go to third\n          } else {\n            targetSetIndex = 2; // We're in third set, stay in third or go to second\n          }\n\n          // The actual index in infiniteItems where we want the winner to appear\n          const targetWinnerIndex = targetSetIndex * singleSetLength + winnerIndex % singleSetLength;\n          console.log('🎯 TARGET CALCULATION:');\n          console.log('  - Single set length:', singleSetLength);\n          console.log('  - Current position in cards:', currentPositionInCards);\n          console.log('  - Target set index:', targetSetIndex);\n          console.log('  - Original winner index:', winnerIndex);\n          console.log('  - Target winner index in infinite array:', targetWinnerIndex);\n\n          // Calculate the position where the winner should appear\n          const winnerCardPosition = targetWinnerIndex * scrollParams.cardWidth;\n\n          // ENHANCED LANDSCAPE FIX: The arrow target should account for actual card center\n          const cardCenterOffset = scrollParams.cardWidth / 2;\n          const targetPositionForWinnerCenter = winnerCardPosition + cardCenterOffset - arrowCenterOffset;\n\n          // Add extra adjustment for landscape mode specifically\n          let finalTargetPosition = targetPositionForWinnerCenter;\n          if (window.innerWidth > window.innerHeight) {\n            // In landscape, we need additional adjustment because cards are smaller\n            const landscapeFineAdjustment = scrollParams.cardWidth * 0.3; // 30% of card width adjustment\n            finalTargetPosition += landscapeFineAdjustment;\n            console.log('🎯 LANDSCAPE FINE ADJUSTMENT: Added', landscapeFineAdjustment, 'px for card centering');\n          }\n          targetPosition = finalTargetPosition;\n          console.log('🎯 FINAL CALCULATION:');\n          console.log('  - Target winner index in infiniteItems:', targetWinnerIndex);\n          console.log('  - Card width:', scrollParams.cardWidth);\n          console.log('  - Target winner card left edge:', winnerCardPosition);\n          console.log('  - Target winner card center:', winnerCardPosition + cardCenterOffset);\n          console.log('  - Arrow center offset:', arrowCenterOffset);\n          console.log('  - Base target position:', targetPositionForWinnerCenter);\n          console.log('  - Final target position (with landscape adj):', finalTargetPosition);\n          console.log('  - Current position:', currentPosition);\n          console.log('  - Movement needed:', finalTargetPosition - currentPosition);\n\n          // Additional debugging for card alignment\n          console.log('🎯 ALIGNMENT DEBUG:');\n          console.log('  - When animation ends, card center should be at pixel:', winnerCardPosition + cardCenterOffset);\n          console.log('  - Arrow is expecting content at pixel:', arrowCenterOffset);\n          console.log('  - Difference (should be ~0 after positioning):', winnerCardPosition + cardCenterOffset - arrowCenterOffset);\n        }\n      }\n\n      // PHASE 3: Execute dramatic slowdown to winner position\n      if (currentWinner && animationPhase === 'slow-reveal' && targetPosition !== null && !winnerPositionFound) {\n        // Calculate distance to target\n        const distanceToTarget = Math.abs(targetPosition - currentPosition);\n        let speed;\n\n        // DEBUG: Log progress every 60 frames (about once per second)\n        if (Math.floor(currentPosition) % 60 === 0) {\n          console.log(` Animation progress: Current: ${currentPosition.toFixed(1)}, Target: ${targetPosition.toFixed(1)}, Distance: ${distanceToTarget.toFixed(1)}`);\n        }\n\n        // OPTIMIZED: Update arrow visual state with cached element\n        if (!cachedTargetArrow) {\n          cachedTargetArrow = document.querySelector('.carousel-target-arrow');\n        }\n        if (cachedTargetArrow) {\n          if (distanceToTarget < 200) {\n            cachedTargetArrow.classList.add('winner-approaching');\n          } else {\n            cachedTargetArrow.classList.remove('winner-approaching');\n          }\n        }\n\n        // ENHANCED SUSPENSE ALGORITHM: Go through one cycle then dramatic slowdown\n        if (distanceToTarget > 800) {\n          speed = 20; // Very fast for going through the cycle\n        } else if (distanceToTarget > 600) {\n          speed = 15; // Fast approach during cycle\n        } else if (distanceToTarget > 400) {\n          speed = 12; // Medium speed during cycle\n        } else if (distanceToTarget > 300) {\n          speed = 8; // Starting to slow down as we approach final position\n        } else if (distanceToTarget > 200) {\n          speed = 5; // Noticeable slowdown\n        } else if (distanceToTarget > 100) {\n          speed = 2.5; // Slowing down dramatically...\n        } else if (distanceToTarget > 50) {\n          speed = 1.2; // Very slow...\n        } else if (distanceToTarget > 25) {\n          speed = 0.6; // Crawling...\n        } else if (distanceToTarget > 10) {\n          speed = 0.2; // Almost stopping...\n        } else {\n          speed = 0.05; // Final crawl to target\n        }\n\n        // Move towards target with calculated speed\n        if (currentPosition < targetPosition) {\n          currentPosition += speed;\n          if (currentPosition >= targetPosition) {\n            currentPosition = targetPosition;\n            winnerPositionFound = true;\n          }\n        } else if (currentPosition > targetPosition) {\n          currentPosition -= speed;\n          if (currentPosition <= targetPosition) {\n            currentPosition = targetPosition;\n            winnerPositionFound = true;\n          }\n        } else {\n          winnerPositionFound = true;\n        }\n\n        // Check if we've reached the target\n        if (winnerPositionFound) {\n          // OPTIMIZED: Use cached element\n          if (cachedTargetArrow) {\n            cachedTargetArrow.classList.remove('winner-approaching');\n            cachedTargetArrow.classList.add('winner-landed');\n          }\n\n          // OPTIMIZED: Reduced logging\n          if (process.env.NODE_ENV === 'development') {\n            console.log('🎯 Animation complete! Winner landed at position:', currentPosition);\n          }\n\n          // NOW reveal the winner visually (CSS animation disabled to keep position)\n          setShowWinnerVisually(true);\n\n          // VERIFICATION: Check if winner actually landed under arrow\n          setTimeout(() => {\n            const targetArrow = document.querySelector('.carousel-target-arrow');\n            const winnerCard = document.querySelector('.carousel-card.winner');\n            if (targetArrow && winnerCard) {\n              const arrowRect = targetArrow.getBoundingClientRect();\n              const cardRect = winnerCard.getBoundingClientRect();\n              const arrowCenter = arrowRect.left + arrowRect.width / 2;\n              const cardCenter = cardRect.left + cardRect.width / 2;\n              const difference = Math.abs(arrowCenter - cardCenter);\n              console.log('🎯 WINNER LANDING VERIFICATION:');\n              console.log('  - Arrow center screen position:', arrowCenter, 'px');\n              console.log('  - Winner card center screen position:', cardCenter, 'px');\n              console.log('  - Alignment difference:', difference, 'px');\n              console.log('  - Success?', difference < 20 ? '✅ YES' : '❌ NO');\n              if (difference >= 20) {\n                console.log('❌ POSITIONING FAILED! Winner did not land under arrow');\n                console.log('   Consider adjusting calculation...');\n              }\n            } else {\n              console.log('⚠️ Could not find arrow or winner card for verification');\n            }\n          }, 100);\n          animationPhase = 'winner-paused';\n          // Pause animation briefly to show winner\n          carousel.style.transform = `translateX(-${currentPosition}px)`;\n          animationId = requestAnimationFrame(animate);\n          return;\n        }\n        carousel.style.transform = `translateX(-${currentPosition}px)`;\n        animationId = requestAnimationFrame(animate);\n        return;\n      }\n\n      // PHASE 4: Winner paused (showing winner for a moment)\n      if (animationPhase === 'winner-paused') {\n        // Just wait - timer will change phase to 'winner-displayed'\n        animationId = requestAnimationFrame(animate);\n        return;\n      }\n\n      // PHASE 5: Winner displayed, resume normal animation (but keep winner highlighted)\n      if (animationPhase === 'winner-displayed') {\n        // Resume normal carousel movement while keeping winner visually highlighted\n        // This shows the updated jackpot total while winner stays green until new round\n        currentPosition += 2; // Normal speed\n        if (currentPosition >= scrollParams.resetTriggerPoint) {\n          currentPosition = scrollParams.resetToPosition;\n        }\n        carousel.style.transform = `translateX(-${currentPosition}px)`;\n        animationId = requestAnimationFrame(animate);\n        return;\n      }\n\n      // If we reach here, something unexpected happened - continue animation\n      animationId = requestAnimationFrame(animate);\n    };\n\n    // Start animation\n    animationId = requestAnimationFrame(animate);\n\n    // Reset animation when new round starts\n    const resetAnimation = () => {\n      var _window$Telegram3;\n      // OPTIMIZED: Reduced logging\n      if (process.env.NODE_ENV === 'development') {\n        console.log('🔄 Resetting animation for new round');\n      }\n      animationPhase = 'normal';\n      winnerPositionFound = false;\n      winnerCardVisible = false;\n      targetPosition = null;\n      cachedTargetArrow = null; // Clear cache\n      setShowWinnerVisually(false); // Hide winner visually for new round\n\n      // OPTIMIZED: Use cached element or skip if not available\n      if (cachedTargetArrow) {\n        cachedTargetArrow.classList.remove('winner-approaching', 'winner-landed');\n      }\n\n      // OPTIMIZED: Simple position reset for Telegram - respects infinite scroll\n      if ((_window$Telegram3 = window.Telegram) !== null && _window$Telegram3 !== void 0 && _window$Telegram3.WebApp) {\n        // Recalculate scroll parameters for potential viewport changes\n        scrollParams = calculateScrollParameters();\n        currentPosition = scrollParams.resetToPosition; // Reset to middle set position\n        if (carousel) {\n          carousel.style.transform = `translateX(-${scrollParams.resetToPosition}px)`;\n        }\n      }\n\n      // Restart animation\n      if (animationId) {\n        cancelAnimationFrame(animationId);\n      }\n      animationId = requestAnimationFrame(animate);\n    };\n\n    // Expose reset function for external use - Enhanced for Telegram\n    window.resetCarouselAnimation = resetAnimation;\n\n    // OPTIMIZED: Minimal Telegram event listeners with throttling\n    if ((_window$Telegram4 = window.Telegram) !== null && _window$Telegram4 !== void 0 && _window$Telegram4.WebApp) {\n      let throttleTimeout = null;\n\n      // Throttled viewport change handler\n      const handleTelegramViewportChange = () => {\n        if (throttleTimeout) return; // Throttle to prevent spam\n        throttleTimeout = setTimeout(() => {\n          throttleTimeout = null;\n\n          // CRITICAL: Recalculate scroll parameters for new viewport\n          const oldCardWidth = scrollParams.cardWidth;\n          scrollParams = calculateScrollParameters();\n          console.log('📱 TELEGRAM VIEWPORT CHANGE:');\n          console.log('  - Old card width:', oldCardWidth, 'px');\n          console.log('  - New card width:', scrollParams.cardWidth, 'px');\n\n          // Only reset if card width actually changed\n          if (Math.abs(oldCardWidth - scrollParams.cardWidth) > 5) {\n            console.log('🔄 Card width changed significantly - resetting animation');\n            if (window.resetCarouselAnimation && animationPhase === 'normal') {\n              window.resetCarouselAnimation();\n            }\n          }\n        }, 300); // Increased delay to reduce CPU usage\n      };\n\n      // Listen for Telegram WebApp events (only essential ones)\n      if (window.Telegram.WebApp.onEvent) {\n        window.Telegram.WebApp.onEvent('viewportChanged', handleTelegramViewportChange);\n      }\n    }\n    return () => {\n      var _window$Telegram5;\n      if (animationId) {\n        cancelAnimationFrame(animationId);\n      }\n      // Restore CSS transition\n      if (carousel) {\n        carousel.style.transition = '';\n      }\n      // Clean up global reference\n      delete window.resetCarouselAnimation;\n\n      // Clean up Telegram-specific event listeners\n      if ((_window$Telegram5 = window.Telegram) !== null && _window$Telegram5 !== void 0 && _window$Telegram5.WebApp) {\n        console.log('🎯 Cleaning up Telegram WebApp event listeners');\n        // Remove Telegram WebApp event listeners\n        if (window.Telegram.WebApp.offEvent) {\n          window.Telegram.WebApp.offEvent('viewportChanged');\n        }\n      }\n    };\n  }, []); // EMPTY dependency array to prevent re-initialization\n\n  // Socket integration for immediate synchronization - SINGLE CONNECTION POINT\n  useEffect(() => {\n    console.log('🔌 App.js: Establishing single socket connection for entire app...');\n    socketService.connect();\n\n    // Listen for timer updates from socket\n    socketService.on('timer', timerData => {\n      console.log('⏰ App: Socket timer update:', timerData);\n\n      // SAFETY: Ensure timerData exists and has required properties\n      if (!timerData || typeof timerData !== 'object') {\n        console.warn('⚠️ Invalid timer data received in App:', timerData);\n        return;\n      }\n      const newTimeRemaining = typeof timerData.timeRemaining === 'number' ? timerData.timeRemaining : timeRemaining;\n      const newRoundNumber = typeof timerData.roundNumber === 'number' ? timerData.roundNumber : currentRound;\n\n      // Only update timeRemaining if it's significantly different (>2 seconds) or new round\n      setTimeRemaining(prev => {\n        const timeDiff = Math.abs(prev - newTimeRemaining);\n        const isNewRound = newRoundNumber !== currentRound;\n\n        // Only clear winner state when new round detected AND timer is significantly higher (real new round)\n        if (isNewRound && contractWinner && newTimeRemaining > 200) {\n          console.log('🔄 Timer update detected REAL new round with fresh timer - clearing winner state');\n          console.log('🔓 Exiting winner state - new round detected');\n          setIsInWinnerState(false);\n          setContractWinner(null);\n          setShowWinnerAnnouncement(false);\n          setShowWinnerVisually(false);\n          setPostWinnerLoading(false);\n          setIsAnyWinnerDisplayActive(false);\n          setPreviousRoundBettors([]);\n        }\n\n        // Sync if: new round, big difference (>10s), or timer reset (server > client)\n        if (isNewRound || timeDiff > 10 || newTimeRemaining > prev) {\n          console.log('⏰ Syncing timer:', prev, '→', newTimeRemaining, isNewRound ? '(new round)' : timeDiff > 10 ? '(>10s difference)' : '(backend ahead)');\n          return newTimeRemaining;\n        }\n\n        // Otherwise keep local countdown running smoothly\n        return prev;\n      });\n      if (newRoundNumber && newRoundNumber !== currentRound) {\n        setCurrentRound(newRoundNumber);\n      }\n      // Note: Contract state timer will be updated via fullGameUpdate/contractStateUpdate events\n    });\n\n    // Listen for new round events\n    socketService.on('newRound', roundData => {\n      console.log('🎰 App: New round detected via socket:', roundData);\n      console.log('🔓 Exiting winner state - new round started');\n      setTimeRemaining(roundData.timeRemaining);\n      setCurrentRound(roundData.roundNumber);\n      setIsInWinnerState(false);\n      setIsAnyWinnerDisplayActive(false);\n      winnerCoordinator.reset();\n      lastWinnerTimestampRef.current = null; // Clear duplicate protection for new round\n\n      // Clear ALL winner highlighting for new round\n      setContractWinner(null);\n      setShowWinnerAnnouncement(false);\n      setShowWinnerVisually(false);\n      setPreviousRoundBettors([]);\n      setWaitingForWinner(false);\n      setPostWinnerLoading(false);\n\n      // OPTIMIZED: Simple animation reset\n      if (window.resetCarouselAnimation) {\n        window.resetCarouselAnimation();\n      }\n    });\n\n    // Listen for game state updates\n    socketService.on('gameState', gameState => {\n      var _gameState$timer;\n      console.log('🎮 App: Game state update:', gameState);\n\n      // Priority: Use timer.timeRemaining ONLY (as user specified)\n      const backendTimeRemaining = (_gameState$timer = gameState.timer) === null || _gameState$timer === void 0 ? void 0 : _gameState$timer.timeRemaining;\n      if (backendTimeRemaining !== undefined) {\n        setTimeRemaining(prev => {\n          const timeDiff = Math.abs(prev - backendTimeRemaining);\n\n          // Only sync if there's a significant difference (>10s) or if backend is ahead\n          if (timeDiff > 10 || backendTimeRemaining > prev) {\n            console.log('⏰ GameState syncing timer:', prev, '→', backendTimeRemaining, timeDiff > 10 ? '(>10s difference)' : '(backend ahead)');\n            return backendTimeRemaining;\n          }\n\n          // Keep local countdown running if difference is small\n          console.log('⏰ GameState keeping local timer:', prev, 'vs backend:', backendTimeRemaining);\n          return prev;\n        });\n      }\n      if (gameState.currentRound) {\n        var _gameState$timer2, _gameState$timer3;\n        // Extract roundNumber if currentRound is an object, otherwise use the value directly\n        const roundNumber = typeof gameState.currentRound === 'object' && gameState.currentRound.roundNumber ? gameState.currentRound.roundNumber : gameState.currentRound;\n\n        // Check if this is a new round with active timer - this means new round started\n        const isNewRound = roundNumber !== currentRound;\n        const hasActiveTimer = ((_gameState$timer2 = gameState.timer) === null || _gameState$timer2 === void 0 ? void 0 : _gameState$timer2.isActive) || ((_gameState$timer3 = gameState.timer) === null || _gameState$timer3 === void 0 ? void 0 : _gameState$timer3.timeRemaining) > 60;\n        if (isNewRound && hasActiveTimer && isInWinnerStateRef.current) {\n          console.log('🔄 GameState detected NEW ROUND with active timer - clearing winner state');\n          console.log('🔓 Exiting winner state - new round started via gameState');\n          setIsInWinnerState(false);\n          setContractWinner(null);\n          setShowWinnerAnnouncement(false);\n          setShowWinnerVisually(false);\n          setPostWinnerLoading(false);\n          setIsAnyWinnerDisplayActive(false);\n          setPreviousRoundBettors([]);\n          winnerCoordinator.reset();\n        }\n        setCurrentRound(roundNumber);\n      }\n\n      // Handle winner-related states\n      if (gameState.isWaitingForWinner !== undefined) {\n        // If transitioning TO waiting for winner, store current bettors\n        if (gameState.isWaitingForWinner && !waitingForWinnerRef.current && gameBettorsRef.current.length > 0) {\n          console.log('🎮 App: Transitioning to waiting for winner, storing bettors:', gameBettorsRef.current);\n          setPreviousRoundBettors([...gameBettorsRef.current]);\n        }\n        setWaitingForWinner(gameState.isWaitingForWinner);\n\n        // If waitingForWinner becomes false AND we have a new round with active timer, reset winner state\n        if (!gameState.isWaitingForWinner && isInWinnerStateRef.current) {\n          var _gameState$timer4, _gameState$timer5;\n          const roundNumber = typeof gameState.currentRound === 'object' && gameState.currentRound.roundNumber ? gameState.currentRound.roundNumber : gameState.currentRound;\n          const isNewRound = roundNumber && roundNumber !== currentRound;\n          const hasActiveTimer = ((_gameState$timer4 = gameState.timer) === null || _gameState$timer4 === void 0 ? void 0 : _gameState$timer4.isActive) || ((_gameState$timer5 = gameState.timer) === null || _gameState$timer5 === void 0 ? void 0 : _gameState$timer5.timeRemaining) > 60;\n          if (isNewRound && hasActiveTimer) {\n            console.log('🔄 waitingForWinner false + new round + active timer = new round started - clearing winner state');\n            console.log('🔓 Exiting winner state - new round confirmed');\n            setIsInWinnerState(false);\n            setContractWinner(null);\n            setShowWinnerAnnouncement(false);\n            setShowWinnerVisually(false);\n            setPostWinnerLoading(false);\n            setIsAnyWinnerDisplayActive(false);\n            setPreviousRoundBettors([]);\n            winnerCoordinator.reset();\n          } else {\n            console.log('⏳ waitingForWinner became false, but keeping winner state (no new round detected)');\n          }\n        }\n      }\n\n      // Update bettors data centrally (avoids duplicate processing)\n      if (gameState.bettors && Array.isArray(gameState.bettors)) {\n        // Only log if bettors count changed to reduce spam\n        if (gameState.bettors.length !== gameBettorsRef.current.length) {\n          console.log('🎮 App: Updating bettors from gameState:', gameState.bettors.length, 'bettors');\n          // Trigger slot machine animation when new bettor joins\n          setSlotSpinning(true);\n          setTimeout(() => setSlotSpinning(false), 3000);\n        }\n\n        // Store current bettors as previous round bettors when waiting for winner\n        if (gameState.isWaitingForWinner && gameState.bettors.length > 0) {\n          console.log('🎮 App: Storing bettors for winner matching:', gameState.bettors);\n          setPreviousRoundBettors([...gameState.bettors]);\n        }\n        setGameBettors(gameState.bettors);\n      }\n\n      // Check for winner announcement in game state (prevent duplicates with stronger protection)\n      if (gameState.winnerAnnouncement) {\n        showWinnerAnnouncements(gameState.winnerAnnouncement, 'gameState');\n      }\n    });\n\n    // Listen for comprehensive game data updates\n    socketService.on('fullGameUpdate', gameData => {\n      console.log('🎮 App: Full game update:', gameData);\n      // These updates will trigger re-renders via useJackpotContract hook\n      // The hook will detect the changes and update accordingly\n    });\n\n    // Listen for bettors updates\n    socketService.on('bettorsUpdate', data => {\n      console.log('💰 App: Bettors update:', data);\n      // Trigger slot machine animation on bettor updates\n      setSlotSpinning(true);\n      setTimeout(() => setSlotSpinning(false), 3000);\n      // Force a refresh of contract state to sync with socket data\n      // This ensures jackpot value and user stats stay in sync\n    });\n\n    // Listen for waiting for winner events\n    socketService.on('waitingForWinner', data => {\n      console.log('🎯 App: Waiting for winner state changed:', data);\n\n      // Handle both old boolean format and new object format\n      const isWaiting = typeof data === 'boolean' ? data : data.isWaiting;\n      const message = typeof data === 'object' ? data.message : null;\n\n      // Don't reset winner state just because waitingForWinner changed\n      // Only reset when we get explicit newRound/roundReset events\n      setWaitingForWinner(isWaiting);\n\n      // Log but don't auto-reset winner state\n      if (!isWaiting && isInWinnerStateRef.current) {\n        console.log('⏳ waitingForWinner event became false, but keeping winner state until explicit new round');\n      }\n      if (message) {\n        console.log('🎯 App: Winner selection message:', message);\n      }\n    });\n\n    // Listen for winner announcements (primary)\n    socketService.on('winner', winnerData => {\n      console.log('🏆 App: Winner announced:', winnerData);\n      console.log('🏆 App: Current gameBettors for comparison:', gameBettors);\n      console.log('🏆 App: Previous round bettors for comparison:', previousRoundBettors);\n      setWaitingForWinner(false);\n      setPostWinnerLoading(true);\n\n      // Use centralized manager\n      showWinnerAnnouncements(winnerData, 'winner event');\n    });\n\n    // Listen for direct winner announcements (fallback/reliable delivery)\n    socketService.on('winnerAnnouncement', winnerData => {\n      console.log('🎯 App: Direct winner announcement:', winnerData);\n      setWaitingForWinner(false);\n\n      // Use centralized manager\n      showWinnerAnnouncements(winnerData, 'direct announcement');\n    });\n\n    // Listen for round reset events (when timer is reset due to no bettors)\n    socketService.on('roundReset', resetData => {\n      console.log('🔄 App: Round reset detected:', resetData);\n      console.log('🔓 Exiting winner state - round reset');\n\n      // Reset timer to the new duration\n      setTimeRemaining(resetData.timeRemaining);\n      setCurrentRound(resetData.roundNumber);\n\n      // Clear ALL winner states since this is a fresh timer\n      setIsInWinnerState(false);\n      setWaitingForWinner(false);\n      setContractWinner(null);\n      setShowWinnerAnnouncement(false);\n      setShowWinnerVisually(false);\n      setPostWinnerLoading(false);\n      setIsAnyWinnerDisplayActive(false);\n      winnerCoordinator.reset();\n\n      // Clear bettors list since round was reset\n      setGameBettors([]);\n      setPreviousRoundBettors([]);\n\n      // OPTIMIZED: Simple animation reset\n      if (window.resetCarouselAnimation) {\n        window.resetCarouselAnimation();\n      }\n    });\n    return () => {\n      console.log('🔌 App.js: Cleaning up socket listeners...');\n      socketService.off('timer');\n      socketService.off('newRound');\n      socketService.off('roundReset');\n      socketService.off('gameState');\n      socketService.off('fullGameUpdate');\n      socketService.off('bettorsUpdate');\n      socketService.off('waitingForWinner');\n      socketService.off('winner');\n      socketService.off('winnerAnnouncement');\n      // Disconnect when app unmounts to prevent memory leaks\n      socketService.disconnect();\n    };\n  }, [currentRound, showWinnerAnnouncements]); // Added missing dependencies\n\n  const handleBetChange = e => {\n    const inputValue = e.target.value;\n\n    // Allow empty input or numbers with decimal points (both . and ,)\n    if (inputValue === '' || inputValue === '.' || inputValue === ',' || /^\\d*[.,]?\\d*$/.test(inputValue)) {\n      // Convert comma to period for consistency\n      const normalizedValue = inputValue.replace(',', '.');\n\n      // For empty or just \".\" input, keep the raw value but show comma if user typed comma\n      if (normalizedValue === '' || normalizedValue === '.') {\n        setBetAmount(inputValue); // Keep original input (might be comma)\n        return;\n      }\n\n      // For valid numbers, check limits but preserve decimal typing\n      const numericValue = parseFloat(normalizedValue);\n      if (!isNaN(numericValue) && numericValue <= 10) {\n        setBetAmount(inputValue); // Keep the original input format (comma or period)\n      }\n    }\n  };\n  const handleTabChange = tab => {\n    hapticFeedback('light');\n    setActiveTab(tab);\n  };\n\n  // Enhanced bet placement with real smart contract\n  const handlePlaceBet = async () => {\n    // Prevent betting during winner display period\n    if (contractWinner || showWinnerAnnouncement) {\n      showAlert('⏳ Please wait for the new round to start before placing a bet!');\n      return;\n    }\n    if (!isConnected) {\n      showAlert('Please connect your wallet first!');\n      return;\n    }\n\n    // Convert comma to period before parsing for validation\n    const normalizedBetAmount = betAmount.toString().replace(',', '.');\n    const numericBetAmount = parseFloat(normalizedBetAmount);\n    if (isNaN(numericBetAmount) || numericBetAmount <= 0) {\n      showAlert('Please enter a valid bet amount!');\n      return;\n    }\n    try {\n      hapticFeedback('medium');\n      await placeBet(numericBetAmount);\n\n      // Reset bet amount after successful bet\n      setBetAmount(0.11);\n      hapticFeedback('success');\n      showAlert(`✅ Bet of ${numericBetAmount.toFixed(3)} TON placed successfully!`);\n    } catch (error) {\n      console.error('Failed to place bet:', error);\n      hapticFeedback('error');\n      showAlert(`❌ Failed to place bet: ${error.message}`);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"app-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"header-section\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"header-top\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"logo-section\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"logo-icon\",\n              children: \"\\uD83C\\uDFB0\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1280,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"app-name\",\n              children: \"SlotPot\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1281,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1279,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"balance-section\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"balance-label\",\n              children: \"Balance\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1285,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"balance-amount\",\n              children: [isConnected ? `${(contractState.userBalance || 0).toFixed(6)}` : '0.000000', /*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"balance-symbol\",\n                children: \"TON\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1288,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1286,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1284,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"header-icons\",\n            children: /*#__PURE__*/_jsxDEV(WalletConnection, {}, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1293,\n              columnNumber: 17\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1292,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1278,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1277,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"main-content\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"jackpot-header\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"jackpot-title\",\n            children: \"\\uD83D\\uDCB0 JACKPOT\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1302,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"jackpot-value-display\",\n            children: jackpotValue.toFixed(3)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1303,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"jackpot-subtitle\",\n            children: \"Winner takes all...\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1304,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1301,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"betting-section\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"bet-input-section\",\n            children: [/*#__PURE__*/_jsxDEV(\"input\", {\n              type: \"text\",\n              className: \"bet-amount-input\",\n              value: betAmount,\n              onChange: handleBetChange,\n              placeholder: \"0.000\",\n              inputMode: \"decimal\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1310,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n              className: \"bet-increment-btn\",\n              onClick: () => setBetAmount(prev => {\n                const currentValue = parseFloat(prev) || 0;\n                return Math.min(currentValue + 0.1, 10).toFixed(1);\n              }),\n              children: \"+0.1\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1318,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1309,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"bet-button\",\n            onClick: handlePlaceBet,\n            disabled: isPlacingBet || !isConnected || contractWinner || showWinnerAnnouncement,\n            children: contractWinner || showWinnerAnnouncement ? 'Winner Display - Wait for New Round' : isPlacingBet ? 'Betting...' : 'Bet'\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1325,\n            columnNumber: 11\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1308,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"stats-grid\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"stat-card\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"stat-value\",\n              children: userBetTotal.toFixed(3)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1338,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"stat-label\",\n              children: \"Your Wager\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1339,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1337,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"stat-card chance-stat\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"stat-value\",\n              children: [userWinChance.toFixed(2), \"%\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 1342,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"stat-label\",\n              children: \"Your Chance\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1343,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1341,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1336,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"time-section\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"time-label\",\n            children: \"Time Remaining \"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1349,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"time-value\",\n            children: [Math.floor((timeRemaining || 0) / 60), \":\", ((timeRemaining || 0) % 60).toString().padStart(2, '0')]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1350,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1348,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"players-carousel-section\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: `carousel-header ${timeRemaining === 0 && waitingForWinner || contractWinner && !showWinnerVisually ? 'analyzing' : showWinnerVisually ? 'winner' : ''}`,\n            children: /*#__PURE__*/_jsxDEV(\"h3\", {\n              children: timeRemaining === 0 && waitingForWinner || contractWinner && !showWinnerVisually ? \"🔍 Analyzing Bets...\" : showWinnerVisually && contractWinner ? `🏆 Winner: ${contractWinner.username || contractWinner.displayName || contractWinner.winner || 'Player'}` : `Players (${gameBettors.length > 0 ? gameBettors.length : previousRoundBettors.length})`\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1361,\n              columnNumber: 17\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1357,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(SimpleCarousel, {\n            players: (() => {\n              // Same data logic as before\n              const bettorsToShow = contractWinner || waitingForWinner ? previousRoundBettors.length > 0 ? previousRoundBettors : gameBettors : gameBettors.length > 0 ? gameBettors : [];\n\n              // Ensure we have at least 6 items to show (fill with waiting slots if needed)\n              return [...bettorsToShow, ...Array.from({\n                length: Math.max(0, 6 - bettorsToShow.length)\n              }, () => null)];\n            })(),\n            winner: showWinnerVisually ? contractWinner : null,\n            isSpinning: timeRemaining === 0 && waitingForWinner || contractWinner && !showWinnerVisually,\n            onWinnerLand: () => {\n              console.log('🎯 Winner landed in Swiper carousel!');\n              // Winner is already set via showWinnerVisually\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1372,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1356,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1299,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"mobile-footer\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"footer-stats\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"footer-stat\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"footer-stat-icon\",\n              children: \"\\uD83C\\uDFE0\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1399,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"footer-stat-value\",\n              children: \"Home\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1400,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1398,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"footer-stat\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"footer-stat-icon\",\n              children: \"\\u26A1\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1403,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"footer-stat-value\",\n              children: \"Fast\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1404,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1402,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"footer-stat\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"footer-stat-icon\",\n              children: \"\\uD83D\\uDD50\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1407,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"footer-stat-value\",\n              children: \"History\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1408,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1406,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"footer-stat\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"footer-stat-icon\",\n              children: \"\\uD83D\\uDD0D\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1411,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"footer-stat-value\",\n              children: \"Search\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1412,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 1410,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1397,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"games-button\",\n          children: [/*#__PURE__*/_jsxDEV(DollarSign, {\n            size: 14\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1416,\n            columnNumber: 15\n          }, this), \"Games\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1415,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1396,\n        columnNumber: 7\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1275,\n      columnNumber: 9\n    }, this), isLoadingContract && !contractWinner && !showWinnerAnnouncement && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"loading-overlay\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"loading-spinner\",\n        children: \"\\uD83D\\uDD04\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1425,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Loading contract data...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1426,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1424,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(WinnerBroadcast, {\n      socketService: socketService\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1431,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1274,\n    columnNumber: 5\n  }, this);\n}\n\n// Main App component with TON Connect Provider\n_s(AppContent, \"d+HjA7TBP0IihRcCGYzBzxoK/Uc=\", false, function () {\n  return [useTelegramWebApp, useJackpotContract];\n});\n_c = AppContent;\nfunction App() {\n  return /*#__PURE__*/_jsxDEV(TonConnectUIProvider, {\n    manifestUrl: manifestUrl,\n    uiPreferences: uiOptions.uiPreferences,\n    language: uiOptions.language,\n    restoreConnection: uiOptions.restoreConnection,\n    actionsConfiguration: uiOptions.actionsConfiguration,\n    children: /*#__PURE__*/_jsxDEV(AppContent, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1446,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1439,\n    columnNumber: 5\n  }, this);\n}\n_c2 = App;\nexport default App;\nvar _c, _c2;\n$RefreshReg$(_c, \"AppContent\");\n$RefreshReg$(_c2, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","useMemo","TonConnectUIProvider","Chat","GameArea","MobileChat","WalletConnection","WinnerBroadcast","SimpleCarousel","useTelegramWebApp","useJackpotContract","socketService","winnerCoordinator","uiOptions","MessageCircle","Trophy","Users","DollarSign","jsxDEV","_jsxDEV","manifestUrl","AppContent","_s","_contractState$timer2","currentRound","setCurrentRound","timeRemaining","setTimeRemaining","activeTab","setActiveTab","betAmount","setBetAmount","showWinnerAnnouncement","setShowWinnerAnnouncement","waitingForWinner","setWaitingForWinner","contractWinner","setContractWinner","postWinnerLoading","setPostWinnerLoading","setIsAnyWinnerDisplayActive","showWinnerVisually","setShowWinnerVisually","isInWinnerState","setIsInWinnerState","gameBettors","setGameBettors","previousRoundBettors","setPreviousRoundBettors","slotSpinning","setSlotSpinning","gameBettorsRef","contractWinnerRef","showWinnerAnnouncementRef","lastWinnerTimestampRef","waitingForWinnerRef","previousRoundBettorsRef","timeRemainingRef","showWinnerVisuallyRef","isInWinnerStateRef","current","console","log","winnerAddress","winner","fullAddress","winnerName","username","displayName","prize","showWinnerAnnouncements","winnerData","source","winnerTimestamp","timestamp","shouldBlock","setActive","setTimeout","user","hapticFeedback","showAlert","hasRealUserData","contractState","userStats","adminInfo","rawAdminInfo","isLoadingContract","isPlacingBet","placeBet","isConnected","address","_rawAdminInfo$current","isAutoManaged","roundDuration","minBetsToEnd","timerActive","Boolean","Number","roundNumber","safeContractState","_contractState$curren","timer","isActive","timeElapsed","timerExpired","undefined","jackpotValue","totalJackpot","isLive","userBetTotal","length","filter","bettor","walletAddress","reduce","total","amount","userWinChance","currentRoundTotal","liveJackpotValue","_contractState$timer","countdown","setInterval","prev","newTime","clearInterval","_window$Telegram4","carousel","carouselRef","style","transition","animationId","currentPosition","winnerPositionFound","winnerCardVisible","targetPosition","animationPhase","getDynamicCardWidth","_window$Telegram","isInTelegram","window","Telegram","WebApp","screenWidth","viewportWidth","innerWidth","baseCardWidth","gap","cardPlusGap","process","env","NODE_ENV","cardWidth","cachedTargetArrow","getCurrentBettors","getPreviousBettors","getContractWinner","getWaitingForWinner","getTimeRemaining","getShowWinnerVisually","getBettorsForAnimation","currentBettors","prevBettors","currentWinnerData","isWaitingData","bettorsToShow","allItems","Array","from","Math","max","item","singleSetLength","calculateScrollParameters","currentCardWidth","singleSetWidth","resetTriggerPoint","resetToPosition","scrollParams","animate","currentWinner","isWaiting","timeLeft","transform","requestAnimationFrame","showWinnerVisuallyNow","infiniteItems","winnerIndex","map","i","index","bettor_address","bettor_username","bettor_displayName","winner_winner","winner_fullAddress","winner_address","winner_username","winner_displayName","isMatch","addressMatch","usernameMatch","isWinner","injected","firstEmptyIndex","findIndex","injectionIndex","document","querySelector","targetArrow","carouselContainer","carouselRect","getBoundingClientRect","arrowRect","containerRect","arrowCenterOffset","_window$Telegram2","arrowCenterInContainer","left","width","isLandscape","innerHeight","landscapeOffset","telegramAdjustment","currentPositionInCards","targetSetIndex","targetWinnerIndex","winnerCardPosition","cardCenterOffset","targetPositionForWinnerCenter","finalTargetPosition","landscapeFineAdjustment","distanceToTarget","abs","speed","floor","toFixed","classList","add","remove","winnerCard","cardRect","arrowCenter","cardCenter","difference","resetAnimation","_window$Telegram3","cancelAnimationFrame","resetCarouselAnimation","throttleTimeout","handleTelegramViewportChange","oldCardWidth","onEvent","_window$Telegram5","offEvent","connect","on","timerData","warn","newTimeRemaining","newRoundNumber","timeDiff","isNewRound","roundData","reset","gameState","_gameState$timer","backendTimeRemaining","_gameState$timer2","_gameState$timer3","hasActiveTimer","isWaitingForWinner","_gameState$timer4","_gameState$timer5","bettors","isArray","winnerAnnouncement","gameData","data","message","resetData","off","disconnect","handleBetChange","e","inputValue","target","value","test","normalizedValue","replace","numericValue","parseFloat","isNaN","handleTabChange","tab","handlePlaceBet","normalizedBetAmount","toString","numericBetAmount","error","className","children","fileName","_jsxFileName","lineNumber","columnNumber","userBalance","type","onChange","placeholder","inputMode","onClick","currentValue","min","disabled","padStart","players","isSpinning","onWinnerLand","size","_c","App","uiPreferences","language","restoreConnection","actionsConfiguration","_c2","$RefreshReg$"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/src/App.js"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nimport { TonConnectUIProvider } from '@tonconnect/ui-react';\nimport Chat from './components/Chat';\nimport GameArea from './components/GameArea';\nimport MobileChat from './components/MobileChat';\nimport WalletConnection from './components/WalletConnection';\nimport WinnerBroadcast from './components/WinnerBroadcast';\nimport SimpleCarousel from './components/SimpleCarousel';\nimport useTelegramWebApp from './hooks/useTelegramWebApp';\nimport useJackpotContract from './hooks/useJackpotContract';\nimport socketService from './services/socketService';\nimport winnerCoordinator from './services/winnerCoordinator';\nimport { uiOptions } from './config/tonconnect';\nimport { MessageCircle, Trophy, Users, DollarSign } from 'lucide-react';\nimport './App.css';\nimport './components/Header.css';\n\n// TON Connect manifest URL - use remote manifest to avoid 500 errors\nconst manifestUrl = \"https://raw.githubusercontent.com/Vodka2134156/kzsks/main/manifest.json\";\n\nfunction AppContent() {\n  // Local UI state\n  const [currentRound, setCurrentRound] = useState(53408);\n  const [timeRemaining, setTimeRemaining] = useState(30);\n  const [activeTab, setActiveTab] = useState('jackpot');\n  const [betAmount, setBetAmount] = useState(0.11);\n  const [showWinnerAnnouncement, setShowWinnerAnnouncement] = useState(false);\n  \n  // Winner state management (moved from GameArea.js)\n  const [waitingForWinner, setWaitingForWinner] = useState(false);\n  const [contractWinner, setContractWinner] = useState(null);\n  const [postWinnerLoading, setPostWinnerLoading] = useState(false);\n  const [, setIsAnyWinnerDisplayActive] = useState(false);\n  const [showWinnerVisually, setShowWinnerVisually] = useState(false); // Controls when winner card appears\n  const [isInWinnerState, setIsInWinnerState] = useState(false); // Blocks new winner broadcasts\n  \n  // Bettors state (managed centrally to avoid duplicates)\n  const [gameBettors, setGameBettors] = useState([]);\n  const [previousRoundBettors, setPreviousRoundBettors] = useState([]); // Store bettors for winner matching\n  const [slotSpinning, setSlotSpinning] = useState(false);\n  // Note: carouselRef removed - now using Swiper component\n\n  // Refs to avoid stale closures in socket handlers\n  const gameBettorsRef = useRef([]);\n  const contractWinnerRef = useRef(null);\n  const showWinnerAnnouncementRef = useRef(false);\n  const lastWinnerTimestampRef = useRef(null);\n  const waitingForWinnerRef = useRef(false);\n  const previousRoundBettorsRef = useRef([]);\n  const timeRemainingRef = useRef(30);\n  const showWinnerVisuallyRef = useRef(false);\n  const isInWinnerStateRef = useRef(false);\n  \n  // Keep refs in sync with state\n  useEffect(() => { gameBettorsRef.current = gameBettors; }, [gameBettors]);\n  useEffect(() => { \n    contractWinnerRef.current = contractWinner; \n    \n    // Log winner detection only once when contractWinner changes\n    if (contractWinner) {\n      console.log('🏆 WINNER DETECTED FROM BACKEND!', { \n        winnerAddress: contractWinner.winner || contractWinner.fullAddress,\n        winnerName: contractWinner.username || contractWinner.displayName || 'Player',\n        prize: contractWinner.prize,\n        contractWinner\n      });\n      console.log('🎬 ANIMATION SHOULD START NOW - waiting for carousel to detect winner');\n    } else {\n      console.log('❌ WINNER CLEARED - contractWinner set to null');\n    }\n  }, [contractWinner]);\n  useEffect(() => { showWinnerAnnouncementRef.current = showWinnerAnnouncement; }, [showWinnerAnnouncement]);\n  useEffect(() => { waitingForWinnerRef.current = waitingForWinner; }, [waitingForWinner]);\n  useEffect(() => { previousRoundBettorsRef.current = previousRoundBettors; }, [previousRoundBettors]);\n  useEffect(() => { timeRemainingRef.current = timeRemaining; }, [timeRemaining]);\n  useEffect(() => { showWinnerVisuallyRef.current = showWinnerVisually; }, [showWinnerVisually]);\n  useEffect(() => { isInWinnerStateRef.current = isInWinnerState; }, [isInWinnerState]);\n\n  // Centralized winner announcement manager\n  const showWinnerAnnouncements = useCallback((winnerData, source = 'unknown') => {\n    const winnerTimestamp = winnerData.timestamp;\n    \n    // Block winner broadcasts if already in winner state\n    if (isInWinnerStateRef.current) {\n      console.log(`🚫 BLOCKED - Already in winner state, ignoring winner broadcast from ${source}`);\n      return false;\n    }\n    \n    // Use coordinator to check if should block (pass full winner data for better duplicate detection)\n    if (winnerCoordinator.shouldBlock(winnerTimestamp, winnerData)) {\n      console.log(`🔄 Winner announcement blocked by coordinator (${source})`);\n      return false;\n    }\n    \n    console.log(`🎉 Showing winner announcements from ${source}:`, winnerData);\n    console.log(`🎯 Entering winner state - blocking future winner broadcasts`);\n    \n    // Enter winner state to block future broadcasts\n    setIsInWinnerState(true);\n    \n    // Set coordination flag via coordinator (pass full winner data)\n    winnerCoordinator.setActive(true, winnerTimestamp, winnerData);\n    setIsAnyWinnerDisplayActive(true);\n    lastWinnerTimestampRef.current = winnerTimestamp;\n    \n    // Show App.js winner notification\n    setContractWinner(winnerData);\n    setShowWinnerAnnouncement(true);\n    setWaitingForWinner(false);\n    \n    // Start animation - winner visual will appear after animation lands on winner\n    setTimeout(() => {\n      console.log('🎬 Animation should have landed on winner - showing winner visually');\n      setShowWinnerVisually(true);\n    }, 3000); // Give animation time to land properly\n    \n    // Winner will stay visible until new round starts (no automatic timeout)\n    console.log('🏆 Winner display will persist until new round is declared by backend');\n    \n    return true;\n  }, []);\n\n  // Telegram integration\n  const { user, hapticFeedback, showAlert, hasRealUserData } = useTelegramWebApp();\n\n  // Smart contract integration\n  const {\n    contractState,\n    userStats,\n    adminInfo: rawAdminInfo,\n    isLoadingContract,\n    isPlacingBet,\n    placeBet,\n    isConnected,\n    address,\n  } = useJackpotContract();\n\n  // SAFETY: Ensure adminInfo is always properly structured and never an object that could be rendered\n  const adminInfo = useMemo(() => {\n    if (!rawAdminInfo || typeof rawAdminInfo !== 'object') {\n      return {\n        isAutoManaged: false,\n        roundDuration: 300,\n        minBetsToEnd: 1,\n        timerActive: false,\n        timeRemaining: 0\n      };\n    }\n    \n    // Extract only primitive values to prevent accidental object rendering\n    return {\n      isAutoManaged: Boolean(rawAdminInfo.isAutoManaged),\n      roundDuration: Number(rawAdminInfo.roundDuration) || 300,\n      minBetsToEnd: Number(rawAdminInfo.minBetsToEnd) || 1,\n      timerActive: Boolean(rawAdminInfo.timerActive),\n      timeRemaining: Number(rawAdminInfo.timeRemaining) || 0,\n      // Ensure currentRound is always a number, never an object\n      currentRound: typeof rawAdminInfo.currentRound === 'object' \n        ? (rawAdminInfo.currentRound?.roundNumber || 0)\n        : (Number(rawAdminInfo.currentRound) || 0)\n    };\n  }, [rawAdminInfo]);\n\n  // SAFETY: Ensure contractState timer properties are never objects that could be accidentally rendered\n  const safeContractState = useMemo(() => {\n    if (!contractState) return contractState;\n    \n    return {\n      ...contractState,\n      // Ensure timer object properties are always primitives\n      timer: contractState.timer ? {\n        isActive: Boolean(contractState.timer.isActive),\n        timeRemaining: Number(contractState.timer.timeRemaining) || 0,\n        timeElapsed: Number(contractState.timer.timeElapsed) || 0,\n        roundNumber: Number(contractState.timer.roundNumber) || 0,\n        timerExpired: Boolean(contractState.timer.timerExpired)\n      } : undefined,\n      // Ensure currentRound is always a number if it exists\n      currentRound: typeof contractState.currentRound === 'object' \n        ? (contractState.currentRound?.roundNumber || 0)\n        : contractState.currentRound\n    };\n  }, [contractState]);\n\n  // Use real contract data or fallback to simulated data\n  const jackpotValue = contractState.totalJackpot;\n  const isLive = contractState.isActive;\n  \n  // Calculate user stats from gameBettors data\n  const userBetTotal = useMemo(() => {\n    if (!isConnected || !address || !gameBettors.length) return 0;\n    \n    return gameBettors\n      .filter(bettor => \n        bettor.address === address || \n        bettor.walletAddress === address\n      )\n      .reduce((total, bettor) => total + (bettor.amount || 0), 0);\n  }, [gameBettors, address, isConnected]);\n  \n  const userWinChance = useMemo(() => {\n    if (!isConnected || !address || userBetTotal === 0) return 0;\n    \n    // Calculate current round total from gameBettors for immediate updates\n    const currentRoundTotal = gameBettors.reduce((total, bettor) => total + (bettor.amount || 0), 0);\n    \n    // Use the live total from current bettors, fallback to contract jackpot value\n    const liveJackpotValue = currentRoundTotal > 0 ? currentRoundTotal : jackpotValue;\n    \n    if (!liveJackpotValue) return 0;\n    \n    return (userBetTotal / liveJackpotValue) * 100;\n  }, [userBetTotal, jackpotValue, gameBettors, isConnected, address]);\n\n  // Use automation timer or fallback to UI timer\n  useEffect(() => {\n    // Always sync with backend timer when it changes\n    if (contractState.timer?.timeRemaining !== undefined) {\n      setTimeRemaining(contractState.timer.timeRemaining);\n    } else {\n      setTimeRemaining(30);\n    }\n  }, [contractState.timer?.timeRemaining]);\n\n  // Local countdown timer (runs between backend updates)\n  useEffect(() => {\n    // Only run countdown when game is live\n    if (!isLive) return;\n\n    console.log('⏰ Starting local countdown timer...');\n\n    const countdown = setInterval(() => {\n      setTimeRemaining(prev => {\n        // Continue countdown even at 0 but don't go negative\n        if (prev > 0) {\n          const newTime = prev - 1;\n          console.log('⏰ Local countdown:', newTime);\n        \n          // When we reach 0, trigger \"analyzing bets\" state locally\n        if (newTime === 0) {\n            console.log('⏰ Local timer reached 0, entering analyzing state...');\n            setWaitingForWinner(true); // This will show \"Analyzing Bets...\"\n        }\n        \n        return newTime;\n        }\n        \n        // Stay at 0 once we reach it (don't go negative)\n        return 0;\n      });\n    }, 1000);\n\n    return () => {\n      console.log('⏰ Stopping local countdown timer...');\n      clearInterval(countdown);\n    };\n  }, [isLive]); // Restart when isLive changes\n\n  // Smooth infinite carousel effect\n  useEffect(() => {\n    const carousel = carouselRef.current;\n    if (!carousel) {\n      console.log('⚠️ CAROUSEL REF NOT READY - animation cannot start');\n      return;\n    }\n\n    console.log('🎠 CAROUSEL ANIMATION STARTING with ref:', carousel);\n\n    // Disable CSS transitions for smooth JS animation\n    carousel.style.transition = 'none';\n\n    let animationId;\n    let currentPosition = 0;\n    let winnerPositionFound = false;\n    let winnerCardVisible = false;\n    let targetPosition = null; // For dramatic slow-down effect\n    let animationPhase = 'normal'; // 'normal', 'fast-spin', 'slow-reveal'\n    // FIXED: Dynamic card width calculation to match carousel rendering\n    // This must match the card width used in the actual carousel\n    const getDynamicCardWidth = () => {\n      const isInTelegram = window.Telegram?.WebApp;\n      const screenWidth = isInTelegram ? (window.Telegram.WebApp.viewportWidth || window.innerWidth) : window.innerWidth;\n      \n      // Match the logic from GameArea.js carousel rendering\n      const baseCardWidth = screenWidth <= 480 ? 120 : 150;\n      const gap = screenWidth <= 480 ? 15 : 20;\n      const cardPlusGap = baseCardWidth + gap;\n      \n             // Only log on first calculation or significant changes\n       if (process.env.NODE_ENV === 'development') {\n         console.log('📐 Card width:', cardPlusGap, 'px', isInTelegram ? '(Telegram)' : '(Web)');\n       }\n      \n      return cardPlusGap;\n    };\n    \n    const cardWidth = getDynamicCardWidth();\n    \n    // OPTIMIZED: Cache DOM elements to avoid repeated queries\n    let cachedTargetArrow = null;\n    \n    // Use refs to get current values without causing re-renders\n    const getCurrentBettors = () => gameBettorsRef.current;\n    const getPreviousBettors = () => previousRoundBettorsRef.current;\n    const getContractWinner = () => contractWinnerRef.current;\n    const getWaitingForWinner = () => waitingForWinnerRef.current;\n    const getTimeRemaining = () => timeRemainingRef.current;\n    const getShowWinnerVisually = () => showWinnerVisuallyRef.current;\n    \n    const getBettorsForAnimation = () => {\n      const currentBettors = getCurrentBettors();\n      const prevBettors = getPreviousBettors();\n      const currentWinnerData = getContractWinner();\n      const isWaitingData = getWaitingForWinner();\n      \n      // FIXED: Use the EXACT SAME logic as the carousel rendering\n      const bettorsToShow = (currentWinnerData || isWaitingData) ? \n                           prevBettors.length > 0 ? prevBettors : currentBettors :\n                           currentBettors.length > 0 ? currentBettors : [];\n      \n      console.log('🎠 getBettorsForAnimation - FIXED DATA FLOW:');\n      console.log('  - Context: contractWinner:', !!currentWinnerData, 'waitingForWinner:', isWaitingData);\n      console.log('  - Available: currentBettors:', currentBettors.length, 'prevBettors:', prevBettors.length);\n      console.log('  - Using bettorsToShow:', bettorsToShow.length, 'bettors');\n      \n      // Ensure we have at least 6 items to show (fill with waiting slots if needed) - SAME AS CAROUSEL\n      const allItems = [\n        ...bettorsToShow,\n        ...Array.from({ length: Math.max(0, 6 - bettorsToShow.length) }, () => null)\n      ];\n      \n      console.log('🎠 getBettorsForAnimation - Created array with:', allItems.length, 'items total');\n      console.log('🎠 Real players:', allItems.filter(item => item !== null).length);\n      console.log('🎠 Waiting slots:', allItems.filter(item => item === null).length);\n      \n      return allItems;\n    };\n    \n    // FIX: Infinite scroll reset logic with dynamic recalculation\n    // The carousel renders 3 identical sets of cards for seamless infinite scroll\n    const singleSetLength = 6; // Fixed to match carousel rendering (6 items minimum)\n    \n    // Function to recalculate scroll parameters (for viewport changes)\n    const calculateScrollParameters = () => {\n      const currentCardWidth = getDynamicCardWidth();\n      const singleSetWidth = currentCardWidth * singleSetLength;\n      const resetTriggerPoint = singleSetWidth * 2; // After 2 complete sets (12 cards)\n      const resetToPosition = singleSetWidth; // Reset back to start of second set\n      \n      return {\n        cardWidth: currentCardWidth,\n        singleSetWidth,\n        resetTriggerPoint,\n        resetToPosition\n      };\n    };\n    \n    // Initial calculation\n    let scrollParams = calculateScrollParameters();\n    \n    if (process.env.NODE_ENV === 'development') {\n      console.log('🎠 Carousel animation started - Card width:', scrollParams.cardWidth, 'px');\n    }\n\n    const animate = () => {\n      // Get current values using refs\n      const currentWinner = getContractWinner();\n      const isWaiting = getWaitingForWinner();\n      const timeLeft = getTimeRemaining();\n      \n      // PHASE 1: Normal scrolling or waiting phase\n      if (!currentWinner) {\n        if (isWaiting && timeLeft === 0) {\n          // Fast spin while waiting for winner announcement\n          if (animationPhase !== 'fast-spin') {\n            animationPhase = 'fast-spin';\n          }\n          \n          currentPosition += 12; // Fast spin\n          if (currentPosition >= scrollParams.resetTriggerPoint) {\n            currentPosition = scrollParams.resetToPosition;\n          }\n          \n          carousel.style.transform = `translateX(-${currentPosition}px)`;\n          animationId = requestAnimationFrame(animate);\n          return;\n        } else {\n          // Normal carousel movement when not waiting\n          if (animationPhase !== 'normal') {\n            animationPhase = 'normal';\n          }\n          \n          currentPosition += 2;\n          if (currentPosition >= scrollParams.resetTriggerPoint) {\n            currentPosition = scrollParams.resetToPosition;\n          }\n          \n          carousel.style.transform = `translateX(-${currentPosition}px)`;\n          animationId = requestAnimationFrame(animate);\n          return;\n        }\n      }\n      \n      // Transition to slow-reveal when winner detected\n      if (currentWinner && animationPhase !== 'slow-reveal') {\n        if (process.env.NODE_ENV === 'development') {\n          console.log('🔄 Winner detected, calculating position...');\n        }\n      }\n      \n      // PHASE 2: When winner is announced, calculate precise target position\n      if (currentWinner && animationPhase !== 'slow-reveal' && targetPosition === null) {\n        // CRITICAL: Recalculate scroll parameters for current viewport before positioning\n        scrollParams = calculateScrollParameters();\n        \n        animationPhase = 'slow-reveal';\n        \n        // Get current bettors for animation (must match carousel rendering exactly)\n        const currentBettors = getCurrentBettors();\n        const prevBettors = getPreviousBettors();\n        const showWinnerVisuallyNow = getShowWinnerVisually();\n        \n        // ENHANCED DEBUG: Track data states\n        console.log('🎯 WINNER DETECTION - DATA STATES:');\n        console.log('  - currentBettors:', currentBettors.length, currentBettors);\n        console.log('  - prevBettors:', prevBettors.length, prevBettors);\n        console.log('  - showWinnerVisually:', showWinnerVisuallyNow);\n        console.log('  - contractWinner:', currentWinner);\n        \n        // FIXED: When winner is announced, current bettors are often reset/cleared\n        // So we should prioritize previousRoundBettors which contains the actual winner data\n        const bettorsToShow = (currentWinner || isWaiting) ? \n                             prevBettors.length > 0 ? prevBettors : currentBettors :\n                             currentBettors.length > 0 ? currentBettors : [];\n        \n        console.log('🎯 BETTOR DATA DEBUG:');\n        console.log('  - Decision logic: winner announced OR waiting =', (currentWinner || isWaiting));\n        console.log('  - Using bettorsToShow:', bettorsToShow.length, bettorsToShow);\n        \n        // Ensure we have at least 6 items (same as carousel rendering)\n        const allItems = [\n          ...bettorsToShow,\n          ...Array.from({ length: Math.max(0, 6 - bettorsToShow.length) }, () => null)\n        ];\n        \n        // Create infinite items EXACTLY like the carousel does\n        const infiniteItems = [...allItems, ...allItems, ...allItems];\n        \n        console.log('🎯 DEBUG CAROUSEL STRUCTURE:');\n        console.log('  - bettorsToShow:', bettorsToShow.length);\n        console.log('  - allItems:', allItems.length);\n        console.log('  - infiniteItems:', infiniteItems.length);\n        console.log('  - currentPosition:', currentPosition);\n        console.log('  - cardWidth:', scrollParams.cardWidth);\n        \n        // Find winner in the INFINITE items array (this is what's actually rendered)\n        let winnerIndex = -1;\n        \n        console.log('🎯 WINNER SEARCH RESULTS:');\n        console.log('  - Looking for winner:', {\n          winner: currentWinner.winner,\n          fullAddress: currentWinner.fullAddress,\n          address: currentWinner.address,\n          username: currentWinner.username,\n          displayName: currentWinner.displayName\n        });\n        console.log('  - Available infiniteItems:', infiniteItems.map((item, i) => ({ \n          index: i, \n          address: item?.address, \n          username: item?.username,\n          displayName: item?.displayName,\n          amount: item?.amount\n        })));\n        \n        // ENHANCED WINNER MATCHING - Try more combinations\n        for (let i = 0; i < infiniteItems.length; i++) {\n          const bettor = infiniteItems[i];\n          if (!bettor) continue;\n          \n          console.log(`🔍 Checking item ${i}:`, {\n            bettor_address: bettor.address,\n            bettor_username: bettor.username,\n            bettor_displayName: bettor.displayName,\n            winner_winner: currentWinner.winner,\n            winner_fullAddress: currentWinner.fullAddress,\n            winner_address: currentWinner.address,\n            winner_username: currentWinner.username,\n            winner_displayName: currentWinner.displayName\n          });\n          \n          const isMatch = (\n            // Address matching\n            (bettor.address && currentWinner.winner && bettor.address === currentWinner.winner) ||\n            (bettor.address && currentWinner.fullAddress && bettor.address === currentWinner.fullAddress) ||\n            (bettor.address && currentWinner.address && bettor.address === currentWinner.address) ||\n            // Username matching\n            (bettor.username && currentWinner.username && bettor.username === currentWinner.username) ||\n            (bettor.username && currentWinner.displayName && bettor.username === currentWinner.displayName) ||\n            (bettor.displayName && currentWinner.username && bettor.displayName === currentWinner.username) ||\n            (bettor.displayName && currentWinner.displayName && bettor.displayName === currentWinner.displayName)\n          );\n          \n          if (isMatch) {\n            winnerIndex = i;\n            console.log('🎯 WINNER FOUND at infiniteItems index:', winnerIndex, 'bettor:', bettor);\n            console.log('🎯 Match reason:', {\n              addressMatch: bettor.address === currentWinner.winner || bettor.address === currentWinner.fullAddress,\n              usernameMatch: bettor.username === currentWinner.username || bettor.displayName === currentWinner.username\n            });\n            break;\n          }\n        }\n        \n        console.log('  - Winner found at index:', winnerIndex);\n        \n        if (winnerIndex === -1) {\n          console.log('⚠️ Winner not found in infiniteItems, using enhanced fallback positioning');\n          \n          // ENHANCED FALLBACK: Create proper winner data and inject it\n          const winnerData = {\n            address: currentWinner.winner || currentWinner.fullAddress || currentWinner.address || 'unknown',\n            username: currentWinner.username || currentWinner.displayName || 'Winner',\n            displayName: currentWinner.displayName || currentWinner.username || 'Winner',\n            amount: currentWinner.prize || currentWinner.amount || 0,\n            isWinner: true,\n            injected: true // Flag to indicate this was injected\n          };\n          \n          // Find the best position to inject the winner\n          const firstEmptyIndex = allItems.findIndex(item => item === null);\n          let injectionIndex = firstEmptyIndex !== -1 ? firstEmptyIndex : 0;\n          \n          // If no empty slots, replace the first non-null item\n          if (firstEmptyIndex === -1 && allItems.length > 0) {\n            injectionIndex = 0;\n            console.log('🔄 No empty slots found, replacing first item at index 0');\n          }\n          \n          // Update all three sets in infiniteItems with winner data\n          infiniteItems[injectionIndex] = { ...winnerData };\n          infiniteItems[injectionIndex + allItems.length] = { ...winnerData };\n          infiniteItems[injectionIndex + (allItems.length * 2)] = { ...winnerData };\n          \n          winnerIndex = injectionIndex;\n          \n          console.log('✅ Enhanced fallback - Injected winner data:');\n          console.log('  - Position:', winnerIndex);\n          console.log('  - Winner data:', winnerData);\n          console.log('  - Injection reason:', firstEmptyIndex !== -1 ? 'Empty slot available' : 'Replaced existing item');\n        }\n        \n        if (winnerIndex !== -1) {\n          // DEBUGGING: Check current DOM state\n          const carousel = document.querySelector('.carousel-track');\n          const targetArrow = document.querySelector('.carousel-target-arrow');\n          const carouselContainer = document.querySelector('.players-carousel');\n          \n          if (carousel && targetArrow && carouselContainer) {\n            const carouselRect = carousel.getBoundingClientRect();\n            const arrowRect = targetArrow.getBoundingClientRect();\n            const containerRect = carouselContainer.getBoundingClientRect();\n            \n            console.log('🎯 DOM DEBUG:');\n            console.log('  - Carousel rect:', carouselRect);\n            console.log('  - Arrow rect:', arrowRect);\n            console.log('  - Container rect:', containerRect);\n            console.log('  - Current transform:', carousel.style.transform);\n          }\n          \n          // Calculate arrow center position relative to the track\n          let arrowCenterOffset = 200; // Default fallback\n          \n          if (targetArrow && carouselContainer) {\n            const containerRect = carouselContainer.getBoundingClientRect();\n            const arrowRect = targetArrow.getBoundingClientRect();\n            \n            // Arrow center relative to container\n            const arrowCenterInContainer = arrowRect.left - containerRect.left + (arrowRect.width / 2);\n            // Track padding shifts everything right by 12px\n            arrowCenterOffset = arrowCenterInContainer - 12;\n            \n            // LANDSCAPE MODE FIX: Adjust for different card sizes in landscape\n            const isLandscape = window.innerWidth > window.innerHeight;\n            const isInTelegram = window.Telegram?.WebApp;\n            \n            if (isLandscape) {\n              // Landscape mode requires significant positioning adjustment\n              // The card width calculation and actual rendering differ significantly in landscape\n              const landscapeOffset = containerRect.width * 0.15; // Adjust based on container width\n              arrowCenterOffset -= landscapeOffset;\n              console.log('🎯 LANDSCAPE ADJUSTMENT: Applied dynamic offset of', landscapeOffset, 'px for landscape mode');\n              console.log('   Container width:', containerRect.width, 'px');\n            }\n            \n            if (isInTelegram) {\n              // Telegram has slightly different layout - fine-tune based on testing\n              const telegramAdjustment = isLandscape ? 40 : 40; // Consistent adjustment for both orientations\n              arrowCenterOffset -= telegramAdjustment;\n              console.log(`🎯 TELEGRAM ADJUSTMENT: Applied -${telegramAdjustment}px offset for Telegram WebApp in ${isLandscape ? 'landscape' : 'portrait'}`);\n            }\n            \n            console.log('🎯 ENHANCED ARROW POSITIONING:');\n            console.log('  - Container rect:', containerRect);\n            console.log('  - Arrow rect:', arrowRect);\n            console.log('  - Arrow center in container:', arrowCenterInContainer);\n            console.log('  - Raw arrow center offset:', arrowCenterInContainer - 12);\n            console.log('  - Landscape mode:', isLandscape);\n            console.log('  - Final arrow center offset (with all adjustments):', arrowCenterOffset);\n            console.log('  - Environment:', isInTelegram ? 'Telegram WebApp' : 'Web Browser');\n          }\n          \n          // FIXED: Calculate the correct target position in the infinite scroll\n          // We want the winner to appear under the arrow, regardless of where it was found\n          \n          // Find which \"set\" of the infinite scroll we should target\n          // We want to go through at least one full cycle for drama, then land on winner\n          const singleSetLength = allItems.length;\n          const currentPositionInCards = currentPosition / scrollParams.cardWidth;\n          \n          // Calculate which set we should target (aim for 2nd or 3rd set for drama)\n          let targetSetIndex = 1; // Default to second set\n          if (currentPositionInCards < singleSetLength) {\n            targetSetIndex = 1; // We're in first set, go to second\n          } else if (currentPositionInCards < singleSetLength * 2) {\n            targetSetIndex = 2; // We're in second set, go to third\n          } else {\n            targetSetIndex = 2; // We're in third set, stay in third or go to second\n          }\n          \n          // The actual index in infiniteItems where we want the winner to appear\n          const targetWinnerIndex = (targetSetIndex * singleSetLength) + (winnerIndex % singleSetLength);\n          \n          console.log('🎯 TARGET CALCULATION:');\n          console.log('  - Single set length:', singleSetLength);\n          console.log('  - Current position in cards:', currentPositionInCards);\n          console.log('  - Target set index:', targetSetIndex);\n          console.log('  - Original winner index:', winnerIndex);\n          console.log('  - Target winner index in infinite array:', targetWinnerIndex);\n          \n          // Calculate the position where the winner should appear\n          const winnerCardPosition = targetWinnerIndex * scrollParams.cardWidth;\n          \n          // ENHANCED LANDSCAPE FIX: The arrow target should account for actual card center\n          const cardCenterOffset = scrollParams.cardWidth / 2;\n          const targetPositionForWinnerCenter = winnerCardPosition + cardCenterOffset - arrowCenterOffset;\n          \n          // Add extra adjustment for landscape mode specifically\n          let finalTargetPosition = targetPositionForWinnerCenter;\n          if (window.innerWidth > window.innerHeight) {\n            // In landscape, we need additional adjustment because cards are smaller\n            const landscapeFineAdjustment = scrollParams.cardWidth * 0.3; // 30% of card width adjustment\n            finalTargetPosition += landscapeFineAdjustment;\n            console.log('🎯 LANDSCAPE FINE ADJUSTMENT: Added', landscapeFineAdjustment, 'px for card centering');\n          }\n          \n          targetPosition = finalTargetPosition;\n          \n          console.log('🎯 FINAL CALCULATION:');\n          console.log('  - Target winner index in infiniteItems:', targetWinnerIndex);\n          console.log('  - Card width:', scrollParams.cardWidth);\n          console.log('  - Target winner card left edge:', winnerCardPosition);\n          console.log('  - Target winner card center:', winnerCardPosition + cardCenterOffset);\n          console.log('  - Arrow center offset:', arrowCenterOffset);\n          console.log('  - Base target position:', targetPositionForWinnerCenter);\n          console.log('  - Final target position (with landscape adj):', finalTargetPosition);\n          console.log('  - Current position:', currentPosition);\n          console.log('  - Movement needed:', finalTargetPosition - currentPosition);\n          \n          // Additional debugging for card alignment\n          console.log('🎯 ALIGNMENT DEBUG:');\n          console.log('  - When animation ends, card center should be at pixel:', winnerCardPosition + cardCenterOffset);\n          console.log('  - Arrow is expecting content at pixel:', arrowCenterOffset);\n          console.log('  - Difference (should be ~0 after positioning):', (winnerCardPosition + cardCenterOffset) - arrowCenterOffset);\n        }\n      }\n      \n      // PHASE 3: Execute dramatic slowdown to winner position\n      if (currentWinner && animationPhase === 'slow-reveal' && targetPosition !== null && !winnerPositionFound) {\n        // Calculate distance to target\n        const distanceToTarget = Math.abs(targetPosition - currentPosition);\n        let speed;\n        \n        // DEBUG: Log progress every 60 frames (about once per second)\n        if (Math.floor(currentPosition) % 60 === 0) {\n          console.log(` Animation progress: Current: ${currentPosition.toFixed(1)}, Target: ${targetPosition.toFixed(1)}, Distance: ${distanceToTarget.toFixed(1)}`);\n        }\n        \n        // OPTIMIZED: Update arrow visual state with cached element\n        if (!cachedTargetArrow) {\n          cachedTargetArrow = document.querySelector('.carousel-target-arrow');\n        }\n        if (cachedTargetArrow) {\n          if (distanceToTarget < 200) {\n            cachedTargetArrow.classList.add('winner-approaching');\n          } else {\n            cachedTargetArrow.classList.remove('winner-approaching');\n          }\n        }\n        \n        // ENHANCED SUSPENSE ALGORITHM: Go through one cycle then dramatic slowdown\n        if (distanceToTarget > 800) {\n          speed = 20; // Very fast for going through the cycle\n        } else if (distanceToTarget > 600) {\n          speed = 15; // Fast approach during cycle\n        } else if (distanceToTarget > 400) {\n          speed = 12; // Medium speed during cycle\n        } else if (distanceToTarget > 300) {\n          speed = 8; // Starting to slow down as we approach final position\n        } else if (distanceToTarget > 200) {\n          speed = 5; // Noticeable slowdown\n        } else if (distanceToTarget > 100) {\n          speed = 2.5; // Slowing down dramatically...\n        } else if (distanceToTarget > 50) {\n          speed = 1.2; // Very slow...\n        } else if (distanceToTarget > 25) {\n          speed = 0.6; // Crawling...\n        } else if (distanceToTarget > 10) {\n          speed = 0.2; // Almost stopping...\n        } else {\n          speed = 0.05; // Final crawl to target\n        }\n        \n        // Move towards target with calculated speed\n        if (currentPosition < targetPosition) {\n          currentPosition += speed;\n          if (currentPosition >= targetPosition) {\n            currentPosition = targetPosition;\n            winnerPositionFound = true;\n          }\n        } else if (currentPosition > targetPosition) {\n          currentPosition -= speed;\n          if (currentPosition <= targetPosition) {\n            currentPosition = targetPosition;\n            winnerPositionFound = true;\n          }\n        } else {\n          winnerPositionFound = true;\n        }\n        \n        // Check if we've reached the target\n        if (winnerPositionFound) {\n          // OPTIMIZED: Use cached element\n          if (cachedTargetArrow) {\n            cachedTargetArrow.classList.remove('winner-approaching');\n            cachedTargetArrow.classList.add('winner-landed');\n          }\n          \n          // OPTIMIZED: Reduced logging\n          if (process.env.NODE_ENV === 'development') {\n            console.log('🎯 Animation complete! Winner landed at position:', currentPosition);\n          }\n          \n          // NOW reveal the winner visually (CSS animation disabled to keep position)\n          setShowWinnerVisually(true);\n          \n          // VERIFICATION: Check if winner actually landed under arrow\n          setTimeout(() => {\n            const targetArrow = document.querySelector('.carousel-target-arrow');\n            const winnerCard = document.querySelector('.carousel-card.winner');\n            if (targetArrow && winnerCard) {\n              const arrowRect = targetArrow.getBoundingClientRect();\n              const cardRect = winnerCard.getBoundingClientRect();\n              const arrowCenter = arrowRect.left + (arrowRect.width / 2);\n              const cardCenter = cardRect.left + (cardRect.width / 2);\n              const difference = Math.abs(arrowCenter - cardCenter);\n              \n              console.log('🎯 WINNER LANDING VERIFICATION:');\n              console.log('  - Arrow center screen position:', arrowCenter, 'px');\n              console.log('  - Winner card center screen position:', cardCenter, 'px');\n              console.log('  - Alignment difference:', difference, 'px');\n              console.log('  - Success?', difference < 20 ? '✅ YES' : '❌ NO');\n              \n              if (difference >= 20) {\n                console.log('❌ POSITIONING FAILED! Winner did not land under arrow');\n                console.log('   Consider adjusting calculation...');\n              }\n            } else {\n              console.log('⚠️ Could not find arrow or winner card for verification');\n            }\n          }, 100);\n          \n          animationPhase = 'winner-paused';\n          // Pause animation briefly to show winner\n          carousel.style.transform = `translateX(-${currentPosition}px)`;\n          animationId = requestAnimationFrame(animate);\n          return;\n        }\n        \n        carousel.style.transform = `translateX(-${currentPosition}px)`;\n        animationId = requestAnimationFrame(animate);\n        return;\n      }\n      \n      // PHASE 4: Winner paused (showing winner for a moment)\n      if (animationPhase === 'winner-paused') {\n        // Just wait - timer will change phase to 'winner-displayed'\n        animationId = requestAnimationFrame(animate);\n        return;\n      }\n      \n      // PHASE 5: Winner displayed, resume normal animation (but keep winner highlighted)\n      if (animationPhase === 'winner-displayed') {\n        // Resume normal carousel movement while keeping winner visually highlighted\n        // This shows the updated jackpot total while winner stays green until new round\n        currentPosition += 2; // Normal speed\n        if (currentPosition >= scrollParams.resetTriggerPoint) {\n          currentPosition = scrollParams.resetToPosition;\n        }\n        \n        carousel.style.transform = `translateX(-${currentPosition}px)`;\n        animationId = requestAnimationFrame(animate);\n        return;\n      }\n\n      // If we reach here, something unexpected happened - continue animation\n      animationId = requestAnimationFrame(animate);\n    };\n\n    // Start animation\n    animationId = requestAnimationFrame(animate);\n\n    // Reset animation when new round starts\n    const resetAnimation = () => {\n      // OPTIMIZED: Reduced logging\n      if (process.env.NODE_ENV === 'development') {\n        console.log('🔄 Resetting animation for new round');\n      }\n      \n      animationPhase = 'normal';\n      winnerPositionFound = false;\n      winnerCardVisible = false;\n      targetPosition = null;\n      cachedTargetArrow = null; // Clear cache\n      setShowWinnerVisually(false); // Hide winner visually for new round\n      \n      // OPTIMIZED: Use cached element or skip if not available\n      if (cachedTargetArrow) {\n        cachedTargetArrow.classList.remove('winner-approaching', 'winner-landed');\n      }\n      \n      // OPTIMIZED: Simple position reset for Telegram - respects infinite scroll\n      if (window.Telegram?.WebApp) {\n        // Recalculate scroll parameters for potential viewport changes\n        scrollParams = calculateScrollParameters();\n        currentPosition = scrollParams.resetToPosition; // Reset to middle set position\n        if (carousel) {\n          carousel.style.transform = `translateX(-${scrollParams.resetToPosition}px)`;\n        }\n      }\n      \n      // Restart animation\n      if (animationId) {\n        cancelAnimationFrame(animationId);\n      }\n      animationId = requestAnimationFrame(animate);\n    };\n    \n    // Expose reset function for external use - Enhanced for Telegram\n    window.resetCarouselAnimation = resetAnimation;\n    \n    // OPTIMIZED: Minimal Telegram event listeners with throttling\n    if (window.Telegram?.WebApp) {\n      let throttleTimeout = null;\n      \n      // Throttled viewport change handler\n      const handleTelegramViewportChange = () => {\n        if (throttleTimeout) return; // Throttle to prevent spam\n        throttleTimeout = setTimeout(() => {\n          throttleTimeout = null;\n          \n          // CRITICAL: Recalculate scroll parameters for new viewport\n          const oldCardWidth = scrollParams.cardWidth;\n          scrollParams = calculateScrollParameters();\n          \n          console.log('📱 TELEGRAM VIEWPORT CHANGE:');\n          console.log('  - Old card width:', oldCardWidth, 'px');\n          console.log('  - New card width:', scrollParams.cardWidth, 'px');\n          \n          // Only reset if card width actually changed\n          if (Math.abs(oldCardWidth - scrollParams.cardWidth) > 5) {\n            console.log('🔄 Card width changed significantly - resetting animation');\n            if (window.resetCarouselAnimation && animationPhase === 'normal') {\n              window.resetCarouselAnimation();\n            }\n          }\n        }, 300); // Increased delay to reduce CPU usage\n      };\n      \n      // Listen for Telegram WebApp events (only essential ones)\n      if (window.Telegram.WebApp.onEvent) {\n        window.Telegram.WebApp.onEvent('viewportChanged', handleTelegramViewportChange);\n      }\n    }\n\n    return () => {\n      if (animationId) {\n        cancelAnimationFrame(animationId);\n      }\n      // Restore CSS transition\n      if (carousel) {\n        carousel.style.transition = '';\n      }\n      // Clean up global reference\n      delete window.resetCarouselAnimation;\n      \n      // Clean up Telegram-specific event listeners\n      if (window.Telegram?.WebApp) {\n        console.log('🎯 Cleaning up Telegram WebApp event listeners');\n        // Remove Telegram WebApp event listeners\n        if (window.Telegram.WebApp.offEvent) {\n          window.Telegram.WebApp.offEvent('viewportChanged');\n        }\n      }\n    };\n  }, []); // EMPTY dependency array to prevent re-initialization\n\n  // Socket integration for immediate synchronization - SINGLE CONNECTION POINT\n  useEffect(() => {\n    console.log('🔌 App.js: Establishing single socket connection for entire app...');\n    socketService.connect();\n\n    // Listen for timer updates from socket\n    socketService.on('timer', (timerData) => {\n      console.log('⏰ App: Socket timer update:', timerData);\n      \n      // SAFETY: Ensure timerData exists and has required properties\n      if (!timerData || typeof timerData !== 'object') {\n        console.warn('⚠️ Invalid timer data received in App:', timerData);\n        return;\n      }\n      \n      const newTimeRemaining = typeof timerData.timeRemaining === 'number' ? timerData.timeRemaining : timeRemaining;\n      const newRoundNumber = typeof timerData.roundNumber === 'number' ? timerData.roundNumber : currentRound;\n      \n      // Only update timeRemaining if it's significantly different (>2 seconds) or new round\n      setTimeRemaining(prev => {\n        const timeDiff = Math.abs(prev - newTimeRemaining);\n        const isNewRound = newRoundNumber !== currentRound;\n        \n        // Only clear winner state when new round detected AND timer is significantly higher (real new round)\n        if (isNewRound && contractWinner && newTimeRemaining > 200) {\n          console.log('🔄 Timer update detected REAL new round with fresh timer - clearing winner state');\n          console.log('🔓 Exiting winner state - new round detected');\n          setIsInWinnerState(false);\n          setContractWinner(null);\n          setShowWinnerAnnouncement(false);\n          setShowWinnerVisually(false);\n          setPostWinnerLoading(false);\n          setIsAnyWinnerDisplayActive(false);\n          setPreviousRoundBettors([]);\n        }\n        \n        // Sync if: new round, big difference (>10s), or timer reset (server > client)\n        if (isNewRound || timeDiff > 10 || newTimeRemaining > prev) {\n          console.log('⏰ Syncing timer:', prev, '→', newTimeRemaining, isNewRound ? '(new round)' : timeDiff > 10 ? '(>10s difference)' : '(backend ahead)');\n          return newTimeRemaining;\n        }\n        \n        // Otherwise keep local countdown running smoothly\n        return prev;\n      });\n      \n      if (newRoundNumber && newRoundNumber !== currentRound) {\n        setCurrentRound(newRoundNumber);\n      }\n      // Note: Contract state timer will be updated via fullGameUpdate/contractStateUpdate events\n    });\n\n    // Listen for new round events\n    socketService.on('newRound', (roundData) => {\n      console.log('🎰 App: New round detected via socket:', roundData);\n      console.log('🔓 Exiting winner state - new round started');\n      \n      setTimeRemaining(roundData.timeRemaining);\n      setCurrentRound(roundData.roundNumber);\n      setIsInWinnerState(false);\n      setIsAnyWinnerDisplayActive(false);\n      winnerCoordinator.reset();\n      lastWinnerTimestampRef.current = null; // Clear duplicate protection for new round\n      \n      // Clear ALL winner highlighting for new round\n      setContractWinner(null);\n      setShowWinnerAnnouncement(false);\n      setShowWinnerVisually(false);\n      setPreviousRoundBettors([]);\n      setWaitingForWinner(false);\n      setPostWinnerLoading(false);\n      \n      // OPTIMIZED: Simple animation reset\n      if (window.resetCarouselAnimation) {\n        window.resetCarouselAnimation();\n      }\n    });\n\n    // Listen for game state updates\n    socketService.on('gameState', (gameState) => {\n      console.log('🎮 App: Game state update:', gameState);\n      \n      // Priority: Use timer.timeRemaining ONLY (as user specified)\n      const backendTimeRemaining = gameState.timer?.timeRemaining;\n      \n      if (backendTimeRemaining !== undefined) {\n        setTimeRemaining(prev => {\n          const timeDiff = Math.abs(prev - backendTimeRemaining);\n          \n          // Only sync if there's a significant difference (>10s) or if backend is ahead\n          if (timeDiff > 10 || backendTimeRemaining > prev) {\n            console.log('⏰ GameState syncing timer:', prev, '→', backendTimeRemaining, timeDiff > 10 ? '(>10s difference)' : '(backend ahead)');\n            return backendTimeRemaining;\n          }\n          \n          // Keep local countdown running if difference is small\n          console.log('⏰ GameState keeping local timer:', prev, 'vs backend:', backendTimeRemaining);\n          return prev;\n        });\n      }\n      if (gameState.currentRound) {\n        // Extract roundNumber if currentRound is an object, otherwise use the value directly\n        const roundNumber = typeof gameState.currentRound === 'object' && gameState.currentRound.roundNumber \n          ? gameState.currentRound.roundNumber \n          : gameState.currentRound;\n        \n        // Check if this is a new round with active timer - this means new round started\n        const isNewRound = roundNumber !== currentRound;\n        const hasActiveTimer = gameState.timer?.isActive || gameState.timer?.timeRemaining > 60;\n        \n        if (isNewRound && hasActiveTimer && isInWinnerStateRef.current) {\n          console.log('🔄 GameState detected NEW ROUND with active timer - clearing winner state');\n          console.log('🔓 Exiting winner state - new round started via gameState');\n          setIsInWinnerState(false);\n          setContractWinner(null);\n          setShowWinnerAnnouncement(false);\n          setShowWinnerVisually(false);\n          setPostWinnerLoading(false);\n          setIsAnyWinnerDisplayActive(false);\n          setPreviousRoundBettors([]);\n          winnerCoordinator.reset();\n        }\n        \n        setCurrentRound(roundNumber);\n      }\n      \n      // Handle winner-related states\n      if (gameState.isWaitingForWinner !== undefined) {\n        // If transitioning TO waiting for winner, store current bettors\n        if (gameState.isWaitingForWinner && !waitingForWinnerRef.current && gameBettorsRef.current.length > 0) {\n          console.log('🎮 App: Transitioning to waiting for winner, storing bettors:', gameBettorsRef.current);\n          setPreviousRoundBettors([...gameBettorsRef.current]);\n        }\n        \n        setWaitingForWinner(gameState.isWaitingForWinner);\n        \n        // If waitingForWinner becomes false AND we have a new round with active timer, reset winner state\n        if (!gameState.isWaitingForWinner && isInWinnerStateRef.current) {\n          const roundNumber = typeof gameState.currentRound === 'object' && gameState.currentRound.roundNumber \n            ? gameState.currentRound.roundNumber \n            : gameState.currentRound;\n          const isNewRound = roundNumber && roundNumber !== currentRound;\n          const hasActiveTimer = gameState.timer?.isActive || gameState.timer?.timeRemaining > 60;\n          \n          if (isNewRound && hasActiveTimer) {\n            console.log('🔄 waitingForWinner false + new round + active timer = new round started - clearing winner state');\n            console.log('🔓 Exiting winner state - new round confirmed');\n            setIsInWinnerState(false);\n            setContractWinner(null);\n            setShowWinnerAnnouncement(false);\n            setShowWinnerVisually(false);\n            setPostWinnerLoading(false);\n            setIsAnyWinnerDisplayActive(false);\n            setPreviousRoundBettors([]);\n            winnerCoordinator.reset();\n          } else {\n            console.log('⏳ waitingForWinner became false, but keeping winner state (no new round detected)');\n          }\n        }\n      }\n      \n      // Update bettors data centrally (avoids duplicate processing)\n      if (gameState.bettors && Array.isArray(gameState.bettors)) {\n        // Only log if bettors count changed to reduce spam\n        if (gameState.bettors.length !== gameBettorsRef.current.length) {\n          console.log('🎮 App: Updating bettors from gameState:', gameState.bettors.length, 'bettors');\n          // Trigger slot machine animation when new bettor joins\n          setSlotSpinning(true);\n          setTimeout(() => setSlotSpinning(false), 3000);\n        }\n        \n        // Store current bettors as previous round bettors when waiting for winner\n        if (gameState.isWaitingForWinner && gameState.bettors.length > 0) {\n          console.log('🎮 App: Storing bettors for winner matching:', gameState.bettors);\n          setPreviousRoundBettors([...gameState.bettors]);\n        }\n        \n        setGameBettors(gameState.bettors);\n      }\n      \n      // Check for winner announcement in game state (prevent duplicates with stronger protection)\n      if (gameState.winnerAnnouncement) {\n        showWinnerAnnouncements(gameState.winnerAnnouncement, 'gameState');\n      }\n    });\n\n    // Listen for comprehensive game data updates\n    socketService.on('fullGameUpdate', (gameData) => {\n      console.log('🎮 App: Full game update:', gameData);\n      // These updates will trigger re-renders via useJackpotContract hook\n      // The hook will detect the changes and update accordingly\n    });\n\n    // Listen for bettors updates\n    socketService.on('bettorsUpdate', (data) => {\n      console.log('💰 App: Bettors update:', data);\n      // Trigger slot machine animation on bettor updates\n      setSlotSpinning(true);\n      setTimeout(() => setSlotSpinning(false), 3000);\n      // Force a refresh of contract state to sync with socket data\n      // This ensures jackpot value and user stats stay in sync\n    });\n\n    // Listen for waiting for winner events\n    socketService.on('waitingForWinner', (data) => {\n      console.log('🎯 App: Waiting for winner state changed:', data);\n      \n      // Handle both old boolean format and new object format\n      const isWaiting = typeof data === 'boolean' ? data : data.isWaiting;\n      const message = typeof data === 'object' ? data.message : null;\n      \n      // Don't reset winner state just because waitingForWinner changed\n      // Only reset when we get explicit newRound/roundReset events\n      setWaitingForWinner(isWaiting);\n      \n      // Log but don't auto-reset winner state\n      if (!isWaiting && isInWinnerStateRef.current) {\n        console.log('⏳ waitingForWinner event became false, but keeping winner state until explicit new round');\n      }\n      \n      if (message) {\n        console.log('🎯 App: Winner selection message:', message);\n      }\n    });\n\n    // Listen for winner announcements (primary)\n    socketService.on('winner', (winnerData) => {\n      console.log('🏆 App: Winner announced:', winnerData);\n      console.log('🏆 App: Current gameBettors for comparison:', gameBettors);\n      console.log('🏆 App: Previous round bettors for comparison:', previousRoundBettors);\n      setWaitingForWinner(false);\n      setPostWinnerLoading(true);\n      \n      // Use centralized manager\n      showWinnerAnnouncements(winnerData, 'winner event');\n    });\n\n    // Listen for direct winner announcements (fallback/reliable delivery)\n    socketService.on('winnerAnnouncement', (winnerData) => {\n      console.log('🎯 App: Direct winner announcement:', winnerData);\n      setWaitingForWinner(false);\n      \n      // Use centralized manager\n      showWinnerAnnouncements(winnerData, 'direct announcement');\n    });\n\n    // Listen for round reset events (when timer is reset due to no bettors)\n    socketService.on('roundReset', (resetData) => {\n      console.log('🔄 App: Round reset detected:', resetData);\n      console.log('🔓 Exiting winner state - round reset');\n      \n      // Reset timer to the new duration\n      setTimeRemaining(resetData.timeRemaining);\n      setCurrentRound(resetData.roundNumber);\n      \n      // Clear ALL winner states since this is a fresh timer\n      setIsInWinnerState(false);\n      setWaitingForWinner(false);\n      setContractWinner(null);\n      setShowWinnerAnnouncement(false);\n      setShowWinnerVisually(false);\n      setPostWinnerLoading(false);\n      setIsAnyWinnerDisplayActive(false);\n      winnerCoordinator.reset();\n      \n      // Clear bettors list since round was reset\n      setGameBettors([]);\n      setPreviousRoundBettors([]);\n      \n      // OPTIMIZED: Simple animation reset\n      if (window.resetCarouselAnimation) {\n        window.resetCarouselAnimation();\n      }\n    });\n\n    return () => {\n      console.log('🔌 App.js: Cleaning up socket listeners...');\n      socketService.off('timer');\n      socketService.off('newRound');\n      socketService.off('roundReset');\n      socketService.off('gameState');\n      socketService.off('fullGameUpdate');\n      socketService.off('bettorsUpdate');\n      socketService.off('waitingForWinner');\n      socketService.off('winner');\n      socketService.off('winnerAnnouncement');\n      // Disconnect when app unmounts to prevent memory leaks\n      socketService.disconnect();\n    };\n  }, [currentRound, showWinnerAnnouncements]); // Added missing dependencies\n\n  const handleBetChange = (e) => {\n    const inputValue = e.target.value;\n    \n    // Allow empty input or numbers with decimal points (both . and ,)\n    if (inputValue === '' || inputValue === '.' || inputValue === ',' || /^\\d*[.,]?\\d*$/.test(inputValue)) {\n      // Convert comma to period for consistency\n      const normalizedValue = inputValue.replace(',', '.');\n      \n      // For empty or just \".\" input, keep the raw value but show comma if user typed comma\n      if (normalizedValue === '' || normalizedValue === '.') {\n        setBetAmount(inputValue); // Keep original input (might be comma)\n        return;\n      }\n      \n      // For valid numbers, check limits but preserve decimal typing\n      const numericValue = parseFloat(normalizedValue);\n      if (!isNaN(numericValue) && numericValue <= 10) {\n        setBetAmount(inputValue); // Keep the original input format (comma or period)\n      }\n    }\n  };\n\n  const handleTabChange = (tab) => {\n    hapticFeedback('light');\n    setActiveTab(tab);\n  };\n\n  // Enhanced bet placement with real smart contract\n  const handlePlaceBet = async () => {\n    // Prevent betting during winner display period\n    if (contractWinner || showWinnerAnnouncement) {\n      showAlert('⏳ Please wait for the new round to start before placing a bet!');\n      return;\n    }\n\n    if (!isConnected) {\n      showAlert('Please connect your wallet first!');\n      return;\n    }\n\n    // Convert comma to period before parsing for validation\n    const normalizedBetAmount = betAmount.toString().replace(',', '.');\n    const numericBetAmount = parseFloat(normalizedBetAmount);\n    \n    if (isNaN(numericBetAmount) || numericBetAmount <= 0) {\n      showAlert('Please enter a valid bet amount!');\n      return;\n    }\n\n    try {\n      hapticFeedback('medium');\n      await placeBet(numericBetAmount);\n      \n      // Reset bet amount after successful bet\n      setBetAmount(0.11);\n      \n      hapticFeedback('success');\n      showAlert(`✅ Bet of ${numericBetAmount.toFixed(3)} TON placed successfully!`);\n    } catch (error) {\n      console.error('Failed to place bet:', error);\n      hapticFeedback('error');\n      showAlert(`❌ Failed to place bet: ${error.message}`);\n    }\n  };\n\n  return (\n    <div className=\"app\">\n        <div className=\"app-container\">\n          {/* Header Section */}\n          <div className=\"header-section\">\n            <div className=\"header-top\">\n              <div className=\"logo-section\">\n                <div className=\"logo-icon\">🎰</div>\n                <div className=\"app-name\">SlotPot</div>\n              </div>\n              \n              <div className=\"balance-section\">\n                <div className=\"balance-label\">Balance</div>\n                <div className=\"balance-amount\">\n                  {isConnected ? `${(contractState.userBalance || 0).toFixed(6)}` : '0.000000'}\n                  <span className=\"balance-symbol\">TON</span>\n                </div>\n              </div>\n              \n              <div className=\"header-icons\">\n                <WalletConnection />\n              </div>\n            </div>\n          </div>\n          \n          {/* Main Content */}\n          <div className=\"main-content\">\n            {/* Jackpot Display */}\n            <div className=\"jackpot-header\">\n              <div className=\"jackpot-title\">💰 JACKPOT</div>\n              <div className=\"jackpot-value-display\">{jackpotValue.toFixed(3)}</div>\n              <div className=\"jackpot-subtitle\">Winner takes all...</div>\n            </div>\n\n            {/* Betting Section */}\n            <div className=\"betting-section\">\n              <div className=\"bet-input-section\">\n                <input \n                  type=\"text\" \n                  className=\"bet-amount-input\" \n                  value={betAmount}\n                  onChange={handleBetChange}\n                  placeholder=\"0.000\"\n                  inputMode=\"decimal\"\n                />\n                <button className=\"bet-increment-btn\" onClick={() => setBetAmount(prev => {\n                  const currentValue = parseFloat(prev) || 0;\n                  return Math.min(currentValue + 0.1, 10).toFixed(1);\n                })}>\n                  +0.1\n          </button>\n              </div>\n          <button \n                className=\"bet-button\" \n                onClick={handlePlaceBet}\n                disabled={isPlacingBet || !isConnected || contractWinner || showWinnerAnnouncement}\n          >\n                {contractWinner || showWinnerAnnouncement ? 'Winner Display - Wait for New Round' :\n                 isPlacingBet ? 'Betting...' : 'Bet'}\n          </button>\n        </div>\n\n            {/* Stats Grid */}\n            <div className=\"stats-grid\">\n              <div className=\"stat-card\">\n                <div className=\"stat-value\">{userBetTotal.toFixed(3)}</div>\n                <div className=\"stat-label\">Your Wager</div>\n              </div>\n              <div className=\"stat-card chance-stat\">\n                <div className=\"stat-value\">{userWinChance.toFixed(2)}%</div>\n                <div className=\"stat-label\">Your Chance</div>\n          </div>\n        </div>\n\n            {/* Time Section */}\n            <div className=\"time-section\">\n              <div className=\"time-label\">Time Remaining </div>\n              <div className=\"time-value\">\n                {Math.floor((timeRemaining || 0) / 60)}:{((timeRemaining || 0) % 60).toString().padStart(2, '0')}\n          </div>\n        </div>\n\n            {/* Players Carousel Section */}\n            <div className=\"players-carousel-section\">\n              <div className={`carousel-header ${\n                (timeRemaining === 0 && waitingForWinner) || (contractWinner && !showWinnerVisually) ? 'analyzing' : \n                showWinnerVisually ? 'winner' : ''\n              }`}>\n                <h3>\n                  {(timeRemaining === 0 && waitingForWinner) || (contractWinner && !showWinnerVisually) ? \n                    \"🔍 Analyzing Bets...\" : \n                    showWinnerVisually && contractWinner ? \n                    `🏆 Winner: ${contractWinner.username || contractWinner.displayName || contractWinner.winner || 'Player'}` :\n                    `Players (${gameBettors.length > 0 ? gameBettors.length : previousRoundBettors.length})`\n                  }\n                </h3>\n              </div>\n              \n              {/* NEW: Simple Swiper Carousel */}\n              <SimpleCarousel \n                players={(() => {\n                  // Same data logic as before\n                  const bettorsToShow = (contractWinner || waitingForWinner) ? \n                                       previousRoundBettors.length > 0 ? previousRoundBettors : gameBettors :\n                                       gameBettors.length > 0 ? gameBettors : [];\n                  \n                  // Ensure we have at least 6 items to show (fill with waiting slots if needed)\n                  return [\n                    ...bettorsToShow,\n                    ...Array.from({ length: Math.max(0, 6 - bettorsToShow.length) }, () => null)\n                  ];\n                })()}\n                winner={showWinnerVisually ? contractWinner : null}\n                isSpinning={(timeRemaining === 0 && waitingForWinner) || (contractWinner && !showWinnerVisually)}\n                onWinnerLand={() => {\n                  console.log('🎯 Winner landed in Swiper carousel!');\n                  // Winner is already set via showWinnerVisually\n                }}\n              />\n        </div>\n      </div>\n\n      {/* Mobile Footer */}\n      <div className=\"mobile-footer\">\n            <div className=\"footer-stats\">\n              <div className=\"footer-stat\">\n                <div className=\"footer-stat-icon\">🏠</div>\n                <div className=\"footer-stat-value\">Home</div>\n              </div>\n              <div className=\"footer-stat\">\n                <div className=\"footer-stat-icon\">⚡</div>\n                <div className=\"footer-stat-value\">Fast</div>\n            </div>\n              <div className=\"footer-stat\">\n                <div className=\"footer-stat-icon\">🕐</div>\n                <div className=\"footer-stat-value\">History</div>\n            </div>\n              <div className=\"footer-stat\">\n                <div className=\"footer-stat-icon\">🔍</div>\n                <div className=\"footer-stat-value\">Search</div>\n              </div>\n          </div>\n            <button className=\"games-button\">\n              <DollarSign size={14} />\n            Games\n          </button>\n        </div>\n      </div>\n\n      {/* Contract Status Indicator */}\n      {isLoadingContract && !contractWinner && !showWinnerAnnouncement && (\n        <div className=\"loading-overlay\">\n          <div className=\"loading-spinner\">🔄</div>\n          <span>Loading contract data...</span>\n        </div>\n      )}\n\n      {/* Winner Broadcast Component */}\n      <WinnerBroadcast socketService={socketService} />\n    </div>\n  );\n}\n\n// Main App component with TON Connect Provider\nfunction App() {\n  return (\n    <TonConnectUIProvider \n      manifestUrl={manifestUrl}\n      uiPreferences={uiOptions.uiPreferences}\n      language={uiOptions.language}\n      restoreConnection={uiOptions.restoreConnection}\n      actionsConfiguration={uiOptions.actionsConfiguration}\n    >\n      <AppContent />\n    </TonConnectUIProvider>\n  );\n}\n\nexport default App; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}