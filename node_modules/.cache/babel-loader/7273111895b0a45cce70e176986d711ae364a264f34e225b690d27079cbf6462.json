{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport socketService from '../services/socketService';\nimport apiService from '../services/apiService';\nimport useTelegramWebApp from './useTelegramWebApp';\nconst useChat = () => {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isTyping, setIsTyping] = useState(false);\n  const [typingUsers, setTypingUsers] = useState([]);\n  const [connectionError, setConnectionError] = useState(null);\n  const [serverStats, setServerStats] = useState({\n    connectedUsers: 0,\n    totalMessages: 0,\n    serverStatus: 'Unknown',\n    lastUpdated: null\n  });\n  const [isLoadingStats, setIsLoadingStats] = useState(false);\n  const {\n    user,\n    hasRealUserData\n  } = useTelegramWebApp();\n  const typingTimeoutRef = useRef(null);\n  const statsIntervalRef = useRef(null);\n\n  // Fetch server stats from API\n  const fetchServerStats = useCallback(async () => {\n    setIsLoadingStats(true);\n    try {\n      const stats = await apiService.getServerStats();\n      setServerStats(stats);\n\n      // If we have recent messages from API and no socket messages yet, load them\n      if (stats.recentMessages && stats.recentMessages.length > 0 && messages.length === 0) {\n        setMessages(stats.recentMessages);\n      }\n    } catch (error) {\n      console.error('Failed to fetch server stats:', error);\n      setServerStats(prev => ({\n        ...prev,\n        serverStatus: 'Error',\n        error: error.message\n      }));\n    } finally {\n      setIsLoadingStats(false);\n    }\n  }, [messages.length]);\n\n  // Initialize API data fetching\n  useEffect(() => {\n    // Fetch initial stats\n    fetchServerStats();\n\n    // Set up periodic stats updates every 30 seconds\n    statsIntervalRef.current = setInterval(fetchServerStats, 30000);\n    return () => {\n      if (statsIntervalRef.current) {\n        clearInterval(statsIntervalRef.current);\n      }\n    };\n  }, [fetchServerStats]);\n\n  // Initialize socket listeners (connection handled by App.js)\n  useEffect(() => {\n    console.log('ðŸ”Œ Setting up chat listeners...');\n\n    // Socket connection is handled by App.js - just set up listeners\n\n    // Subscribe to messages\n    socketService.on('chat:message', message => {\n      setMessages(prev => {\n        // Prevent duplicate messages\n        const exists = prev.some(msg => msg.id === message.id);\n        if (exists) return prev;\n        return [...prev, message].slice(-50); // Keep last 50 messages\n      });\n\n      // Update message count in stats\n      setServerStats(prev => ({\n        ...prev,\n        totalMessages: prev.totalMessages + 1,\n        lastUpdated: new Date()\n      }));\n    });\n\n    // Subscribe to connection status\n    socketService.on('connect', () => {\n      setIsConnected(true);\n      setConnectionError(null);\n\n      // Refresh stats when connected\n      fetchServerStats();\n      if (user) {\n        // Auto-join chat when connected\n        socketService.emit('user:join', {\n          username: user.displayName,\n          avatar: 'ðŸ‘¤',\n          isPremium: user.isPremium\n        });\n      }\n    });\n    socketService.on('disconnect', () => {\n      setIsConnected(false);\n    });\n    socketService.on('connect_error', error => {\n      setIsConnected(false);\n      setConnectionError(error || new Error('Connection failed'));\n    });\n\n    // Subscribe to typing indicators\n    socketService.on('user:typing', data => {\n      setTypingUsers(prev => {\n        if (data.isTyping) {\n          // Add user to typing list\n          if (!prev.includes(data.username)) {\n            return [...prev, data.username];\n          }\n          return prev;\n        } else {\n          // Remove user from typing list\n          return prev.filter(username => username !== data.username);\n        }\n      });\n\n      // Auto-remove typing indicator after 3 seconds\n      setTimeout(() => {\n        setTypingUsers(prev => prev.filter(username => username !== data.username));\n      }, 3000);\n    });\n\n    // Cleanup on unmount (don't disconnect - shared connection)\n    return () => {\n      socketService.off('chat:message');\n      socketService.off('connect');\n      socketService.off('disconnect');\n      socketService.off('connect_error');\n      socketService.off('user:typing');\n      // Don't disconnect here - App.js manages the connection\n    };\n  }, [user, fetchServerStats]);\n\n  // Send a message\n  const sendMessage = useCallback(messageText => {\n    if (!messageText.trim() || !isConnected) {\n      return false;\n    }\n    socketService.emit('chat:message', {\n      message: messageText\n    });\n\n    // Stop typing indicator\n    setIsTyping(false);\n    socketService.emit('user:typing', {\n      isTyping: false\n    });\n    return true;\n  }, [isConnected]);\n\n  // Handle typing indicators\n  const handleTyping = useCallback(typing => {\n    if (!isConnected) return;\n    setIsTyping(typing);\n    socketService.emit('user:typing', {\n      isTyping: typing\n    });\n\n    // Clear previous timeout\n    if (typingTimeoutRef.current) {\n      clearTimeout(typingTimeoutRef.current);\n    }\n\n    // Auto-stop typing after 3 seconds\n    if (typing) {\n      typingTimeoutRef.current = setTimeout(() => {\n        setIsTyping(false);\n        socketService.emit('user:typing', {\n          isTyping: false\n        });\n      }, 3000);\n    }\n  }, [isConnected]);\n\n  // Send bet notification to chat\n  const sendBetNotification = useCallback(amount => {\n    if (!isConnected) return;\n    socketService.emit('game:bet', {\n      amount\n    });\n  }, [isConnected]);\n\n  // Reconnect to server (handled by App.js)\n  const reconnect = useCallback(() => {\n    setConnectionError(null);\n    // App.js handles the actual reconnection\n    fetchServerStats(); // Just refresh API data\n  }, [fetchServerStats]);\n\n  // Refresh server stats manually\n  const refreshStats = useCallback(() => {\n    fetchServerStats();\n  }, [fetchServerStats]);\n\n  // Get chat statistics\n  const getChatStats = useCallback(() => {\n    return {\n      totalMessages: Math.max(messages.length, serverStats.totalMessages),\n      isConnected,\n      hasError: !!connectionError,\n      typingUsersCount: typingUsers.length,\n      connectedUsers: serverStats.connectedUsers,\n      serverStatus: serverStats.serverStatus,\n      lastUpdated: serverStats.lastUpdated,\n      isLoadingStats\n    };\n  }, [messages.length, isConnected, connectionError, typingUsers.length, serverStats, isLoadingStats]);\n\n  // Format message for display\n  const formatMessage = useCallback(message => {\n    return {\n      ...message,\n      timestamp: new Date(message.timestamp),\n      isOwnMessage: message.username === (user === null || user === void 0 ? void 0 : user.displayName),\n      formattedTime: new Date(message.timestamp).toLocaleTimeString('en-US', {\n        hour: '2-digit',\n        minute: '2-digit'\n      })\n    };\n  }, [user === null || user === void 0 ? void 0 : user.displayName]);\n  return {\n    // State\n    messages: messages.map(formatMessage),\n    isConnected,\n    isTyping,\n    typingUsers,\n    connectionError,\n    serverStats,\n    isLoadingStats,\n    // Actions\n    sendMessage,\n    handleTyping,\n    sendBetNotification,\n    reconnect,\n    refreshStats,\n    // Utils\n    getChatStats,\n    // Connection info\n    serverUrl: 'http://localhost:5002',\n    userInfo: {\n      username: (user === null || user === void 0 ? void 0 : user.displayName) || 'Anonymous',\n      isRealUser: hasRealUserData,\n      isPremium: (user === null || user === void 0 ? void 0 : user.isPremium) || false\n    }\n  };\n};\n_s(useChat, \"Ofd1Q8JVP6cuz6GCazbPpjaNoiQ=\", false, function () {\n  return [useTelegramWebApp];\n});\nexport default useChat;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","socketService","apiService","useTelegramWebApp","useChat","_s","messages","setMessages","isConnected","setIsConnected","isTyping","setIsTyping","typingUsers","setTypingUsers","connectionError","setConnectionError","serverStats","setServerStats","connectedUsers","totalMessages","serverStatus","lastUpdated","isLoadingStats","setIsLoadingStats","user","hasRealUserData","typingTimeoutRef","statsIntervalRef","fetchServerStats","stats","getServerStats","recentMessages","length","error","console","prev","message","current","setInterval","clearInterval","log","on","exists","some","msg","id","slice","Date","emit","username","displayName","avatar","isPremium","Error","data","includes","filter","setTimeout","off","sendMessage","messageText","trim","handleTyping","typing","clearTimeout","sendBetNotification","amount","reconnect","refreshStats","getChatStats","Math","max","hasError","typingUsersCount","formatMessage","timestamp","isOwnMessage","formattedTime","toLocaleTimeString","hour","minute","map","serverUrl","userInfo","isRealUser"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/src/hooks/useChat.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\r\nimport socketService from '../services/socketService';\r\nimport apiService from '../services/apiService';\r\nimport useTelegramWebApp from './useTelegramWebApp';\r\n\r\nconst useChat = () => {\r\n  const [messages, setMessages] = useState([]);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [isTyping, setIsTyping] = useState(false);\r\n  const [typingUsers, setTypingUsers] = useState([]);\r\n  const [connectionError, setConnectionError] = useState(null);\r\n  const [serverStats, setServerStats] = useState({\r\n    connectedUsers: 0,\r\n    totalMessages: 0,\r\n    serverStatus: 'Unknown',\r\n    lastUpdated: null\r\n  });\r\n  const [isLoadingStats, setIsLoadingStats] = useState(false);\r\n  \r\n  const { user, hasRealUserData } = useTelegramWebApp();\r\n  const typingTimeoutRef = useRef(null);\r\n  const statsIntervalRef = useRef(null);\r\n\r\n  // Fetch server stats from API\r\n  const fetchServerStats = useCallback(async () => {\r\n    setIsLoadingStats(true);\r\n    try {\r\n      const stats = await apiService.getServerStats();\r\n      setServerStats(stats);\r\n      \r\n      // If we have recent messages from API and no socket messages yet, load them\r\n      if (stats.recentMessages && stats.recentMessages.length > 0 && messages.length === 0) {\r\n        setMessages(stats.recentMessages);\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to fetch server stats:', error);\r\n      setServerStats(prev => ({\r\n        ...prev,\r\n        serverStatus: 'Error',\r\n        error: error.message\r\n      }));\r\n    } finally {\r\n      setIsLoadingStats(false);\r\n    }\r\n  }, [messages.length]);\r\n\r\n  // Initialize API data fetching\r\n  useEffect(() => {\r\n    // Fetch initial stats\r\n    fetchServerStats();\r\n\r\n    // Set up periodic stats updates every 30 seconds\r\n    statsIntervalRef.current = setInterval(fetchServerStats, 30000);\r\n\r\n    return () => {\r\n      if (statsIntervalRef.current) {\r\n        clearInterval(statsIntervalRef.current);\r\n      }\r\n    };\r\n  }, [fetchServerStats]);\r\n\r\n  // Initialize socket listeners (connection handled by App.js)\r\n  useEffect(() => {\r\n    console.log('ðŸ”Œ Setting up chat listeners...');\r\n    \r\n    // Socket connection is handled by App.js - just set up listeners\r\n\r\n    // Subscribe to messages\r\n    socketService.on('chat:message', (message) => {\r\n      setMessages(prev => {\r\n        // Prevent duplicate messages\r\n        const exists = prev.some(msg => msg.id === message.id);\r\n        if (exists) return prev;\r\n        \r\n        return [...prev, message].slice(-50); // Keep last 50 messages\r\n      });\r\n      \r\n      // Update message count in stats\r\n      setServerStats(prev => ({\r\n        ...prev,\r\n        totalMessages: prev.totalMessages + 1,\r\n        lastUpdated: new Date()\r\n      }));\r\n    });\r\n\r\n    // Subscribe to connection status\r\n    socketService.on('connect', () => {\r\n      setIsConnected(true);\r\n      setConnectionError(null);\r\n      \r\n      // Refresh stats when connected\r\n      fetchServerStats();\r\n      \r\n      if (user) {\r\n        // Auto-join chat when connected\r\n        socketService.emit('user:join', {\r\n          username: user.displayName,\r\n          avatar: 'ðŸ‘¤',\r\n          isPremium: user.isPremium\r\n        });\r\n      }\r\n    });\r\n\r\n    socketService.on('disconnect', () => {\r\n      setIsConnected(false);\r\n    });\r\n\r\n    socketService.on('connect_error', (error) => {\r\n      setIsConnected(false);\r\n      setConnectionError(error || new Error('Connection failed'));\r\n    });\r\n\r\n    // Subscribe to typing indicators\r\n    socketService.on('user:typing', (data) => {\r\n      setTypingUsers(prev => {\r\n        if (data.isTyping) {\r\n          // Add user to typing list\r\n          if (!prev.includes(data.username)) {\r\n            return [...prev, data.username];\r\n          }\r\n          return prev;\r\n        } else {\r\n          // Remove user from typing list\r\n          return prev.filter(username => username !== data.username);\r\n        }\r\n      });\r\n\r\n      // Auto-remove typing indicator after 3 seconds\r\n      setTimeout(() => {\r\n        setTypingUsers(prev => prev.filter(username => username !== data.username));\r\n      }, 3000);\r\n    });\r\n\r\n    // Cleanup on unmount (don't disconnect - shared connection)\r\n    return () => {\r\n      socketService.off('chat:message');\r\n      socketService.off('connect');\r\n      socketService.off('disconnect');\r\n      socketService.off('connect_error');\r\n      socketService.off('user:typing');\r\n      // Don't disconnect here - App.js manages the connection\r\n    };\r\n  }, [user, fetchServerStats]);\r\n\r\n  // Send a message\r\n  const sendMessage = useCallback((messageText) => {\r\n    if (!messageText.trim() || !isConnected) {\r\n      return false;\r\n    }\r\n\r\n    socketService.emit('chat:message', { message: messageText });\r\n    \r\n    // Stop typing indicator\r\n    setIsTyping(false);\r\n    socketService.emit('user:typing', { isTyping: false });\r\n    \r\n    return true;\r\n  }, [isConnected]);\r\n\r\n  // Handle typing indicators\r\n  const handleTyping = useCallback((typing) => {\r\n    if (!isConnected) return;\r\n\r\n    setIsTyping(typing);\r\n    socketService.emit('user:typing', { isTyping: typing });\r\n\r\n    // Clear previous timeout\r\n    if (typingTimeoutRef.current) {\r\n      clearTimeout(typingTimeoutRef.current);\r\n    }\r\n\r\n    // Auto-stop typing after 3 seconds\r\n    if (typing) {\r\n      typingTimeoutRef.current = setTimeout(() => {\r\n        setIsTyping(false);\r\n        socketService.emit('user:typing', { isTyping: false });\r\n      }, 3000);\r\n    }\r\n  }, [isConnected]);\r\n\r\n  // Send bet notification to chat\r\n  const sendBetNotification = useCallback((amount) => {\r\n    if (!isConnected) return;\r\n    socketService.emit('game:bet', { amount });\r\n  }, [isConnected]);\r\n\r\n  // Reconnect to server (handled by App.js)\r\n  const reconnect = useCallback(() => {\r\n    setConnectionError(null);\r\n    // App.js handles the actual reconnection\r\n    fetchServerStats(); // Just refresh API data\r\n  }, [fetchServerStats]);\r\n\r\n  // Refresh server stats manually\r\n  const refreshStats = useCallback(() => {\r\n    fetchServerStats();\r\n  }, [fetchServerStats]);\r\n\r\n  // Get chat statistics\r\n  const getChatStats = useCallback(() => {\r\n    return {\r\n      totalMessages: Math.max(messages.length, serverStats.totalMessages),\r\n      isConnected,\r\n      hasError: !!connectionError,\r\n      typingUsersCount: typingUsers.length,\r\n      connectedUsers: serverStats.connectedUsers,\r\n      serverStatus: serverStats.serverStatus,\r\n      lastUpdated: serverStats.lastUpdated,\r\n      isLoadingStats\r\n    };\r\n  }, [messages.length, isConnected, connectionError, typingUsers.length, serverStats, isLoadingStats]);\r\n\r\n  // Format message for display\r\n  const formatMessage = useCallback((message) => {\r\n    return {\r\n      ...message,\r\n      timestamp: new Date(message.timestamp),\r\n      isOwnMessage: message.username === user?.displayName,\r\n      formattedTime: new Date(message.timestamp).toLocaleTimeString('en-US', {\r\n        hour: '2-digit',\r\n        minute: '2-digit'\r\n      })\r\n    };\r\n  }, [user?.displayName]);\r\n\r\n  return {\r\n    // State\r\n    messages: messages.map(formatMessage),\r\n    isConnected,\r\n    isTyping,\r\n    typingUsers,\r\n    connectionError,\r\n    serverStats,\r\n    isLoadingStats,\r\n    \r\n    // Actions\r\n    sendMessage,\r\n    handleTyping,\r\n    sendBetNotification,\r\n    reconnect,\r\n    refreshStats,\r\n    \r\n    // Utils\r\n    getChatStats,\r\n    \r\n    // Connection info\r\n            serverUrl: 'http://localhost:5002',\r\n    userInfo: {\r\n      username: user?.displayName || 'Anonymous',\r\n      isRealUser: hasRealUserData,\r\n      isPremium: user?.isPremium || false\r\n    }\r\n  };\r\n};\r\n\r\nexport default useChat; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}