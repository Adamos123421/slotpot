{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeDict = exports.detectLabelType = exports.writeLabelSame = exports.writeLabelLong = exports.writeLabelShort = exports.buildTree = void 0;\nconst Builder_1 = require(\"../boc/Builder\");\nconst findCommonPrefix_1 = require(\"./utils/findCommonPrefix\");\n//\n// Tree Build\n//\nfunction pad(src, size) {\n  while (src.length < size) {\n    src = '0' + src;\n  }\n  return src;\n}\nfunction removePrefixMap(src, length) {\n  if (length === 0) {\n    return src;\n  } else {\n    let res = new Map();\n    for (let k of src.keys()) {\n      let d = src.get(k);\n      res.set(k.slice(length), d);\n    }\n    return res;\n  }\n}\nfunction forkMap(src, prefixLen) {\n  if (src.size === 0) {\n    throw Error('Internal inconsistency');\n  }\n  let left = new Map();\n  let right = new Map();\n  for (let [k, d] of src.entries()) {\n    if (k[prefixLen] === '0') {\n      left.set(k, d);\n    } else {\n      right.set(k, d);\n    }\n  }\n  if (left.size === 0) {\n    throw Error('Internal inconsistency. Left emtpy.');\n  }\n  if (right.size === 0) {\n    throw Error('Internal inconsistency. Right emtpy.');\n  }\n  return {\n    left,\n    right\n  };\n}\nfunction buildNode(src, prefixLen) {\n  if (src.size === 0) {\n    throw Error('Internal inconsistency');\n  }\n  if (src.size === 1) {\n    return {\n      type: 'leaf',\n      value: Array.from(src.values())[0]\n    };\n  }\n  let {\n    left,\n    right\n  } = forkMap(src, prefixLen);\n  return {\n    type: 'fork',\n    left: buildEdge(left, prefixLen + 1),\n    right: buildEdge(right, prefixLen + 1)\n  };\n}\nfunction buildEdge(src, prefixLen = 0) {\n  if (src.size === 0) {\n    throw Error('Internal inconsistency');\n  }\n  const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()), prefixLen);\n  return {\n    label,\n    node: buildNode(src, label.length + prefixLen)\n  };\n}\nfunction buildTree(src, keyLength) {\n  // Convert map keys\n  let converted = new Map();\n  for (let k of Array.from(src.keys())) {\n    const padded = pad(k.toString(2), keyLength);\n    converted.set(padded, src.get(k));\n  }\n  // Calculate root label\n  return buildEdge(converted);\n}\nexports.buildTree = buildTree;\n//\n// Serialization\n//\nfunction writeLabelShort(src, to) {\n  // Header\n  to.storeBit(0);\n  // Unary length\n  for (let i = 0; i < src.length; i++) {\n    to.storeBit(1);\n  }\n  to.storeBit(0);\n  // Value\n  if (src.length > 0) {\n    to.storeUint(BigInt('0b' + src), src.length);\n  }\n  return to;\n}\nexports.writeLabelShort = writeLabelShort;\nfunction labelShortLength(src) {\n  return 1 + src.length + 1 + src.length;\n}\nfunction writeLabelLong(src, keyLength, to) {\n  // Header\n  to.storeBit(1);\n  to.storeBit(0);\n  // Length\n  let length = Math.ceil(Math.log2(keyLength + 1));\n  to.storeUint(src.length, length);\n  // Value\n  if (src.length > 0) {\n    to.storeUint(BigInt('0b' + src), src.length);\n  }\n  return to;\n}\nexports.writeLabelLong = writeLabelLong;\nfunction labelLongLength(src, keyLength) {\n  return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;\n}\nfunction writeLabelSame(value, length, keyLength, to) {\n  // Header\n  to.storeBit(1);\n  to.storeBit(1);\n  // Value\n  to.storeBit(value);\n  // Length\n  let lenLen = Math.ceil(Math.log2(keyLength + 1));\n  to.storeUint(length, lenLen);\n}\nexports.writeLabelSame = writeLabelSame;\nfunction labelSameLength(keyLength) {\n  return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));\n}\nfunction isSame(src) {\n  if (src.length === 0 || src.length === 1) {\n    return true;\n  }\n  for (let i = 1; i < src.length; i++) {\n    if (src[i] !== src[0]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction detectLabelType(src, keyLength) {\n  let kind = 'short';\n  let kindLength = labelShortLength(src);\n  let longLength = labelLongLength(src, keyLength);\n  if (longLength < kindLength) {\n    kindLength = longLength;\n    kind = 'long';\n  }\n  if (isSame(src)) {\n    let sameLength = labelSameLength(keyLength);\n    if (sameLength < kindLength) {\n      kindLength = sameLength;\n      kind = 'same';\n    }\n  }\n  return kind;\n}\nexports.detectLabelType = detectLabelType;\nfunction writeLabel(src, keyLength, to) {\n  let type = detectLabelType(src, keyLength);\n  if (type === 'short') {\n    writeLabelShort(src, to);\n  } else if (type === 'long') {\n    writeLabelLong(src, keyLength, to);\n  } else if (type === 'same') {\n    writeLabelSame(src[0] === '1', src.length, keyLength, to);\n  }\n}\nfunction writeNode(src, keyLength, serializer, to) {\n  if (src.type === 'leaf') {\n    serializer(src.value, to);\n  }\n  if (src.type === 'fork') {\n    const leftCell = (0, Builder_1.beginCell)();\n    const rightCell = (0, Builder_1.beginCell)();\n    writeEdge(src.left, keyLength - 1, serializer, leftCell);\n    writeEdge(src.right, keyLength - 1, serializer, rightCell);\n    to.storeRef(leftCell);\n    to.storeRef(rightCell);\n  }\n}\nfunction writeEdge(src, keyLength, serializer, to) {\n  writeLabel(src.label, keyLength, to);\n  writeNode(src.node, keyLength - src.label.length, serializer, to);\n}\nfunction serializeDict(src, keyLength, serializer, to) {\n  const tree = buildTree(src, keyLength);\n  writeEdge(tree, keyLength, serializer, to);\n}\nexports.serializeDict = serializeDict;","map":{"version":3,"names":["Object","defineProperty","exports","value","serializeDict","detectLabelType","writeLabelSame","writeLabelLong","writeLabelShort","buildTree","Builder_1","require","findCommonPrefix_1","pad","src","size","length","removePrefixMap","res","Map","k","keys","d","get","set","slice","forkMap","prefixLen","Error","left","right","entries","buildNode","type","Array","from","values","buildEdge","label","findCommonPrefix","node","keyLength","converted","padded","toString","to","storeBit","i","storeUint","BigInt","labelShortLength","Math","ceil","log2","labelLongLength","lenLen","labelSameLength","isSame","kind","kindLength","longLength","sameLength","writeLabel","writeNode","serializer","leftCell","beginCell","rightCell","writeEdge","storeRef","tree"],"sources":["C:/Users/adams/Downloads/GLL/slotpot/node_modules/@ton/core/dist/dict/serializeDict.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeDict = exports.detectLabelType = exports.writeLabelSame = exports.writeLabelLong = exports.writeLabelShort = exports.buildTree = void 0;\nconst Builder_1 = require(\"../boc/Builder\");\nconst findCommonPrefix_1 = require(\"./utils/findCommonPrefix\");\n//\n// Tree Build\n//\nfunction pad(src, size) {\n    while (src.length < size) {\n        src = '0' + src;\n    }\n    return src;\n}\nfunction removePrefixMap(src, length) {\n    if (length === 0) {\n        return src;\n    }\n    else {\n        let res = new Map();\n        for (let k of src.keys()) {\n            let d = src.get(k);\n            res.set(k.slice(length), d);\n        }\n        return res;\n    }\n}\nfunction forkMap(src, prefixLen) {\n    if (src.size === 0) {\n        throw Error('Internal inconsistency');\n    }\n    let left = new Map();\n    let right = new Map();\n    for (let [k, d] of src.entries()) {\n        if (k[prefixLen] === '0') {\n            left.set(k, d);\n        }\n        else {\n            right.set(k, d);\n        }\n    }\n    if (left.size === 0) {\n        throw Error('Internal inconsistency. Left emtpy.');\n    }\n    if (right.size === 0) {\n        throw Error('Internal inconsistency. Right emtpy.');\n    }\n    return { left, right };\n}\nfunction buildNode(src, prefixLen) {\n    if (src.size === 0) {\n        throw Error('Internal inconsistency');\n    }\n    if (src.size === 1) {\n        return { type: 'leaf', value: Array.from(src.values())[0] };\n    }\n    let { left, right } = forkMap(src, prefixLen);\n    return {\n        type: 'fork',\n        left: buildEdge(left, prefixLen + 1),\n        right: buildEdge(right, prefixLen + 1)\n    };\n}\nfunction buildEdge(src, prefixLen = 0) {\n    if (src.size === 0) {\n        throw Error('Internal inconsistency');\n    }\n    const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()), prefixLen);\n    return { label, node: buildNode(src, label.length + prefixLen) };\n}\nfunction buildTree(src, keyLength) {\n    // Convert map keys\n    let converted = new Map();\n    for (let k of Array.from(src.keys())) {\n        const padded = pad(k.toString(2), keyLength);\n        converted.set(padded, src.get(k));\n    }\n    // Calculate root label\n    return buildEdge(converted);\n}\nexports.buildTree = buildTree;\n//\n// Serialization\n//\nfunction writeLabelShort(src, to) {\n    // Header\n    to.storeBit(0);\n    // Unary length\n    for (let i = 0; i < src.length; i++) {\n        to.storeBit(1);\n    }\n    to.storeBit(0);\n    // Value\n    if (src.length > 0) {\n        to.storeUint(BigInt('0b' + src), src.length);\n    }\n    return to;\n}\nexports.writeLabelShort = writeLabelShort;\nfunction labelShortLength(src) {\n    return 1 + src.length + 1 + src.length;\n}\nfunction writeLabelLong(src, keyLength, to) {\n    // Header\n    to.storeBit(1);\n    to.storeBit(0);\n    // Length\n    let length = Math.ceil(Math.log2(keyLength + 1));\n    to.storeUint(src.length, length);\n    // Value\n    if (src.length > 0) {\n        to.storeUint(BigInt('0b' + src), src.length);\n    }\n    return to;\n}\nexports.writeLabelLong = writeLabelLong;\nfunction labelLongLength(src, keyLength) {\n    return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;\n}\nfunction writeLabelSame(value, length, keyLength, to) {\n    // Header\n    to.storeBit(1);\n    to.storeBit(1);\n    // Value\n    to.storeBit(value);\n    // Length\n    let lenLen = Math.ceil(Math.log2(keyLength + 1));\n    to.storeUint(length, lenLen);\n}\nexports.writeLabelSame = writeLabelSame;\nfunction labelSameLength(keyLength) {\n    return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));\n}\nfunction isSame(src) {\n    if (src.length === 0 || src.length === 1) {\n        return true;\n    }\n    for (let i = 1; i < src.length; i++) {\n        if (src[i] !== src[0]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction detectLabelType(src, keyLength) {\n    let kind = 'short';\n    let kindLength = labelShortLength(src);\n    let longLength = labelLongLength(src, keyLength);\n    if (longLength < kindLength) {\n        kindLength = longLength;\n        kind = 'long';\n    }\n    if (isSame(src)) {\n        let sameLength = labelSameLength(keyLength);\n        if (sameLength < kindLength) {\n            kindLength = sameLength;\n            kind = 'same';\n        }\n    }\n    return kind;\n}\nexports.detectLabelType = detectLabelType;\nfunction writeLabel(src, keyLength, to) {\n    let type = detectLabelType(src, keyLength);\n    if (type === 'short') {\n        writeLabelShort(src, to);\n    }\n    else if (type === 'long') {\n        writeLabelLong(src, keyLength, to);\n    }\n    else if (type === 'same') {\n        writeLabelSame(src[0] === '1', src.length, keyLength, to);\n    }\n}\nfunction writeNode(src, keyLength, serializer, to) {\n    if (src.type === 'leaf') {\n        serializer(src.value, to);\n    }\n    if (src.type === 'fork') {\n        const leftCell = (0, Builder_1.beginCell)();\n        const rightCell = (0, Builder_1.beginCell)();\n        writeEdge(src.left, keyLength - 1, serializer, leftCell);\n        writeEdge(src.right, keyLength - 1, serializer, rightCell);\n        to.storeRef(leftCell);\n        to.storeRef(rightCell);\n    }\n}\nfunction writeEdge(src, keyLength, serializer, to) {\n    writeLabel(src.label, keyLength, to);\n    writeNode(src.node, keyLength - src.label.length, serializer, to);\n}\nfunction serializeDict(src, keyLength, serializer, to) {\n    const tree = buildTree(src, keyLength);\n    writeEdge(tree, keyLength, serializer, to);\n}\nexports.serializeDict = serializeDict;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}