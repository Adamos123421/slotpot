{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nimport { jackpotContract } from '../services/jackpotContract';\nimport { backendApi } from '../services/backendApi';\nimport useTonConnect from './useTonConnect';\nimport socketService from '../services/socketService';\n\n// API polling removed - all data now comes via socket broadcasts\n\nconst useJackpotContract = () => {\n  _s();\n  var _contractState$timer2;\n  // Debug: Log when hook initializes (only on real initialization)\n  const initRef = useRef(false);\n  if (!initRef.current) {\n    console.log('ðŸ”§ useJackpotContract hook initializing...');\n    initRef.current = true;\n  }\n\n  // Contract state\n  const [contractState, setContractState] = useState({\n    totalJackpot: 0,\n    isActive: false,\n    betCount: 0,\n    lastWinner: null,\n    lastWinnerAddress: null,\n    lastPrizeAmount: 0,\n    contractBalance: 0,\n    timestamp: 0,\n    error: null,\n    // Winner detection\n    roundJustEnded: false,\n    hasWinner: false,\n    winnerAnnouncement: null,\n    // Timer information (now integrated)\n    timer: {\n      isActive: false,\n      timeRemaining: 0,\n      timeElapsed: 0,\n      roundNumber: 0\n    },\n    roundDuration: 300,\n    bettors: []\n  });\n\n  // Current round bettors\n  const [currentBettors, setCurrentBettors] = useState([]);\n\n  // Admin info now comes via socket in contract state\n\n  // User-specific state\n  const [userStats, setUserStats] = useState({\n    betAmount: 0,\n    winningProbability: 0,\n    winChancePercentage: '0.00',\n    loading: false,\n    error: null\n  });\n\n  // Loading states\n  const [isPlacingBet, setIsPlacingBet] = useState(false);\n  const [hasInitialLoad, setHasInitialLoad] = useState(false);\n\n  // Essential refs for hook functionality\n  const prevIsActiveRef = useRef(contractState.isActive);\n  const socketInitializedRef = useRef(false);\n\n  // Get wallet connection status\n  const {\n    isConnected,\n    address,\n    sendTransaction,\n    isLoading: walletLoading,\n    isRestoringConnection\n  } = useTonConnect();\n\n  // REMOVED: All bettor and contract data now comes via socket broadcasts\n\n  // REMOVED: All contract state now comes via socket broadcasts\n\n  // REMOVED: All address tracking and API calls - now handled via socket broadcasts\n\n  // User stats refresh - handled in consolidated polling system\n  // Removed separate useEffect to prevent duplicate API calls\n  // This fixes the issue where APIs were being called 4 times simultaneously\n\n  // Track round changes with ref to prevent re-renders\n  useEffect(() => {\n    var _contractState$timer;\n    const prevIsActive = prevIsActiveRef.current;\n    const currentIsActive = contractState.isActive;\n\n    // Detect new round start (inactive -> active)\n    // But only clear bettors if timer > 0 (actual new round, not waiting for winner)\n    if (!prevIsActive && currentIsActive && ((_contractState$timer = contractState.timer) === null || _contractState$timer === void 0 ? void 0 : _contractState$timer.timeRemaining) > 0) {\n      console.log('ðŸ”„ New round detected, clearing bettors list');\n      setCurrentBettors([]); // Clear bettors list for new round\n    }\n\n    // Update ref for next comparison\n    prevIsActiveRef.current = currentIsActive;\n  }, [contractState.isActive, (_contractState$timer2 = contractState.timer) === null || _contractState$timer2 === void 0 ? void 0 : _contractState$timer2.timeRemaining]);\n\n  // REMOVED: All API polling - now handled entirely via socket broadcasts\n\n  // Socket handling for contract state updates (prevent re-initialization)\n  useEffect(() => {\n    // Prevent duplicate initialization\n    if (socketInitializedRef.current) {\n      console.log('ðŸ”§ Hook: Socket already initialized, skipping');\n      return;\n    }\n    socketInitializedRef.current = true;\n    console.log('ðŸ”§ Hook: Setting up socket listeners (ONCE ONLY)');\n\n    // Listen for full game updates to sync contract state\n    const handleFullGameUpdate = gameData => {\n      console.log('ðŸ”§ Hook: Received full game update:', gameData);\n      setContractState(prevState => {\n        var _gameData$timer$isAct, _gameData$timer, _gameData$timer$timeR, _gameData$timer2, _gameData$timer$round, _gameData$timer3, _gameData$currentRoun;\n        return {\n          ...prevState,\n          ...gameData,\n          // Ensure timer data is preserved/updated\n          timer: {\n            ...prevState.timer,\n            ...gameData.timer,\n            // Fallback to direct properties if timer object doesn't exist\n            isActive: (_gameData$timer$isAct = (_gameData$timer = gameData.timer) === null || _gameData$timer === void 0 ? void 0 : _gameData$timer.isActive) !== null && _gameData$timer$isAct !== void 0 ? _gameData$timer$isAct : gameData.isActive,\n            timeRemaining: (_gameData$timer$timeR = (_gameData$timer2 = gameData.timer) === null || _gameData$timer2 === void 0 ? void 0 : _gameData$timer2.timeRemaining) !== null && _gameData$timer$timeR !== void 0 ? _gameData$timer$timeR : gameData.timeRemaining,\n            roundNumber: (_gameData$timer$round = (_gameData$timer3 = gameData.timer) === null || _gameData$timer3 === void 0 ? void 0 : _gameData$timer3.roundNumber) !== null && _gameData$timer$round !== void 0 ? _gameData$timer$round : (_gameData$currentRoun = gameData.currentRound) === null || _gameData$currentRoun === void 0 ? void 0 : _gameData$currentRoun.roundNumber\n          }\n        };\n      });\n\n      // Update bettors if included in game data\n      if (gameData.bettors && Array.isArray(gameData.bettors)) {\n        console.log('ðŸ”§ Hook: Updating bettors from game data:', gameData.bettors.length, 'bettors');\n        setCurrentBettors(gameData.bettors);\n      }\n    };\n    const handleContractUpdate = contractData => {\n      console.log('ðŸ”§ Hook: Received contract update:', contractData);\n      setContractState(prevState => ({\n        ...prevState,\n        ...contractData\n      }));\n    };\n    const handleBettorsUpdate = bettorsData => {\n      console.log('ðŸ”§ Hook: Received bettors update:', bettorsData);\n      if (bettorsData.bettors) {\n        setCurrentBettors(bettorsData.bettors);\n      }\n    };\n\n    // Set up listeners (removed gameState to avoid duplicates with App.js)\n    socketService.on('fullGameUpdate', handleFullGameUpdate);\n    socketService.on('contractStateUpdate', handleContractUpdate);\n    socketService.on('bettorsUpdate', handleBettorsUpdate);\n    return () => {\n      console.log('ðŸ”§ Hook: Cleaning up socket listeners');\n      socketService.off('fullGameUpdate', handleFullGameUpdate);\n      socketService.off('contractStateUpdate', handleContractUpdate);\n      socketService.off('bettorsUpdate', handleBettorsUpdate);\n      socketInitializedRef.current = false;\n    };\n  }, []); // Empty dependency array - only run once\n\n  // Place a bet (sends real transaction and notifies backend)\n  const placeBet = async betAmount => {\n    console.log(`ðŸŽ° placeBet() called with amount: ${betAmount} TON`);\n    if (!isConnected || !address) {\n      throw new Error('Wallet not connected');\n    }\n    if (!contractState.isActive) {\n      throw new Error('Jackpot is not active');\n    }\n    if (betAmount < 0.1) {\n      throw new Error('Minimum bet is 0.1 TON');\n    }\n    if (betAmount > 10) {\n      throw new Error('Maximum bet is 10 TON');\n    }\n    try {\n      setIsPlacingBet(true);\n      console.log(`ðŸŽ° Placing bet: ${betAmount} TON from ${address}`);\n      console.log(`ðŸ“‹ Contract state: active=${contractState.isActive}, jackpot=${contractState.totalJackpot}`);\n\n      // Build transaction for the smart contract using the contract service\n      console.log(`ðŸ”§ Building transaction with opcode 0x03...`);\n      const transaction = jackpotContract.buildBetTransaction(betAmount, \"EQDhuMbM_cT3dXuJulXmlkA12YF8k5VdpPc1UxkuEqLpCo9K\");\n      console.log(`ðŸ“¤ Sending transaction to contract:`, {\n        contractAddress: transaction.messages[0].address,\n        amount: transaction.messages[0].amount,\n        payloadLength: transaction.messages[0].payload.length\n      });\n\n      // Send transaction via TON Connect\n      const result = await sendTransaction(transaction);\n      console.log('âœ… Bet transaction sent to contract:', result);\n\n      // Show transaction notification\n      if (typeof window !== 'undefined' && window.showTransactionNotification) {\n        window.showTransactionNotification(`ðŸ’° Transaction sent! Your ${betAmount} TON bet will take effect shortly.`, 'success');\n      }\n\n      // Backend will automatically detect the bet through contract polling\n      console.log('âœ… Bet sent to contract - backend will automatically detect via polling');\n\n      // Simple success response - no bet verification polling\n      console.log('âœ… Bet placed successfully - relying on normal polling for updates');\n      return {\n        success: true,\n        txHash: result.boc || 'unknown',\n        amount: betAmount,\n        address: address\n      };\n    } catch (error) {\n      console.error('âŒ Bet placement failed:', error);\n\n      // Show error notification\n      if (typeof window !== 'undefined' && window.showTransactionNotification) {\n        window.showTransactionNotification(`âŒ Bet failed: ${error.message}`, 'error');\n      }\n      throw error;\n    } finally {\n      setIsPlacingBet(false);\n    }\n  };\n\n  // Helper function to format address\n  const formatAddress = addr => {\n    if (!addr) return null;\n    return `${addr.slice(0, 6)}...${addr.slice(-6)}`;\n  };\n\n  // Helper function to format TON amounts\n  const formatTonAmount = amount => {\n    if (!amount) return '0.000';\n    return parseFloat(amount).toFixed(3);\n  };\n  return {\n    // Contract state\n    contractState: {\n      ...contractState,\n      formattedJackpot: formatTonAmount(contractState.totalJackpot),\n      formattedLastPrize: formatTonAmount(contractState.lastPrizeAmount)\n    },\n    // Admin info (now included in contract state)\n\n    // User state\n    userStats: {\n      ...userStats,\n      formattedBetAmount: formatTonAmount(userStats.betAmount)\n    },\n    // Loading states\n    isPlacingBet,\n    isRestoringConnection,\n    walletLoading,\n    // Actions\n    placeBet,\n    // Utility\n    isConnected,\n    address: address ? formatAddress(address) : null,\n    fullAddress: address,\n    // Backend admin controls (for emergency use only)\n    emergencyControls: {\n      forceStartRound: adminKey => backendApi.forceStartRound(adminKey),\n      forceEndRound: adminKey => backendApi.forceEndRound(adminKey),\n      updateSettings: settings => backendApi.updateAdminSettings(settings)\n    },\n    // Current bettors\n    currentBettors\n  };\n};\n_s(useJackpotContract, \"cnpd6DF6ELHRLANrJZvNHtcFddc=\", false, function () {\n  return [useTonConnect];\n});\nexport default useJackpotContract;","map":{"version":3,"names":["useState","useEffect","useRef","jackpotContract","backendApi","useTonConnect","socketService","useJackpotContract","_s","_contractState$timer2","initRef","current","console","log","contractState","setContractState","totalJackpot","isActive","betCount","lastWinner","lastWinnerAddress","lastPrizeAmount","contractBalance","timestamp","error","roundJustEnded","hasWinner","winnerAnnouncement","timer","timeRemaining","timeElapsed","roundNumber","roundDuration","bettors","currentBettors","setCurrentBettors","userStats","setUserStats","betAmount","winningProbability","winChancePercentage","loading","isPlacingBet","setIsPlacingBet","hasInitialLoad","setHasInitialLoad","prevIsActiveRef","socketInitializedRef","isConnected","address","sendTransaction","isLoading","walletLoading","isRestoringConnection","_contractState$timer","prevIsActive","currentIsActive","handleFullGameUpdate","gameData","prevState","_gameData$timer$isAct","_gameData$timer","_gameData$timer$timeR","_gameData$timer2","_gameData$timer$round","_gameData$timer3","_gameData$currentRoun","currentRound","Array","isArray","length","handleContractUpdate","contractData","handleBettorsUpdate","bettorsData","on","off","placeBet","Error","transaction","buildBetTransaction","contractAddress","messages","amount","payloadLength","payload","result","window","showTransactionNotification","success","txHash","boc","message","formatAddress","addr","slice","formatTonAmount","parseFloat","toFixed","formattedJackpot","formattedLastPrize","formattedBetAmount","fullAddress","emergencyControls","forceStartRound","adminKey","forceEndRound","updateSettings","settings","updateAdminSettings"],"sources":["C:/Users/adams/Downloads/GLL/slotpot/src/hooks/useJackpotContract.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\nimport { jackpotContract } from '../services/jackpotContract';\nimport { backendApi } from '../services/backendApi';\nimport useTonConnect from './useTonConnect';\nimport socketService from '../services/socketService';\n\n// API polling removed - all data now comes via socket broadcasts\n\nconst useJackpotContract = () => {\n  // Debug: Log when hook initializes (only on real initialization)\n  const initRef = useRef(false);\n  if (!initRef.current) {\n    console.log('ðŸ”§ useJackpotContract hook initializing...');\n    initRef.current = true;\n  }\n  \n  // Contract state\n  const [contractState, setContractState] = useState({\n    totalJackpot: 0,\n    isActive: false,\n    betCount: 0,\n    lastWinner: null,\n    lastWinnerAddress: null,\n    lastPrizeAmount: 0,\n    contractBalance: 0,\n    timestamp: 0,\n    error: null,\n    // Winner detection\n    roundJustEnded: false,\n    hasWinner: false,\n    winnerAnnouncement: null,\n    // Timer information (now integrated)\n    timer: {\n      isActive: false,\n      timeRemaining: 0,\n      timeElapsed: 0,\n      roundNumber: 0\n    },\n    roundDuration: 300,\n    bettors: []\n  });\n\n  // Current round bettors\n  const [currentBettors, setCurrentBettors] = useState([]);\n\n  // Admin info now comes via socket in contract state\n\n  // User-specific state\n  const [userStats, setUserStats] = useState({\n    betAmount: 0,\n    winningProbability: 0,\n    winChancePercentage: '0.00',\n    loading: false,\n    error: null\n  });\n\n  // Loading states\n  const [isPlacingBet, setIsPlacingBet] = useState(false);\n  const [hasInitialLoad, setHasInitialLoad] = useState(false);\n\n  // Essential refs for hook functionality\n  const prevIsActiveRef = useRef(contractState.isActive);\n  const socketInitializedRef = useRef(false);\n\n  // Get wallet connection status\n  const { \n    isConnected, \n    address, \n    sendTransaction, \n    isLoading: walletLoading,\n    isRestoringConnection \n  } = useTonConnect();\n\n  // REMOVED: All bettor and contract data now comes via socket broadcasts\n\n  // REMOVED: All contract state now comes via socket broadcasts\n\n  // REMOVED: All address tracking and API calls - now handled via socket broadcasts\n\n  // User stats refresh - handled in consolidated polling system\n  // Removed separate useEffect to prevent duplicate API calls\n  // This fixes the issue where APIs were being called 4 times simultaneously\n\n  // Track round changes with ref to prevent re-renders\n  useEffect(() => {\n    const prevIsActive = prevIsActiveRef.current;\n    const currentIsActive = contractState.isActive;\n    \n    // Detect new round start (inactive -> active)\n    // But only clear bettors if timer > 0 (actual new round, not waiting for winner)\n    if (!prevIsActive && currentIsActive && contractState.timer?.timeRemaining > 0) {\n      console.log('ðŸ”„ New round detected, clearing bettors list');\n      setCurrentBettors([]); // Clear bettors list for new round\n    }\n    \n    // Update ref for next comparison\n    prevIsActiveRef.current = currentIsActive;\n  }, [contractState.isActive, contractState.timer?.timeRemaining]);\n\n  // REMOVED: All API polling - now handled entirely via socket broadcasts\n\n  // Socket handling for contract state updates (prevent re-initialization)\n  useEffect(() => {\n    // Prevent duplicate initialization\n    if (socketInitializedRef.current) {\n      console.log('ðŸ”§ Hook: Socket already initialized, skipping');\n      return;\n    }\n    \n    socketInitializedRef.current = true;\n    console.log('ðŸ”§ Hook: Setting up socket listeners (ONCE ONLY)');\n    \n    // Listen for full game updates to sync contract state\n    const handleFullGameUpdate = (gameData) => {\n      console.log('ðŸ”§ Hook: Received full game update:', gameData);\n      setContractState(prevState => ({\n        ...prevState,\n        ...gameData,\n        // Ensure timer data is preserved/updated\n        timer: {\n          ...prevState.timer,\n          ...gameData.timer,\n          // Fallback to direct properties if timer object doesn't exist\n          isActive: gameData.timer?.isActive ?? gameData.isActive,\n          timeRemaining: gameData.timer?.timeRemaining ?? gameData.timeRemaining,\n          roundNumber: gameData.timer?.roundNumber ?? gameData.currentRound?.roundNumber\n        }\n      }));\n      \n      // Update bettors if included in game data\n      if (gameData.bettors && Array.isArray(gameData.bettors)) {\n        console.log('ðŸ”§ Hook: Updating bettors from game data:', gameData.bettors.length, 'bettors');\n        setCurrentBettors(gameData.bettors);\n      }\n    };\n\n    const handleContractUpdate = (contractData) => {\n      console.log('ðŸ”§ Hook: Received contract update:', contractData);\n      setContractState(prevState => ({\n        ...prevState,\n        ...contractData\n      }));\n    };\n\n    const handleBettorsUpdate = (bettorsData) => {\n      console.log('ðŸ”§ Hook: Received bettors update:', bettorsData);\n      if (bettorsData.bettors) {\n        setCurrentBettors(bettorsData.bettors);\n      }\n    };\n\n    // Set up listeners (removed gameState to avoid duplicates with App.js)\n    socketService.on('fullGameUpdate', handleFullGameUpdate);\n    socketService.on('contractStateUpdate', handleContractUpdate);\n    socketService.on('bettorsUpdate', handleBettorsUpdate);\n\n    return () => {\n      console.log('ðŸ”§ Hook: Cleaning up socket listeners');\n      socketService.off('fullGameUpdate', handleFullGameUpdate);\n      socketService.off('contractStateUpdate', handleContractUpdate);\n      socketService.off('bettorsUpdate', handleBettorsUpdate);\n      socketInitializedRef.current = false;\n    };\n  }, []); // Empty dependency array - only run once\n\n  // Place a bet (sends real transaction and notifies backend)\n  const placeBet = async (betAmount) => {\n    console.log(`ðŸŽ° placeBet() called with amount: ${betAmount} TON`);\n    \n    if (!isConnected || !address) {\n      throw new Error('Wallet not connected');\n    }\n\n    if (!contractState.isActive) {\n      throw new Error('Jackpot is not active');\n    }\n\n    if (betAmount < 0.1) {\n      throw new Error('Minimum bet is 0.1 TON');\n    }\n\n    if (betAmount > 10) {\n      throw new Error('Maximum bet is 10 TON');\n    }\n\n    try {\n      setIsPlacingBet(true);\n      console.log(`ðŸŽ° Placing bet: ${betAmount} TON from ${address}`);\n      console.log(`ðŸ“‹ Contract state: active=${contractState.isActive}, jackpot=${contractState.totalJackpot}`);\n\n      // Build transaction for the smart contract using the contract service\n      console.log(`ðŸ”§ Building transaction with opcode 0x03...`);\n      const transaction = jackpotContract.buildBetTransaction(betAmount, \"EQDhuMbM_cT3dXuJulXmlkA12YF8k5VdpPc1UxkuEqLpCo9K\");\n      \n      console.log(`ðŸ“¤ Sending transaction to contract:`, {\n        contractAddress: transaction.messages[0].address,\n        amount: transaction.messages[0].amount,\n        payloadLength: transaction.messages[0].payload.length\n      });\n      \n      // Send transaction via TON Connect\n      const result = await sendTransaction(transaction);\n      \n      console.log('âœ… Bet transaction sent to contract:', result);\n\n      // Show transaction notification\n      if (typeof window !== 'undefined' && window.showTransactionNotification) {\n        window.showTransactionNotification(`ðŸ’° Transaction sent! Your ${betAmount} TON bet will take effect shortly.`, 'success');\n      }\n\n      // Backend will automatically detect the bet through contract polling\n      console.log('âœ… Bet sent to contract - backend will automatically detect via polling');\n\n      // Simple success response - no bet verification polling\n      console.log('âœ… Bet placed successfully - relying on normal polling for updates');\n\n      return {\n        success: true,\n        txHash: result.boc || 'unknown',\n        amount: betAmount,\n        address: address\n      };\n    } catch (error) {\n      console.error('âŒ Bet placement failed:', error);\n      \n      // Show error notification\n      if (typeof window !== 'undefined' && window.showTransactionNotification) {\n        window.showTransactionNotification(`âŒ Bet failed: ${error.message}`, 'error');\n      }\n      \n      throw error;\n    } finally {\n      setIsPlacingBet(false);\n    }\n  };\n\n  // Helper function to format address\n  const formatAddress = (addr) => {\n    if (!addr) return null;\n    return `${addr.slice(0, 6)}...${addr.slice(-6)}`;\n  };\n\n  // Helper function to format TON amounts\n  const formatTonAmount = (amount) => {\n    if (!amount) return '0.000';\n    return parseFloat(amount).toFixed(3);\n  };\n\n  return {\n    // Contract state\n    contractState: {\n      ...contractState,\n      formattedJackpot: formatTonAmount(contractState.totalJackpot),\n      formattedLastPrize: formatTonAmount(contractState.lastPrizeAmount)\n    },\n    \n    // Admin info (now included in contract state)\n    \n    // User state\n    userStats: {\n      ...userStats,\n      formattedBetAmount: formatTonAmount(userStats.betAmount)\n    },\n    \n    // Loading states\n    isPlacingBet,\n    isRestoringConnection,\n    walletLoading,\n    \n    // Actions\n    placeBet,\n    \n    // Utility\n    isConnected,\n    address: address ? formatAddress(address) : null,\n    fullAddress: address,\n    \n    // Backend admin controls (for emergency use only)\n    emergencyControls: {\n      forceStartRound: (adminKey) => backendApi.forceStartRound(adminKey),\n      forceEndRound: (adminKey) => backendApi.forceEndRound(adminKey),\n      updateSettings: (settings) => backendApi.updateAdminSettings(settings)\n    },\n    \n    // Current bettors\n    currentBettors\n  };\n};\n\nexport default useJackpotContract;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}