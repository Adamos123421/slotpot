{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ADNLAddress = void 0;\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nconst base32_1 = require(\"../utils/base32\");\nconst crc16_1 = require(\"../utils/crc16\");\nclass ADNLAddress {\n  static parseFriendly(src) {\n    if (src.length !== 55) {\n      throw Error('Invalid address');\n    }\n    // Decoding\n    src = 'f' + src;\n    let decoded = (0, base32_1.base32Decode)(src);\n    if (decoded[0] !== 0x2d) {\n      throw Error('Invalid address');\n    }\n    let gotHash = decoded.slice(33);\n    let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));\n    if (!hash.equals(gotHash)) {\n      throw Error('Invalid address');\n    }\n    return new ADNLAddress(decoded.slice(1, 33));\n  }\n  static parseRaw(src) {\n    const data = Buffer.from(src, 'base64');\n    return new ADNLAddress(data);\n  }\n  constructor(address) {\n    this.toRaw = () => {\n      return this.address.toString('hex').toUpperCase();\n    };\n    this.toString = () => {\n      let data = Buffer.concat([Buffer.from([0x2D]), this.address]);\n      let hash = (0, crc16_1.crc16)(data);\n      data = Buffer.concat([data, hash]);\n      return (0, base32_1.base32Encode)(data).slice(1);\n    };\n    this[_a] = () => this.toString();\n    if (address.length !== 32) {\n      throw Error('Invalid address');\n    }\n    this.address = address;\n  }\n  equals(b) {\n    return this.address.equals(b.address);\n  }\n}\nexports.ADNLAddress = ADNLAddress;\n_a = symbol_inspect_1.default;","map":{"version":3,"names":["__importDefault","mod","__esModule","_a","Object","defineProperty","exports","value","ADNLAddress","symbol_inspect_1","require","base32_1","crc16_1","parseFriendly","src","length","Error","decoded","base32Decode","gotHash","slice","hash","crc16","equals","parseRaw","data","Buffer","from","constructor","address","toRaw","toString","toUpperCase","concat","base32Encode","b","default"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/address/ADNLAddress.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ADNLAddress = void 0;\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nconst base32_1 = require(\"../utils/base32\");\nconst crc16_1 = require(\"../utils/crc16\");\nclass ADNLAddress {\n    static parseFriendly(src) {\n        if (src.length !== 55) {\n            throw Error('Invalid address');\n        }\n        // Decoding\n        src = 'f' + src;\n        let decoded = (0, base32_1.base32Decode)(src);\n        if (decoded[0] !== 0x2d) {\n            throw Error('Invalid address');\n        }\n        let gotHash = decoded.slice(33);\n        let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));\n        if (!hash.equals(gotHash)) {\n            throw Error('Invalid address');\n        }\n        return new ADNLAddress(decoded.slice(1, 33));\n    }\n    static parseRaw(src) {\n        const data = Buffer.from(src, 'base64');\n        return new ADNLAddress(data);\n    }\n    constructor(address) {\n        this.toRaw = () => {\n            return this.address.toString('hex').toUpperCase();\n        };\n        this.toString = () => {\n            let data = Buffer.concat([Buffer.from([0x2D]), this.address]);\n            let hash = (0, crc16_1.crc16)(data);\n            data = Buffer.concat([data, hash]);\n            return (0, base32_1.base32Encode)(data).slice(1);\n        };\n        this[_a] = () => this.toString();\n        if (address.length !== 32) {\n            throw Error('Invalid address');\n        }\n        this.address = address;\n    }\n    equals(b) {\n        return this.address.equals(b.address);\n    }\n}\nexports.ADNLAddress = ADNLAddress;\n_a = symbol_inspect_1.default;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}