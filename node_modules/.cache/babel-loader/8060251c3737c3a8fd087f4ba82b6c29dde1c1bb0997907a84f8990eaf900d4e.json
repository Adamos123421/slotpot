{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) 2019-present, GraphQL Foundation\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// A Function, which when given an Array of keys, returns a Promise of an Array\n// of values or Errors.\n// Optionally turn off batching or caching or provide a cache key function or a\n// custom cache instance.\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nvar DataLoader = /*#__PURE__*/\nfunction () {\n  function DataLoader(batchLoadFn, options) {\n    if (typeof batchLoadFn !== 'function') {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n    }\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n    this.name = getValidName(options);\n  } // Private\n\n  var _proto = DataLoader.prototype;\n\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n  _proto.load = function load(key) {\n    if (key === null || key === undefined) {\n      throw new TypeError('The loader.load() function must be called with a value, ' + (\"but got: \" + String(key) + \".\"));\n    }\n    var batch = getCurrentBatch(this);\n    var cacheMap = this._cacheMap;\n    var cacheKey; // If caching and there is a cache-hit, return cached Promise.\n\n    if (cacheMap) {\n      cacheKey = this._cacheKeyFn(key);\n      var cachedPromise = cacheMap.get(cacheKey);\n      if (cachedPromise) {\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(function (resolve) {\n          cacheHits.push(function () {\n            resolve(cachedPromise);\n          });\n        });\n      }\n    } // Otherwise, produce a new Promise for this key, and enqueue it to be\n    // dispatched along with the current batch.\n\n    batch.keys.push(key);\n    var promise = new Promise(function (resolve, reject) {\n      batch.callbacks.push({\n        resolve: resolve,\n        reject: reject\n      });\n    }); // If caching, cache this promise.\n\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */;\n  _proto.loadMany = function loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + (\"but got: \" + keys + \".\"));\n    } // Support ArrayLike by using only minimal property access\n\n    var loadPromises = [];\n    for (var i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i])[\"catch\"](function (error) {\n        return error;\n      }));\n    }\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */;\n  _proto.clear = function clear(key) {\n    var cacheMap = this._cacheMap;\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n      cacheMap[\"delete\"](cacheKey);\n    }\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */;\n  _proto.clearAll = function clearAll() {\n    var cacheMap = this._cacheMap;\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */;\n  _proto.prime = function prime(key, value) {\n    var cacheMap = this._cacheMap;\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\n\n      if (cacheMap.get(cacheKey) === undefined) {\n        // Cache a rejected promise if the value is an Error, in order to match\n        // the behavior of load(key).\n        var promise;\n        if (value instanceof Error) {\n          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\n          // for a given key, we want to disable unhandled promise rejection.\n\n          promise[\"catch\"](function () {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n    return this;\n  }\n  /**\n   * The name given to this `DataLoader` instance. Useful for APM tools.\n   *\n   * Is `null` if not set in the constructor.\n   */;\n  return DataLoader;\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\n\nvar enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n  resolvedPromise.then(function () {\n    process.nextTick(fn);\n  });\n} : typeof setImmediate === 'function' ? function (fn) {\n  setImmediate(fn);\n} : function (fn) {\n  setTimeout(fn);\n}; // Private: cached resolved Promise instance\n\nvar resolvedPromise; // Private: Describes a batch of requests\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch(loader) {\n  // If there is an existing batch which has not yet dispatched and is within\n  // the limit of the batch size, then return it.\n  var existingBatch = loader._batch;\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {\n    return existingBatch;\n  } // Otherwise, create a new batch for this loader.\n\n  var newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  }; // Store it on the loader so it may be reused.\n\n  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\n\n  loader._batchScheduleFn(function () {\n    dispatchBatch(loader, newBatch);\n  });\n  return newBatch;\n}\nfunction dispatchBatch(loader, batch) {\n  // Mark this batch as having been dispatched.\n  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\n\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  } // Call the provided batchLoadFn for this loader with the batch's keys and\n  // with the loader as the `this` context.\n\n  var batchPromise;\n  try {\n    batchPromise = loader._batchLoadFn(batch.keys);\n  } catch (e) {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function ' + (\"errored synchronously: \" + String(e) + \".\")));\n  } // Assert the expected response from batchLoadFn\n\n  if (!batchPromise || typeof batchPromise.then !== 'function') {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n  } // Await the resolution of the call to batchLoadFn.\n\n  batchPromise.then(function (values) {\n    // Assert the expected resolution from batchLoadFn.\n    if (!isArrayLike(values)) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n    }\n    if (values.length !== batch.keys.length) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n    } // Resolve all cache hits in the same micro-task as freshly loaded values.\n\n    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\n\n    for (var i = 0; i < batch.callbacks.length; i++) {\n      var _value = values[i];\n      if (_value instanceof Error) {\n        batch.callbacks[i].reject(_value);\n      } else {\n        batch.callbacks[i].resolve(_value);\n      }\n    }\n  })[\"catch\"](function (error) {\n    failedDispatch(loader, batch, error);\n  });\n} // Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\n\nfunction failedDispatch(loader, batch, error) {\n  // Cache hits are resolved, even though the batch failed.\n  resolveCacheHits(batch);\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n} // Private: Resolves the Promises for any cache hits in this batch.\n\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n} // Private: given the DataLoader's options, produce a valid max batch size.\n\nfunction getValidMaxBatchSize(options) {\n  var shouldBatch = !options || options.batch !== false;\n  if (!shouldBatch) {\n    return 1;\n  }\n  var maxBatchSize = options && options.maxBatchSize;\n  if (maxBatchSize === undefined) {\n    return Infinity;\n  }\n  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n  }\n  return maxBatchSize;\n} // Private\n\nfunction getValidBatchScheduleFn(options) {\n  var batchScheduleFn = options && options.batchScheduleFn;\n  if (batchScheduleFn === undefined) {\n    return enqueuePostPromiseJob;\n  }\n  if (typeof batchScheduleFn !== 'function') {\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n  }\n  return batchScheduleFn;\n} // Private: given the DataLoader's options, produce a cache key function.\n\nfunction getValidCacheKeyFn(options) {\n  var cacheKeyFn = options && options.cacheKeyFn;\n  if (cacheKeyFn === undefined) {\n    return function (key) {\n      return key;\n    };\n  }\n  if (typeof cacheKeyFn !== 'function') {\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n  }\n  return cacheKeyFn;\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\n\nfunction getValidCacheMap(options) {\n  var shouldCache = !options || options.cache !== false;\n  if (!shouldCache) {\n    return null;\n  }\n  var cacheMap = options && options.cacheMap;\n  if (cacheMap === undefined) {\n    return new Map();\n  }\n  if (cacheMap !== null) {\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\n    var missingFunctions = cacheFunctions.filter(function (fnName) {\n      return cacheMap && typeof cacheMap[fnName] !== 'function';\n    });\n    if (missingFunctions.length !== 0) {\n      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n    }\n  }\n  return cacheMap;\n}\nfunction getValidName(options) {\n  if (options && options.name) {\n    return options.name;\n  }\n  return null;\n} // Private\n\nfunction isArrayLike(x) {\n  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\nmodule.exports = DataLoader;","map":{"version":3,"names":["DataLoader","batchLoadFn","options","TypeError","_batchLoadFn","_maxBatchSize","getValidMaxBatchSize","_batchScheduleFn","getValidBatchScheduleFn","_cacheKeyFn","getValidCacheKeyFn","_cacheMap","getValidCacheMap","_batch","name","getValidName","_proto","prototype","load","key","undefined","String","batch","getCurrentBatch","cacheMap","cacheKey","cachedPromise","get","cacheHits","Promise","resolve","push","keys","promise","reject","callbacks","set","loadMany","isArrayLike","loadPromises","i","length","error","all","clear","clearAll","prime","value","Error","enqueuePostPromiseJob","process","nextTick","fn","resolvedPromise","then","setImmediate","setTimeout","loader","existingBatch","hasDispatched","newBatch","dispatchBatch","resolveCacheHits","batchPromise","e","failedDispatch","values","_value","shouldBatch","maxBatchSize","Infinity","batchScheduleFn","cacheKeyFn","shouldCache","cache","Map","cacheFunctions","missingFunctions","filter","fnName","join","x","Object","hasOwnProperty","call","module","exports"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/dataloader/index.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Copyright (c) 2019-present, GraphQL Foundation\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// A Function, which when given an Array of keys, returns a Promise of an Array\n// of values or Errors.\n// Optionally turn off batching or caching or provide a cache key function or a\n// custom cache instance.\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nvar DataLoader =\n/*#__PURE__*/\nfunction () {\n  function DataLoader(batchLoadFn, options) {\n    if (typeof batchLoadFn !== 'function') {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n    }\n\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n    this.name = getValidName(options);\n  } // Private\n\n\n  var _proto = DataLoader.prototype;\n\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n  _proto.load = function load(key) {\n    if (key === null || key === undefined) {\n      throw new TypeError('The loader.load() function must be called with a value, ' + (\"but got: \" + String(key) + \".\"));\n    }\n\n    var batch = getCurrentBatch(this);\n    var cacheMap = this._cacheMap;\n    var cacheKey; // If caching and there is a cache-hit, return cached Promise.\n\n    if (cacheMap) {\n      cacheKey = this._cacheKeyFn(key);\n      var cachedPromise = cacheMap.get(cacheKey);\n\n      if (cachedPromise) {\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(function (resolve) {\n          cacheHits.push(function () {\n            resolve(cachedPromise);\n          });\n        });\n      }\n    } // Otherwise, produce a new Promise for this key, and enqueue it to be\n    // dispatched along with the current batch.\n\n\n    batch.keys.push(key);\n    var promise = new Promise(function (resolve, reject) {\n      batch.callbacks.push({\n        resolve: resolve,\n        reject: reject\n      });\n    }); // If caching, cache this promise.\n\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */\n  ;\n\n  _proto.loadMany = function loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + (\"but got: \" + keys + \".\"));\n    } // Support ArrayLike by using only minimal property access\n\n\n    var loadPromises = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i])[\"catch\"](function (error) {\n        return error;\n      }));\n    }\n\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clear = function clear(key) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n\n      cacheMap[\"delete\"](cacheKey);\n    }\n\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clearAll = function clearAll() {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */\n  ;\n\n  _proto.prime = function prime(key, value) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\n\n\n      if (cacheMap.get(cacheKey) === undefined) {\n        // Cache a rejected promise if the value is an Error, in order to match\n        // the behavior of load(key).\n        var promise;\n\n        if (value instanceof Error) {\n          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\n          // for a given key, we want to disable unhandled promise rejection.\n\n          promise[\"catch\"](function () {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The name given to this `DataLoader` instance. Useful for APM tools.\n   *\n   * Is `null` if not set in the constructor.\n   */\n  ;\n\n  return DataLoader;\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\n\n\nvar enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n\n  resolvedPromise.then(function () {\n    process.nextTick(fn);\n  });\n} : typeof setImmediate === 'function' ? function (fn) {\n  setImmediate(fn);\n} : function (fn) {\n  setTimeout(fn);\n}; // Private: cached resolved Promise instance\n\nvar resolvedPromise; // Private: Describes a batch of requests\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch(loader) {\n  // If there is an existing batch which has not yet dispatched and is within\n  // the limit of the batch size, then return it.\n  var existingBatch = loader._batch;\n\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {\n    return existingBatch;\n  } // Otherwise, create a new batch for this loader.\n\n\n  var newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  }; // Store it on the loader so it may be reused.\n\n  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\n\n  loader._batchScheduleFn(function () {\n    dispatchBatch(loader, newBatch);\n  });\n\n  return newBatch;\n}\n\nfunction dispatchBatch(loader, batch) {\n  // Mark this batch as having been dispatched.\n  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\n\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  } // Call the provided batchLoadFn for this loader with the batch's keys and\n  // with the loader as the `this` context.\n\n\n  var batchPromise;\n\n  try {\n    batchPromise = loader._batchLoadFn(batch.keys);\n  } catch (e) {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function ' + (\"errored synchronously: \" + String(e) + \".\")));\n  } // Assert the expected response from batchLoadFn\n\n\n  if (!batchPromise || typeof batchPromise.then !== 'function') {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n  } // Await the resolution of the call to batchLoadFn.\n\n\n  batchPromise.then(function (values) {\n    // Assert the expected resolution from batchLoadFn.\n    if (!isArrayLike(values)) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n    }\n\n    if (values.length !== batch.keys.length) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n    } // Resolve all cache hits in the same micro-task as freshly loaded values.\n\n\n    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\n\n    for (var i = 0; i < batch.callbacks.length; i++) {\n      var _value = values[i];\n\n      if (_value instanceof Error) {\n        batch.callbacks[i].reject(_value);\n      } else {\n        batch.callbacks[i].resolve(_value);\n      }\n    }\n  })[\"catch\"](function (error) {\n    failedDispatch(loader, batch, error);\n  });\n} // Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\n\n\nfunction failedDispatch(loader, batch, error) {\n  // Cache hits are resolved, even though the batch failed.\n  resolveCacheHits(batch);\n\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n} // Private: Resolves the Promises for any cache hits in this batch.\n\n\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n} // Private: given the DataLoader's options, produce a valid max batch size.\n\n\nfunction getValidMaxBatchSize(options) {\n  var shouldBatch = !options || options.batch !== false;\n\n  if (!shouldBatch) {\n    return 1;\n  }\n\n  var maxBatchSize = options && options.maxBatchSize;\n\n  if (maxBatchSize === undefined) {\n    return Infinity;\n  }\n\n  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n  }\n\n  return maxBatchSize;\n} // Private\n\n\nfunction getValidBatchScheduleFn(options) {\n  var batchScheduleFn = options && options.batchScheduleFn;\n\n  if (batchScheduleFn === undefined) {\n    return enqueuePostPromiseJob;\n  }\n\n  if (typeof batchScheduleFn !== 'function') {\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n  }\n\n  return batchScheduleFn;\n} // Private: given the DataLoader's options, produce a cache key function.\n\n\nfunction getValidCacheKeyFn(options) {\n  var cacheKeyFn = options && options.cacheKeyFn;\n\n  if (cacheKeyFn === undefined) {\n    return function (key) {\n      return key;\n    };\n  }\n\n  if (typeof cacheKeyFn !== 'function') {\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n  }\n\n  return cacheKeyFn;\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\n\n\nfunction getValidCacheMap(options) {\n  var shouldCache = !options || options.cache !== false;\n\n  if (!shouldCache) {\n    return null;\n  }\n\n  var cacheMap = options && options.cacheMap;\n\n  if (cacheMap === undefined) {\n    return new Map();\n  }\n\n  if (cacheMap !== null) {\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\n    var missingFunctions = cacheFunctions.filter(function (fnName) {\n      return cacheMap && typeof cacheMap[fnName] !== 'function';\n    });\n\n    if (missingFunctions.length !== 0) {\n      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n    }\n  }\n\n  return cacheMap;\n}\n\nfunction getValidName(options) {\n  if (options && options.name) {\n    return options.name;\n  }\n\n  return null;\n} // Private\n\n\nfunction isArrayLike(x) {\n  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\n\nmodule.exports = DataLoader;"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,UAAU,GACd;AACA,YAAY;EACV,SAASA,UAAUA,CAACC,WAAW,EAAEC,OAAO,EAAE;IACxC,IAAI,OAAOD,WAAW,KAAK,UAAU,EAAE;MACrC,MAAM,IAAIE,SAAS,CAAC,+DAA+D,IAAI,yDAAyD,GAAGF,WAAW,GAAG,GAAG,CAAC,CAAC;IACxK;IAEA,IAAI,CAACG,YAAY,GAAGH,WAAW;IAC/B,IAAI,CAACI,aAAa,GAAGC,oBAAoB,CAACJ,OAAO,CAAC;IAClD,IAAI,CAACK,gBAAgB,GAAGC,uBAAuB,CAACN,OAAO,CAAC;IACxD,IAAI,CAACO,WAAW,GAAGC,kBAAkB,CAACR,OAAO,CAAC;IAC9C,IAAI,CAACS,SAAS,GAAGC,gBAAgB,CAACV,OAAO,CAAC;IAC1C,IAAI,CAACW,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,IAAI,GAAGC,YAAY,CAACb,OAAO,CAAC;EACnC,CAAC,CAAC;;EAGF,IAAIc,MAAM,GAAGhB,UAAU,CAACiB,SAAS;;EAEjC;AACF;AACA;EACED,MAAM,CAACE,IAAI,GAAG,SAASA,IAAIA,CAACC,GAAG,EAAE;IAC/B,IAAIA,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAKC,SAAS,EAAE;MACrC,MAAM,IAAIjB,SAAS,CAAC,0DAA0D,IAAI,WAAW,GAAGkB,MAAM,CAACF,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;IACrH;IAEA,IAAIG,KAAK,GAAGC,eAAe,CAAC,IAAI,CAAC;IACjC,IAAIC,QAAQ,GAAG,IAAI,CAACb,SAAS;IAC7B,IAAIc,QAAQ,CAAC,CAAC;;IAEd,IAAID,QAAQ,EAAE;MACZC,QAAQ,GAAG,IAAI,CAAChB,WAAW,CAACU,GAAG,CAAC;MAChC,IAAIO,aAAa,GAAGF,QAAQ,CAACG,GAAG,CAACF,QAAQ,CAAC;MAE1C,IAAIC,aAAa,EAAE;QACjB,IAAIE,SAAS,GAAGN,KAAK,CAACM,SAAS,KAAKN,KAAK,CAACM,SAAS,GAAG,EAAE,CAAC;QACzD,OAAO,IAAIC,OAAO,CAAC,UAAUC,OAAO,EAAE;UACpCF,SAAS,CAACG,IAAI,CAAC,YAAY;YACzBD,OAAO,CAACJ,aAAa,CAAC;UACxB,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;IACF;;IAGAJ,KAAK,CAACU,IAAI,CAACD,IAAI,CAACZ,GAAG,CAAC;IACpB,IAAIc,OAAO,GAAG,IAAIJ,OAAO,CAAC,UAAUC,OAAO,EAAEI,MAAM,EAAE;MACnDZ,KAAK,CAACa,SAAS,CAACJ,IAAI,CAAC;QACnBD,OAAO,EAAEA,OAAO;QAChBI,MAAM,EAAEA;MACV,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC,CAAC;;IAEJ,IAAIV,QAAQ,EAAE;MACZA,QAAQ,CAACY,GAAG,CAACX,QAAQ,EAAEQ,OAAO,CAAC;IACjC;IAEA,OAAOA,OAAO;EAChB;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAnBE;EAsBAjB,MAAM,CAACqB,QAAQ,GAAG,SAASA,QAAQA,CAACL,IAAI,EAAE;IACxC,IAAI,CAACM,WAAW,CAACN,IAAI,CAAC,EAAE;MACtB,MAAM,IAAI7B,SAAS,CAAC,gEAAgE,IAAI,WAAW,GAAG6B,IAAI,GAAG,GAAG,CAAC,CAAC;IACpH,CAAC,CAAC;;IAGF,IAAIO,YAAY,GAAG,EAAE;IAErB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,IAAI,CAACS,MAAM,EAAED,CAAC,EAAE,EAAE;MACpCD,YAAY,CAACR,IAAI,CAAC,IAAI,CAACb,IAAI,CAACc,IAAI,CAACQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,UAAUE,KAAK,EAAE;QAC7D,OAAOA,KAAK;MACd,CAAC,CAAC,CAAC;IACL;IAEA,OAAOb,OAAO,CAACc,GAAG,CAACJ,YAAY,CAAC;EAClC;EACA;AACF;AACA;AACA,KAHE;EAMAvB,MAAM,CAAC4B,KAAK,GAAG,SAASA,KAAKA,CAACzB,GAAG,EAAE;IACjC,IAAIK,QAAQ,GAAG,IAAI,CAACb,SAAS;IAE7B,IAAIa,QAAQ,EAAE;MACZ,IAAIC,QAAQ,GAAG,IAAI,CAAChB,WAAW,CAACU,GAAG,CAAC;MAEpCK,QAAQ,CAAC,QAAQ,CAAC,CAACC,QAAQ,CAAC;IAC9B;IAEA,OAAO,IAAI;EACb;EACA;AACF;AACA;AACA;AACA,KAJE;EAOAT,MAAM,CAAC6B,QAAQ,GAAG,SAASA,QAAQA,CAAA,EAAG;IACpC,IAAIrB,QAAQ,GAAG,IAAI,CAACb,SAAS;IAE7B,IAAIa,QAAQ,EAAE;MACZA,QAAQ,CAACoB,KAAK,CAAC,CAAC;IAClB;IAEA,OAAO,IAAI;EACb;EACA;AACF;AACA;AACA;AACA;AACA,KALE;EAQA5B,MAAM,CAAC8B,KAAK,GAAG,SAASA,KAAKA,CAAC3B,GAAG,EAAE4B,KAAK,EAAE;IACxC,IAAIvB,QAAQ,GAAG,IAAI,CAACb,SAAS;IAE7B,IAAIa,QAAQ,EAAE;MACZ,IAAIC,QAAQ,GAAG,IAAI,CAAChB,WAAW,CAACU,GAAG,CAAC,CAAC,CAAC;;MAGtC,IAAIK,QAAQ,CAACG,GAAG,CAACF,QAAQ,CAAC,KAAKL,SAAS,EAAE;QACxC;QACA;QACA,IAAIa,OAAO;QAEX,IAAIc,KAAK,YAAYC,KAAK,EAAE;UAC1Bf,OAAO,GAAGJ,OAAO,CAACK,MAAM,CAACa,KAAK,CAAC,CAAC,CAAC;UACjC;;UAEAd,OAAO,CAAC,OAAO,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;QAClC,CAAC,MAAM;UACLA,OAAO,GAAGJ,OAAO,CAACC,OAAO,CAACiB,KAAK,CAAC;QAClC;QAEAvB,QAAQ,CAACY,GAAG,CAACX,QAAQ,EAAEQ,OAAO,CAAC;MACjC;IACF;IAEA,OAAO,IAAI;EACb;EACA;AACF;AACA;AACA;AACA,KAJE;EAOA,OAAOjC,UAAU;AACnB,CAAC,CAAC,CAAC,CAAC,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,IAAIiD,qBAAqB,GAAG,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,CAACC,QAAQ,KAAK,UAAU,GAAG,UAAUC,EAAE,EAAE;EAChH,IAAI,CAACC,eAAe,EAAE;IACpBA,eAAe,GAAGxB,OAAO,CAACC,OAAO,CAAC,CAAC;EACrC;EAEAuB,eAAe,CAACC,IAAI,CAAC,YAAY;IAC/BJ,OAAO,CAACC,QAAQ,CAACC,EAAE,CAAC;EACtB,CAAC,CAAC;AACJ,CAAC,GAAG,OAAOG,YAAY,KAAK,UAAU,GAAG,UAAUH,EAAE,EAAE;EACrDG,YAAY,CAACH,EAAE,CAAC;AAClB,CAAC,GAAG,UAAUA,EAAE,EAAE;EAChBI,UAAU,CAACJ,EAAE,CAAC;AAChB,CAAC,CAAC,CAAC;;AAEH,IAAIC,eAAe,CAAC,CAAC;;AAErB;AACA;AACA,SAAS9B,eAAeA,CAACkC,MAAM,EAAE;EAC/B;EACA;EACA,IAAIC,aAAa,GAAGD,MAAM,CAAC5C,MAAM;EAEjC,IAAI6C,aAAa,KAAK,IAAI,IAAI,CAACA,aAAa,CAACC,aAAa,IAAID,aAAa,CAAC1B,IAAI,CAACS,MAAM,GAAGgB,MAAM,CAACpD,aAAa,EAAE;IAC9G,OAAOqD,aAAa;EACtB,CAAC,CAAC;;EAGF,IAAIE,QAAQ,GAAG;IACbD,aAAa,EAAE,KAAK;IACpB3B,IAAI,EAAE,EAAE;IACRG,SAAS,EAAE;EACb,CAAC,CAAC,CAAC;;EAEHsB,MAAM,CAAC5C,MAAM,GAAG+C,QAAQ,CAAC,CAAC;;EAE1BH,MAAM,CAAClD,gBAAgB,CAAC,YAAY;IAClCsD,aAAa,CAACJ,MAAM,EAAEG,QAAQ,CAAC;EACjC,CAAC,CAAC;EAEF,OAAOA,QAAQ;AACjB;AAEA,SAASC,aAAaA,CAACJ,MAAM,EAAEnC,KAAK,EAAE;EACpC;EACAA,KAAK,CAACqC,aAAa,GAAG,IAAI,CAAC,CAAC;;EAE5B,IAAIrC,KAAK,CAACU,IAAI,CAACS,MAAM,KAAK,CAAC,EAAE;IAC3BqB,gBAAgB,CAACxC,KAAK,CAAC;IACvB;EACF,CAAC,CAAC;EACF;;EAGA,IAAIyC,YAAY;EAEhB,IAAI;IACFA,YAAY,GAAGN,MAAM,CAACrD,YAAY,CAACkB,KAAK,CAACU,IAAI,CAAC;EAChD,CAAC,CAAC,OAAOgC,CAAC,EAAE;IACV,OAAOC,cAAc,CAACR,MAAM,EAAEnC,KAAK,EAAE,IAAInB,SAAS,CAAC,+DAA+D,GAAG,iEAAiE,IAAI,yBAAyB,GAAGkB,MAAM,CAAC2C,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;EAC1O,CAAC,CAAC;;EAGF,IAAI,CAACD,YAAY,IAAI,OAAOA,YAAY,CAACT,IAAI,KAAK,UAAU,EAAE;IAC5D,OAAOW,cAAc,CAACR,MAAM,EAAEnC,KAAK,EAAE,IAAInB,SAAS,CAAC,+DAA+D,GAAG,qEAAqE,IAAI,wBAAwB,GAAGkB,MAAM,CAAC0C,YAAY,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;EACxP,CAAC,CAAC;;EAGFA,YAAY,CAACT,IAAI,CAAC,UAAUY,MAAM,EAAE;IAClC;IACA,IAAI,CAAC5B,WAAW,CAAC4B,MAAM,CAAC,EAAE;MACxB,MAAM,IAAI/D,SAAS,CAAC,+DAA+D,GAAG,qEAAqE,IAAI,oCAAoC,GAAGkB,MAAM,CAAC6C,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC;IAC9N;IAEA,IAAIA,MAAM,CAACzB,MAAM,KAAKnB,KAAK,CAACU,IAAI,CAACS,MAAM,EAAE;MACvC,MAAM,IAAItC,SAAS,CAAC,+DAA+D,GAAG,qEAAqE,GAAG,mEAAmE,GAAG,UAAU,IAAI,aAAa,GAAGkB,MAAM,CAACC,KAAK,CAACU,IAAI,CAAC,CAAC,IAAI,eAAe,GAAGX,MAAM,CAAC6C,MAAM,CAAC,CAAC,CAAC;IAC7T,CAAC,CAAC;;IAGFJ,gBAAgB,CAACxC,KAAK,CAAC,CAAC,CAAC;;IAEzB,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,CAACa,SAAS,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;MAC/C,IAAI2B,MAAM,GAAGD,MAAM,CAAC1B,CAAC,CAAC;MAEtB,IAAI2B,MAAM,YAAYnB,KAAK,EAAE;QAC3B1B,KAAK,CAACa,SAAS,CAACK,CAAC,CAAC,CAACN,MAAM,CAACiC,MAAM,CAAC;MACnC,CAAC,MAAM;QACL7C,KAAK,CAACa,SAAS,CAACK,CAAC,CAAC,CAACV,OAAO,CAACqC,MAAM,CAAC;MACpC;IACF;EACF,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,UAAUzB,KAAK,EAAE;IAC3BuB,cAAc,CAACR,MAAM,EAAEnC,KAAK,EAAEoB,KAAK,CAAC;EACtC,CAAC,CAAC;AACJ,CAAC,CAAC;AACF;;AAGA,SAASuB,cAAcA,CAACR,MAAM,EAAEnC,KAAK,EAAEoB,KAAK,EAAE;EAC5C;EACAoB,gBAAgB,CAACxC,KAAK,CAAC;EAEvB,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,CAACU,IAAI,CAACS,MAAM,EAAED,CAAC,EAAE,EAAE;IAC1CiB,MAAM,CAACb,KAAK,CAACtB,KAAK,CAACU,IAAI,CAACQ,CAAC,CAAC,CAAC;IAC3BlB,KAAK,CAACa,SAAS,CAACK,CAAC,CAAC,CAACN,MAAM,CAACQ,KAAK,CAAC;EAClC;AACF,CAAC,CAAC;;AAGF,SAASoB,gBAAgBA,CAACxC,KAAK,EAAE;EAC/B,IAAIA,KAAK,CAACM,SAAS,EAAE;IACnB,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,CAACM,SAAS,CAACa,MAAM,EAAED,CAAC,EAAE,EAAE;MAC/ClB,KAAK,CAACM,SAAS,CAACY,CAAC,CAAC,CAAC,CAAC;IACtB;EACF;AACF,CAAC,CAAC;;AAGF,SAASlC,oBAAoBA,CAACJ,OAAO,EAAE;EACrC,IAAIkE,WAAW,GAAG,CAAClE,OAAO,IAAIA,OAAO,CAACoB,KAAK,KAAK,KAAK;EAErD,IAAI,CAAC8C,WAAW,EAAE;IAChB,OAAO,CAAC;EACV;EAEA,IAAIC,YAAY,GAAGnE,OAAO,IAAIA,OAAO,CAACmE,YAAY;EAElD,IAAIA,YAAY,KAAKjD,SAAS,EAAE;IAC9B,OAAOkD,QAAQ;EACjB;EAEA,IAAI,OAAOD,YAAY,KAAK,QAAQ,IAAIA,YAAY,GAAG,CAAC,EAAE;IACxD,MAAM,IAAIlE,SAAS,CAAC,0CAA0C,GAAGkE,YAAY,CAAC;EAChF;EAEA,OAAOA,YAAY;AACrB,CAAC,CAAC;;AAGF,SAAS7D,uBAAuBA,CAACN,OAAO,EAAE;EACxC,IAAIqE,eAAe,GAAGrE,OAAO,IAAIA,OAAO,CAACqE,eAAe;EAExD,IAAIA,eAAe,KAAKnD,SAAS,EAAE;IACjC,OAAO6B,qBAAqB;EAC9B;EAEA,IAAI,OAAOsB,eAAe,KAAK,UAAU,EAAE;IACzC,MAAM,IAAIpE,SAAS,CAAC,sCAAsC,GAAGoE,eAAe,CAAC;EAC/E;EAEA,OAAOA,eAAe;AACxB,CAAC,CAAC;;AAGF,SAAS7D,kBAAkBA,CAACR,OAAO,EAAE;EACnC,IAAIsE,UAAU,GAAGtE,OAAO,IAAIA,OAAO,CAACsE,UAAU;EAE9C,IAAIA,UAAU,KAAKpD,SAAS,EAAE;IAC5B,OAAO,UAAUD,GAAG,EAAE;MACpB,OAAOA,GAAG;IACZ,CAAC;EACH;EAEA,IAAI,OAAOqD,UAAU,KAAK,UAAU,EAAE;IACpC,MAAM,IAAIrE,SAAS,CAAC,iCAAiC,GAAGqE,UAAU,CAAC;EACrE;EAEA,OAAOA,UAAU;AACnB,CAAC,CAAC;;AAGF,SAAS5D,gBAAgBA,CAACV,OAAO,EAAE;EACjC,IAAIuE,WAAW,GAAG,CAACvE,OAAO,IAAIA,OAAO,CAACwE,KAAK,KAAK,KAAK;EAErD,IAAI,CAACD,WAAW,EAAE;IAChB,OAAO,IAAI;EACb;EAEA,IAAIjD,QAAQ,GAAGtB,OAAO,IAAIA,OAAO,CAACsB,QAAQ;EAE1C,IAAIA,QAAQ,KAAKJ,SAAS,EAAE;IAC1B,OAAO,IAAIuD,GAAG,CAAC,CAAC;EAClB;EAEA,IAAInD,QAAQ,KAAK,IAAI,EAAE;IACrB,IAAIoD,cAAc,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC;IACtD,IAAIC,gBAAgB,GAAGD,cAAc,CAACE,MAAM,CAAC,UAAUC,MAAM,EAAE;MAC7D,OAAOvD,QAAQ,IAAI,OAAOA,QAAQ,CAACuD,MAAM,CAAC,KAAK,UAAU;IAC3D,CAAC,CAAC;IAEF,IAAIF,gBAAgB,CAACpC,MAAM,KAAK,CAAC,EAAE;MACjC,MAAM,IAAItC,SAAS,CAAC,mCAAmC,GAAG0E,gBAAgB,CAACG,IAAI,CAAC,IAAI,CAAC,CAAC;IACxF;EACF;EAEA,OAAOxD,QAAQ;AACjB;AAEA,SAAST,YAAYA,CAACb,OAAO,EAAE;EAC7B,IAAIA,OAAO,IAAIA,OAAO,CAACY,IAAI,EAAE;IAC3B,OAAOZ,OAAO,CAACY,IAAI;EACrB;EAEA,OAAO,IAAI;AACb,CAAC,CAAC;;AAGF,SAASwB,WAAWA,CAAC2C,CAAC,EAAE;EACtB,OAAO,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,KAAK,IAAI,IAAI,OAAOA,CAAC,CAACxC,MAAM,KAAK,QAAQ,KAAKwC,CAAC,CAACxC,MAAM,KAAK,CAAC,IAAIwC,CAAC,CAACxC,MAAM,GAAG,CAAC,IAAIyC,MAAM,CAACjE,SAAS,CAACkE,cAAc,CAACC,IAAI,CAACH,CAAC,EAAEA,CAAC,CAACxC,MAAM,GAAG,CAAC,CAAC,CAAC;AACzK;AAEA4C,MAAM,CAACC,OAAO,GAAGtF,UAAU","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}