{"ast":null,"code":"import { Address, beginCell, Cell, toNano } from '@ton/core';\nimport { TonClient } from '@ton/ton';\n\n// Contract configuration\nexport const JACKPOT_CONTRACT_CONFIG = {\n  // ‚ö†Ô∏è IMPORTANT: Replace this with your actual deployed contract address!\n  // This is just a placeholder - transactions will fail with wrong address\n  address: process.env.REACT_APP_CONTRACT_ADDRESS || \"REPLACE_WITH_YOUR_ACTUAL_CONTRACT_ADDRESS\",\n  // Admin configuration - in production, use environment variables\n  adminMnemonic: \"cabin flame border diary parent web extend stable hungry cabin alley cable bulk nasty learn toe recipe pluck memory twist wheel boost execute caution\".split(' ') || [],\n  // TON Client configuration\n  endpoint: process.env.REACT_APP_TON_ENDPOINT || 'https://toncenter.com/api/v2/jsonRPC',\n  apiKey: \"cb6a181146fafbe2adc51d3a21d27341aa8a93cbf581e03a80e9e7203a3abd65\"\n};\n\n// Message constructors for contract interactions\nexport const ContractMessages = {\n  // Admin messages\n  startJackpot: (queryId = 0) => {\n    return beginCell().storeUint(0x12345678, 32) // Replace with actual op code\n    .storeUint(queryId, 64).endCell();\n  },\n  endJackpot: (queryId = 0) => {\n    return beginCell().storeUint(0x87654321, 32) // Replace with actual op code  \n    .storeUint(queryId, 64).endCell();\n  },\n  placeBet: (queryId = 0) => {\n    return beginCell().storeUint(0x03, 32) // PlaceBet opcode as specified in contract\n    .storeUint(queryId, 64) // query_id as uint64\n    .endCell();\n  }\n};\nexport class JackpotContract {\n  constructor() {\n    this.client = new TonClient({\n      endpoint: JACKPOT_CONTRACT_CONFIG.endpoint,\n      apiKey: JACKPOT_CONTRACT_CONFIG.apiKey\n    });\n    this.contractAddress = Address.parse(\"EQAO-eknIHULYsinQdpEb8oPVQy6eUXz0-zAPTKi1QTAJkjo\");\n\n    // Debug contract address on initialization\n    console.log('üèóÔ∏è JackpotContract initialized:', {\n      configAddress: JACKPOT_CONTRACT_CONFIG.address,\n      parsedAddress: this.contractAddress.toString(),\n      fromEnv: !!process.env.REACT_APP_CONTRACT_ADDRESS\n    });\n  }\n\n  // Contract getters - these call the smart contract's get methods\n  async getTotalJackpot() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getTotalJackpot\");\n\n      // Parse the result from stack\n      const jackpotAmount = result.stack.readBigNumber();\n      return Number(jackpotAmount) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching jackpot amount:', error);\n      return 0;\n    }\n  }\n  async isJackpotActive() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"isJackpotActive\");\n      return result.stack.readBoolean();\n    } catch (error) {\n      console.error('Error fetching jackpot status:', error);\n      return false;\n    }\n  }\n  async getBetCount() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getBetCount\");\n      return result.stack.readNumber();\n    } catch (error) {\n      console.error('Error fetching bet count:', error);\n      return 0;\n    }\n  }\n  async getBettorAmount(bettorAddress) {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getBettorAmount\", [{\n        type: 'slice',\n        cell: beginCell().storeAddress(Address.parse(bettorAddress)).endCell()\n      }]);\n      const amount = result.stack.readBigNumber();\n      return Number(amount) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching bettor amount:', error);\n      return 0;\n    }\n  }\n  async getWinningProbability(bettorAddress) {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getWinningProbability\", [{\n        type: 'slice',\n        cell: beginCell().storeAddress(Address.parse(bettorAddress)).endCell()\n      }]);\n      const probability = result.stack.readNumber();\n      return probability / 100; // Convert from basis points to percentage\n    } catch (error) {\n      console.error('Error fetching winning probability:', error);\n      return 0;\n    }\n  }\n  async getAllBettors() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getAllBettors\");\n\n      // Parse the dictionary result\n      // This will return a map of addresses to amounts\n      const bettorsDict = result.stack.readCellOpt();\n      if (!bettorsDict) return {};\n\n      // Parse the dictionary - implementation depends on exact contract structure\n      // For now, return empty object - you'll need to implement dictionary parsing\n      return {};\n    } catch (error) {\n      console.error('Error fetching all bettors:', error);\n      return {};\n    }\n  }\n  async getLastWinner() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getLastWinner\");\n      const winnerCell = result.stack.readCellOpt();\n      if (!winnerCell) return null;\n\n      // Parse address from cell\n      const slice = winnerCell.beginParse();\n      const winnerAddress = slice.loadAddress();\n      return winnerAddress === null || winnerAddress === void 0 ? void 0 : winnerAddress.toString();\n    } catch (error) {\n      console.error('Error fetching last winner:', error);\n      return null;\n    }\n  }\n  async getLastPrizeAmount() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getLastPrizeAmount\");\n      const prizeAmount = result.stack.readBigNumber();\n      return Number(prizeAmount) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching last prize amount:', error);\n      return 0;\n    }\n  }\n  async getContractBalance() {\n    try {\n      const result = await this.client.runMethod(this.contractAddress, \"getBalance\");\n      const balance = result.stack.readBigNumber();\n      return Number(balance) / 1e9; // Convert from nanotons to TON\n    } catch (error) {\n      console.error('Error fetching contract balance:', error);\n      return 0;\n    }\n  }\n\n  // Transaction builders for sending to the contract\n  buildBetTransaction(betAmount, senderAddress) {\n    const betAmountNano = toNano(betAmount.toString());\n    // Generate unique query_id for this bet\n    const queryId = Date.now() * 1000 + Math.floor(Math.random() * 1000);\n    console.log(`üîß Building bet transaction:`, {\n      betAmount: betAmount + ' TON',\n      betAmountNano: betAmountNano.toString(),\n      queryId,\n      senderAddress,\n      contractAddress: this.contractAddress.toString(),\n      // Check if contract address equals sender address (this would be wrong!)\n      addressesMatch: this.contractAddress.toString() === senderAddress,\n      usingEnvAddress: !!process.env.REACT_APP_CONTRACT_ADDRESS\n    });\n    const payload = ContractMessages.placeBet(queryId);\n    console.log(`üì¶ PlaceBet message payload:`, payload.toBoc().toString('base64'));\n\n    // Verify the message structure immediately\n    try {\n      const cell = payload;\n      const slice = cell.beginParse();\n      const opCode = slice.loadUint(32);\n      const decodedQueryId = slice.loadUint(64);\n      console.log(`‚úÖ Message verification:`, {\n        opCode: `0x${opCode.toString(16).padStart(2, '0')}`,\n        queryId: decodedQueryId,\n        isCorrectOpCode: opCode === 0x03,\n        matches: queryId === decodedQueryId\n      });\n    } catch (error) {\n      console.error('‚ùå Message verification failed:', error);\n    }\n    const transaction = {\n      validUntil: Math.floor(Date.now() / 1000) + 600,\n      // 10 minutes\n      messages: [{\n        address: this.contractAddress.toString(),\n        amount: betAmountNano.toString(),\n        payload: payload.toBoc().toString('base64')\n      }]\n    };\n    console.log(`üéØ Final transaction will be sent to:`, {\n      destinationAddress: transaction.messages[0].address,\n      amount: transaction.messages[0].amount + ' nanotons',\n      amountTON: betAmount + ' TON',\n      senderAddress: senderAddress,\n      isGoingToContract: transaction.messages[0].address !== senderAddress\n    });\n    return transaction;\n  }\n  buildStartJackpotTransaction() {\n    return {\n      validUntil: Math.floor(Date.now() / 1000) + 600,\n      // 10 minutes\n      messages: [{\n        address: this.contractAddress.toString(),\n        amount: toNano('0.05').toString(),\n        // Gas fee\n        payload: ContractMessages.startJackpot(Date.now()).toBoc().toString('base64')\n      }]\n    };\n  }\n  buildEndJackpotTransaction() {\n    return {\n      validUntil: Math.floor(Date.now() / 1000) + 600,\n      // 10 minutes\n      messages: [{\n        address: this.contractAddress.toString(),\n        amount: toNano('0.05').toString(),\n        // Gas fee\n        payload: ContractMessages.endJackpot(Date.now()).toBoc().toString('base64')\n      }]\n    };\n  }\n\n  // Utility method to get comprehensive contract state\n  async getContractState() {\n    try {\n      const [totalJackpot, isActive, betCount, lastWinner, lastPrizeAmount, contractBalance] = await Promise.all([this.getTotalJackpot(), this.isJackpotActive(), this.getBetCount(), this.getLastWinner(), this.getLastPrizeAmount(), this.getContractBalance()]);\n      return {\n        totalJackpot,\n        isActive,\n        betCount,\n        lastWinner,\n        lastPrizeAmount,\n        contractBalance,\n        timestamp: Date.now()\n      };\n    } catch (error) {\n      console.error('Error fetching contract state:', error);\n      return {\n        totalJackpot: 0,\n        isActive: false,\n        betCount: 0,\n        lastWinner: null,\n        lastPrizeAmount: 0,\n        contractBalance: 0,\n        timestamp: Date.now(),\n        error: error.message\n      };\n    }\n  }\n}\n\n// Create a singleton instance\nexport const jackpotContract = new JackpotContract();\n\n// Export utility functions\nexport const formatTonAmount = amount => {\n  return Number(amount).toFixed(3);\n};\nexport const formatAddress = address => {\n  if (!address) return '';\n  return `${address.slice(0, 6)}...${address.slice(-4)}`;\n};\n\n// Utility function to decode and verify PlaceBet message\nexport const decodePlaceBetMessage = base64Payload => {\n  try {\n    const cell = Cell.fromBase64(base64Payload);\n    const slice = cell.beginParse();\n    const opCode = slice.loadUint(32);\n    const queryId = slice.loadUint(64);\n    console.log(`üîç Decoded PlaceBet message:`, {\n      opCode: `0x${opCode.toString(16).padStart(2, '0')}`,\n      queryId,\n      isCorrectOpCode: opCode === 0x03\n    });\n    return {\n      opCode,\n      queryId,\n      isValid: opCode === 0x03\n    };\n  } catch (error) {\n    console.error('Error decoding PlaceBet message:', error);\n    return null;\n  }\n};","map":{"version":3,"names":["Address","beginCell","Cell","toNano","TonClient","JACKPOT_CONTRACT_CONFIG","address","process","env","REACT_APP_CONTRACT_ADDRESS","adminMnemonic","split","endpoint","REACT_APP_TON_ENDPOINT","apiKey","ContractMessages","startJackpot","queryId","storeUint","endCell","endJackpot","placeBet","JackpotContract","constructor","client","contractAddress","parse","console","log","configAddress","parsedAddress","toString","fromEnv","getTotalJackpot","result","runMethod","jackpotAmount","stack","readBigNumber","Number","error","isJackpotActive","readBoolean","getBetCount","readNumber","getBettorAmount","bettorAddress","type","cell","storeAddress","amount","getWinningProbability","probability","getAllBettors","bettorsDict","readCellOpt","getLastWinner","winnerCell","slice","beginParse","winnerAddress","loadAddress","getLastPrizeAmount","prizeAmount","getContractBalance","balance","buildBetTransaction","betAmount","senderAddress","betAmountNano","Date","now","Math","floor","random","addressesMatch","usingEnvAddress","payload","toBoc","opCode","loadUint","decodedQueryId","padStart","isCorrectOpCode","matches","transaction","validUntil","messages","destinationAddress","amountTON","isGoingToContract","buildStartJackpotTransaction","buildEndJackpotTransaction","getContractState","totalJackpot","isActive","betCount","lastWinner","lastPrizeAmount","contractBalance","Promise","all","timestamp","message","jackpotContract","formatTonAmount","toFixed","formatAddress","decodePlaceBetMessage","base64Payload","fromBase64","isValid"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/src/services/jackpotContract.js"],"sourcesContent":["import { Address, beginCell, Cell, toNano } from '@ton/core';\r\nimport { TonClient } from '@ton/ton';\r\n\r\n// Contract configuration\r\nexport const JACKPOT_CONTRACT_CONFIG = {\r\n  // ‚ö†Ô∏è IMPORTANT: Replace this with your actual deployed contract address!\r\n  // This is just a placeholder - transactions will fail with wrong address\r\n  address: process.env.REACT_APP_CONTRACT_ADDRESS || \"REPLACE_WITH_YOUR_ACTUAL_CONTRACT_ADDRESS\",\r\n  \r\n  // Admin configuration - in production, use environment variables\r\n  adminMnemonic: \"cabin flame border diary parent web extend stable hungry cabin alley cable bulk nasty learn toe recipe pluck memory twist wheel boost execute caution\".split(' ') || [],\r\n  \r\n  // TON Client configuration\r\n  endpoint: process.env.REACT_APP_TON_ENDPOINT || 'https://toncenter.com/api/v2/jsonRPC',\r\n  apiKey: \"cb6a181146fafbe2adc51d3a21d27341aa8a93cbf581e03a80e9e7203a3abd65\"\r\n};\r\n\r\n// Message constructors for contract interactions\r\nexport const ContractMessages = {\r\n  // Admin messages\r\n  startJackpot: (queryId = 0) => {\r\n    return beginCell()\r\n      .storeUint(0x12345678, 32) // Replace with actual op code\r\n      .storeUint(queryId, 64)\r\n      .endCell();\r\n  },\r\n\r\n  endJackpot: (queryId = 0) => {\r\n    return beginCell()\r\n      .storeUint(0x87654321, 32) // Replace with actual op code  \r\n      .storeUint(queryId, 64)\r\n      .endCell();\r\n  },\r\n\r\n  placeBet: (queryId = 0) => {\r\n    return beginCell()\r\n      .storeUint(0x03, 32) // PlaceBet opcode as specified in contract\r\n      .storeUint(queryId, 64) // query_id as uint64\r\n      .endCell();\r\n  }\r\n};\r\n\r\nexport class JackpotContract {\r\n  constructor() {\r\n    this.client = new TonClient({\r\n      endpoint: JACKPOT_CONTRACT_CONFIG.endpoint,\r\n      apiKey: JACKPOT_CONTRACT_CONFIG.apiKey\r\n    });\r\n    \r\n    this.contractAddress = Address.parse(\"EQAO-eknIHULYsinQdpEb8oPVQy6eUXz0-zAPTKi1QTAJkjo\");\r\n    \r\n    // Debug contract address on initialization\r\n    console.log('üèóÔ∏è JackpotContract initialized:', {\r\n      configAddress: JACKPOT_CONTRACT_CONFIG.address,\r\n      parsedAddress: this.contractAddress.toString(),\r\n      fromEnv: !!process.env.REACT_APP_CONTRACT_ADDRESS\r\n    });\r\n  }\r\n\r\n  // Contract getters - these call the smart contract's get methods\r\n  async getTotalJackpot() {\r\n    try {\r\n      const result = await this.client.runMethod(\r\n        this.contractAddress,\r\n        \"getTotalJackpot\"\r\n      );\r\n      \r\n      // Parse the result from stack\r\n      const jackpotAmount = result.stack.readBigNumber();\r\n      return Number(jackpotAmount) / 1e9; // Convert from nanotons to TON\r\n    } catch (error) {\r\n      console.error('Error fetching jackpot amount:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  async isJackpotActive() {\r\n    try {\r\n      const result = await this.client.runMethod(\r\n        this.contractAddress,\r\n        \"isJackpotActive\"\r\n      );\r\n      \r\n      return result.stack.readBoolean();\r\n    } catch (error) {\r\n      console.error('Error fetching jackpot status:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async getBetCount() {\r\n    try {\r\n      const result = await this.client.runMethod(\r\n        this.contractAddress,\r\n        \"getBetCount\"\r\n      );\r\n      \r\n      return result.stack.readNumber();\r\n    } catch (error) {\r\n      console.error('Error fetching bet count:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  async getBettorAmount(bettorAddress) {\r\n    try {\r\n      const result = await this.client.runMethod(\r\n        this.contractAddress,\r\n        \"getBettorAmount\",\r\n        [\r\n          { type: 'slice', cell: beginCell().storeAddress(Address.parse(bettorAddress)).endCell() }\r\n        ]\r\n      );\r\n      \r\n      const amount = result.stack.readBigNumber();\r\n      return Number(amount) / 1e9; // Convert from nanotons to TON\r\n    } catch (error) {\r\n      console.error('Error fetching bettor amount:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  async getWinningProbability(bettorAddress) {\r\n    try {\r\n      const result = await this.client.runMethod(\r\n        this.contractAddress,\r\n        \"getWinningProbability\",\r\n        [\r\n          { type: 'slice', cell: beginCell().storeAddress(Address.parse(bettorAddress)).endCell() }\r\n        ]\r\n      );\r\n      \r\n      const probability = result.stack.readNumber();\r\n      return probability / 100; // Convert from basis points to percentage\r\n    } catch (error) {\r\n      console.error('Error fetching winning probability:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  async getAllBettors() {\r\n    try {\r\n      const result = await this.client.runMethod(\r\n        this.contractAddress,\r\n        \"getAllBettors\"\r\n      );\r\n      \r\n      // Parse the dictionary result\r\n      // This will return a map of addresses to amounts\r\n      const bettorsDict = result.stack.readCellOpt();\r\n      \r\n      if (!bettorsDict) return {};\r\n      \r\n      // Parse the dictionary - implementation depends on exact contract structure\r\n      // For now, return empty object - you'll need to implement dictionary parsing\r\n      return {};\r\n    } catch (error) {\r\n      console.error('Error fetching all bettors:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async getLastWinner() {\r\n    try {\r\n      const result = await this.client.runMethod(\r\n        this.contractAddress,\r\n        \"getLastWinner\"\r\n      );\r\n      \r\n      const winnerCell = result.stack.readCellOpt();\r\n      if (!winnerCell) return null;\r\n      \r\n      // Parse address from cell\r\n      const slice = winnerCell.beginParse();\r\n      const winnerAddress = slice.loadAddress();\r\n      \r\n      return winnerAddress?.toString();\r\n    } catch (error) {\r\n      console.error('Error fetching last winner:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getLastPrizeAmount() {\r\n    try {\r\n      const result = await this.client.runMethod(\r\n        this.contractAddress,\r\n        \"getLastPrizeAmount\"\r\n      );\r\n      \r\n      const prizeAmount = result.stack.readBigNumber();\r\n      return Number(prizeAmount) / 1e9; // Convert from nanotons to TON\r\n    } catch (error) {\r\n      console.error('Error fetching last prize amount:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  async getContractBalance() {\r\n    try {\r\n      const result = await this.client.runMethod(\r\n        this.contractAddress,\r\n        \"getBalance\"\r\n      );\r\n      \r\n      const balance = result.stack.readBigNumber();\r\n      return Number(balance) / 1e9; // Convert from nanotons to TON\r\n    } catch (error) {\r\n      console.error('Error fetching contract balance:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // Transaction builders for sending to the contract\r\n  buildBetTransaction(betAmount, senderAddress) {\r\n    const betAmountNano = toNano(betAmount.toString());\r\n    // Generate unique query_id for this bet\r\n    const queryId = Date.now() * 1000 + Math.floor(Math.random() * 1000);\r\n    \r\n    console.log(`üîß Building bet transaction:`, {\r\n      betAmount: betAmount + ' TON',\r\n      betAmountNano: betAmountNano.toString(),\r\n      queryId,\r\n      senderAddress,\r\n      contractAddress: this.contractAddress.toString(),\r\n      // Check if contract address equals sender address (this would be wrong!)\r\n      addressesMatch: this.contractAddress.toString() === senderAddress,\r\n      usingEnvAddress: !!process.env.REACT_APP_CONTRACT_ADDRESS\r\n    });\r\n    \r\n    const payload = ContractMessages.placeBet(queryId);\r\n    console.log(`üì¶ PlaceBet message payload:`, payload.toBoc().toString('base64'));\r\n    \r\n    // Verify the message structure immediately\r\n    try {\r\n      const cell = payload;\r\n      const slice = cell.beginParse();\r\n      const opCode = slice.loadUint(32);\r\n      const decodedQueryId = slice.loadUint(64);\r\n      \r\n      console.log(`‚úÖ Message verification:`, {\r\n        opCode: `0x${opCode.toString(16).padStart(2, '0')}`,\r\n        queryId: decodedQueryId,\r\n        isCorrectOpCode: opCode === 0x03,\r\n        matches: queryId === decodedQueryId\r\n      });\r\n    } catch (error) {\r\n      console.error('‚ùå Message verification failed:', error);\r\n    }\r\n    \r\n    const transaction = {\r\n      validUntil: Math.floor(Date.now() / 1000) + 600, // 10 minutes\r\n      messages: [\r\n        {\r\n          address: this.contractAddress.toString(),\r\n          amount: betAmountNano.toString(),\r\n          payload: payload.toBoc().toString('base64')\r\n        }\r\n      ]\r\n    };\r\n    \r\n    console.log(`üéØ Final transaction will be sent to:`, {\r\n      destinationAddress: transaction.messages[0].address,\r\n      amount: transaction.messages[0].amount + ' nanotons',\r\n      amountTON: betAmount + ' TON',\r\n      senderAddress: senderAddress,\r\n      isGoingToContract: transaction.messages[0].address !== senderAddress\r\n    });\r\n    \r\n    return transaction;\r\n  }\r\n\r\n  buildStartJackpotTransaction() {\r\n    return {\r\n      validUntil: Math.floor(Date.now() / 1000) + 600, // 10 minutes\r\n      messages: [\r\n        {\r\n          address: this.contractAddress.toString(),\r\n          amount: toNano('0.05').toString(), // Gas fee\r\n          payload: ContractMessages.startJackpot(Date.now()).toBoc().toString('base64')\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  buildEndJackpotTransaction() {\r\n    return {\r\n      validUntil: Math.floor(Date.now() / 1000) + 600, // 10 minutes\r\n      messages: [\r\n        {\r\n          address: this.contractAddress.toString(),\r\n          amount: toNano('0.05').toString(), // Gas fee\r\n          payload: ContractMessages.endJackpot(Date.now()).toBoc().toString('base64')\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  // Utility method to get comprehensive contract state\r\n  async getContractState() {\r\n    try {\r\n      const [\r\n        totalJackpot,\r\n        isActive,\r\n        betCount,\r\n        lastWinner,\r\n        lastPrizeAmount,\r\n        contractBalance\r\n      ] = await Promise.all([\r\n        this.getTotalJackpot(),\r\n        this.isJackpotActive(),\r\n        this.getBetCount(),\r\n        this.getLastWinner(),\r\n        this.getLastPrizeAmount(),\r\n        this.getContractBalance()\r\n      ]);\r\n\r\n      return {\r\n        totalJackpot,\r\n        isActive,\r\n        betCount,\r\n        lastWinner,\r\n        lastPrizeAmount,\r\n        contractBalance,\r\n        timestamp: Date.now()\r\n      };\r\n    } catch (error) {\r\n      console.error('Error fetching contract state:', error);\r\n      return {\r\n        totalJackpot: 0,\r\n        isActive: false,\r\n        betCount: 0,\r\n        lastWinner: null,\r\n        lastPrizeAmount: 0,\r\n        contractBalance: 0,\r\n        timestamp: Date.now(),\r\n        error: error.message\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Create a singleton instance\r\nexport const jackpotContract = new JackpotContract();\r\n\r\n// Export utility functions\r\nexport const formatTonAmount = (amount) => {\r\n  return Number(amount).toFixed(3);\r\n};\r\n\r\nexport const formatAddress = (address) => {\r\n  if (!address) return '';\r\n  return `${address.slice(0, 6)}...${address.slice(-4)}`;\r\n};\r\n\r\n// Utility function to decode and verify PlaceBet message\r\nexport const decodePlaceBetMessage = (base64Payload) => {\r\n  try {\r\n    const cell = Cell.fromBase64(base64Payload);\r\n    const slice = cell.beginParse();\r\n    \r\n    const opCode = slice.loadUint(32);\r\n    const queryId = slice.loadUint(64);\r\n    \r\n    console.log(`üîç Decoded PlaceBet message:`, {\r\n      opCode: `0x${opCode.toString(16).padStart(2, '0')}`,\r\n      queryId,\r\n      isCorrectOpCode: opCode === 0x03\r\n    });\r\n    \r\n    return {\r\n      opCode,\r\n      queryId,\r\n      isValid: opCode === 0x03\r\n    };\r\n  } catch (error) {\r\n    console.error('Error decoding PlaceBet message:', error);\r\n    return null;\r\n  }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}