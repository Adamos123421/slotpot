{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Cell = void 0;\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nconst BitString_1 = require(\"./BitString\");\nconst CellType_1 = require(\"./CellType\");\nconst Slice_1 = require(\"./Slice\");\nconst resolveExotic_1 = require(\"./cell/resolveExotic\");\nconst wonderCalculator_1 = require(\"./cell/wonderCalculator\");\nconst serialization_1 = require(\"./cell/serialization\");\nconst BitReader_1 = require(\"./BitReader\");\nconst Builder_1 = require(\"./Builder\");\n/**\n * Cell as described in TVM spec\n */\nclass Cell {\n  /**\n   * Deserialize cells from BOC\n   * @param src source buffer\n   * @returns array of cells\n   */\n  static fromBoc(src) {\n    return (0, serialization_1.deserializeBoc)(src);\n  }\n  /**\n   * Helper class that deserializes a single cell from BOC in base64\n   * @param src source string\n   */\n  static fromBase64(src) {\n    let parsed = Cell.fromBoc(Buffer.from(src, 'base64'));\n    if (parsed.length !== 1) {\n      throw new Error(\"Deserialized more than one cell\");\n    }\n    return parsed[0];\n  }\n  constructor(opts) {\n    // Level and depth information\n    this._hashes = [];\n    this._depths = [];\n    /**\n     * Beging cell parsing\n     * @returns a new slice\n     */\n    this.beginParse = (allowExotic = false) => {\n      if (this.isExotic && !allowExotic) {\n        throw new Error(\"Exotic cells cannot be parsed\");\n      }\n      return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);\n    };\n    /**\n     * Get cell hash\n     * @param level level\n     * @returns cell hash\n     */\n    this.hash = (level = 3) => {\n      return this._hashes[Math.min(this._hashes.length - 1, level)];\n    };\n    /**\n     * Get cell depth\n     * @param level level\n     * @returns cell depth\n     */\n    this.depth = (level = 3) => {\n      return this._depths[Math.min(this._depths.length - 1, level)];\n    };\n    /**\n     * Get cell level\n     * @returns cell level\n     */\n    this.level = () => {\n      return this.mask.level;\n    };\n    /**\n     * Checks cell to be euqal to another cell\n     * @param other other cell\n     * @returns true if cells are equal\n     */\n    this.equals = other => {\n      return this.hash().equals(other.hash());\n    };\n    this[_a] = () => this.toString();\n    // Resolve bits\n    let bits = BitString_1.BitString.EMPTY;\n    if (opts && opts.bits) {\n      bits = opts.bits;\n    }\n    // Resolve refs\n    let refs = [];\n    if (opts && opts.refs) {\n      refs = [...opts.refs];\n    }\n    // Resolve type\n    let hashes;\n    let depths;\n    let mask;\n    let type = CellType_1.CellType.Ordinary;\n    if (opts && opts.exotic) {\n      // Resolve exotic cell\n      let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);\n      // Perform wonders\n      let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);\n      // Copy results\n      mask = wonders.mask;\n      depths = wonders.depths;\n      hashes = wonders.hashes;\n      type = resolved.type;\n    } else {\n      // Check correctness\n      if (refs.length > 4) {\n        throw new Error(\"Invalid number of references\");\n      }\n      if (bits.length > 1023) {\n        throw new Error(`Bits overflow: ${bits.length} > 1023`);\n      }\n      // Perform wonders\n      let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);\n      // Copy results\n      mask = wonders.mask;\n      depths = wonders.depths;\n      hashes = wonders.hashes;\n      type = CellType_1.CellType.Ordinary;\n    }\n    // Set fields\n    this.type = type;\n    this.bits = bits;\n    this.refs = refs;\n    this.mask = mask;\n    this._depths = depths;\n    this._hashes = hashes;\n    Object.freeze(this);\n    Object.freeze(this.refs);\n    Object.freeze(this.bits);\n    Object.freeze(this.mask);\n    Object.freeze(this._depths);\n    Object.freeze(this._hashes);\n  }\n  /**\n   * Check if cell is exotic\n   */\n  get isExotic() {\n    return this.type !== CellType_1.CellType.Ordinary;\n  }\n  /**\n   * Serializes cell to BOC\n   * @param opts options\n   */\n  toBoc(opts) {\n    let idx = opts && opts.idx !== null && opts.idx !== undefined ? opts.idx : false;\n    let crc32 = opts && opts.crc32 !== null && opts.crc32 !== undefined ? opts.crc32 : true;\n    return (0, serialization_1.serializeBoc)(this, {\n      idx,\n      crc32\n    });\n  }\n  /**\n   * Format cell to string\n   * @param indent indentation\n   * @returns string representation\n   */\n  toString(indent) {\n    let id = indent || '';\n    let t = 'x';\n    if (this.isExotic) {\n      if (this.type === CellType_1.CellType.MerkleProof) {\n        t = 'p';\n      } else if (this.type === CellType_1.CellType.MerkleUpdate) {\n        t = 'u';\n      } else if (this.type === CellType_1.CellType.PrunedBranch) {\n        t = 'p';\n      }\n    }\n    let s = id + (this.isExotic ? t : 'x') + '{' + this.bits.toString() + '}';\n    for (let k in this.refs) {\n      const i = this.refs[k];\n      s += '\\n' + i.toString(id + ' ');\n    }\n    return s;\n  }\n  /**\n   * Covnert cell to slice\n   * @returns slice\n   */\n  asSlice() {\n    return this.beginParse();\n  }\n  /**\n   * Convert cell to a builder that has this cell stored\n   * @returns builder\n   */\n  asBuilder() {\n    return (0, Builder_1.beginCell)().storeSlice(this.asSlice());\n  }\n}\nexports.Cell = Cell;\n_a = symbol_inspect_1.default;\nCell.EMPTY = new Cell();","map":{"version":3,"names":["__importDefault","mod","__esModule","_a","Object","defineProperty","exports","value","Cell","symbol_inspect_1","require","BitString_1","CellType_1","Slice_1","resolveExotic_1","wonderCalculator_1","serialization_1","BitReader_1","Builder_1","fromBoc","src","deserializeBoc","fromBase64","parsed","Buffer","from","length","Error","constructor","opts","_hashes","_depths","beginParse","allowExotic","isExotic","Slice","BitReader","bits","refs","hash","level","Math","min","depth","mask","equals","other","toString","BitString","EMPTY","hashes","depths","type","CellType","Ordinary","exotic","resolved","resolveExotic","wonders","wonderCalculator","freeze","toBoc","idx","undefined","crc32","serializeBoc","indent","id","t","MerkleProof","MerkleUpdate","PrunedBranch","s","k","i","asSlice","asBuilder","beginCell","storeSlice","default"],"sources":["C:/Users/adams/Downloads/GLL/slotpot/node_modules/@ton/core/dist/boc/Cell.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Cell = void 0;\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nconst BitString_1 = require(\"./BitString\");\nconst CellType_1 = require(\"./CellType\");\nconst Slice_1 = require(\"./Slice\");\nconst resolveExotic_1 = require(\"./cell/resolveExotic\");\nconst wonderCalculator_1 = require(\"./cell/wonderCalculator\");\nconst serialization_1 = require(\"./cell/serialization\");\nconst BitReader_1 = require(\"./BitReader\");\nconst Builder_1 = require(\"./Builder\");\n/**\n * Cell as described in TVM spec\n */\nclass Cell {\n    /**\n     * Deserialize cells from BOC\n     * @param src source buffer\n     * @returns array of cells\n     */\n    static fromBoc(src) {\n        return (0, serialization_1.deserializeBoc)(src);\n    }\n    /**\n     * Helper class that deserializes a single cell from BOC in base64\n     * @param src source string\n     */\n    static fromBase64(src) {\n        let parsed = Cell.fromBoc(Buffer.from(src, 'base64'));\n        if (parsed.length !== 1) {\n            throw new Error(\"Deserialized more than one cell\");\n        }\n        return parsed[0];\n    }\n    constructor(opts) {\n        // Level and depth information\n        this._hashes = [];\n        this._depths = [];\n        /**\n         * Beging cell parsing\n         * @returns a new slice\n         */\n        this.beginParse = (allowExotic = false) => {\n            if (this.isExotic && !allowExotic) {\n                throw new Error(\"Exotic cells cannot be parsed\");\n            }\n            return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);\n        };\n        /**\n         * Get cell hash\n         * @param level level\n         * @returns cell hash\n         */\n        this.hash = (level = 3) => {\n            return this._hashes[Math.min(this._hashes.length - 1, level)];\n        };\n        /**\n         * Get cell depth\n         * @param level level\n         * @returns cell depth\n         */\n        this.depth = (level = 3) => {\n            return this._depths[Math.min(this._depths.length - 1, level)];\n        };\n        /**\n         * Get cell level\n         * @returns cell level\n         */\n        this.level = () => {\n            return this.mask.level;\n        };\n        /**\n         * Checks cell to be euqal to another cell\n         * @param other other cell\n         * @returns true if cells are equal\n         */\n        this.equals = (other) => {\n            return this.hash().equals(other.hash());\n        };\n        this[_a] = () => this.toString();\n        // Resolve bits\n        let bits = BitString_1.BitString.EMPTY;\n        if (opts && opts.bits) {\n            bits = opts.bits;\n        }\n        // Resolve refs\n        let refs = [];\n        if (opts && opts.refs) {\n            refs = [...opts.refs];\n        }\n        // Resolve type\n        let hashes;\n        let depths;\n        let mask;\n        let type = CellType_1.CellType.Ordinary;\n        if (opts && opts.exotic) {\n            // Resolve exotic cell\n            let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);\n            // Perform wonders\n            let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);\n            // Copy results\n            mask = wonders.mask;\n            depths = wonders.depths;\n            hashes = wonders.hashes;\n            type = resolved.type;\n        }\n        else {\n            // Check correctness\n            if (refs.length > 4) {\n                throw new Error(\"Invalid number of references\");\n            }\n            if (bits.length > 1023) {\n                throw new Error(`Bits overflow: ${bits.length} > 1023`);\n            }\n            // Perform wonders\n            let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);\n            // Copy results\n            mask = wonders.mask;\n            depths = wonders.depths;\n            hashes = wonders.hashes;\n            type = CellType_1.CellType.Ordinary;\n        }\n        // Set fields\n        this.type = type;\n        this.bits = bits;\n        this.refs = refs;\n        this.mask = mask;\n        this._depths = depths;\n        this._hashes = hashes;\n        Object.freeze(this);\n        Object.freeze(this.refs);\n        Object.freeze(this.bits);\n        Object.freeze(this.mask);\n        Object.freeze(this._depths);\n        Object.freeze(this._hashes);\n    }\n    /**\n     * Check if cell is exotic\n     */\n    get isExotic() {\n        return this.type !== CellType_1.CellType.Ordinary;\n    }\n    /**\n     * Serializes cell to BOC\n     * @param opts options\n     */\n    toBoc(opts) {\n        let idx = (opts && opts.idx !== null && opts.idx !== undefined) ? opts.idx : false;\n        let crc32 = (opts && opts.crc32 !== null && opts.crc32 !== undefined) ? opts.crc32 : true;\n        return (0, serialization_1.serializeBoc)(this, { idx, crc32 });\n    }\n    /**\n     * Format cell to string\n     * @param indent indentation\n     * @returns string representation\n     */\n    toString(indent) {\n        let id = indent || '';\n        let t = 'x';\n        if (this.isExotic) {\n            if (this.type === CellType_1.CellType.MerkleProof) {\n                t = 'p';\n            }\n            else if (this.type === CellType_1.CellType.MerkleUpdate) {\n                t = 'u';\n            }\n            else if (this.type === CellType_1.CellType.PrunedBranch) {\n                t = 'p';\n            }\n        }\n        let s = id + (this.isExotic ? t : 'x') + '{' + this.bits.toString() + '}';\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            s += '\\n' + i.toString(id + ' ');\n        }\n        return s;\n    }\n    /**\n     * Covnert cell to slice\n     * @returns slice\n     */\n    asSlice() {\n        return this.beginParse();\n    }\n    /**\n     * Convert cell to a builder that has this cell stored\n     * @returns builder\n     */\n    asBuilder() {\n        return (0, Builder_1.beginCell)().storeSlice(this.asSlice());\n    }\n}\nexports.Cell = Cell;\n_a = symbol_inspect_1.default;\nCell.EMPTY = new Cell();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}