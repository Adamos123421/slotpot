{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\adams\\\\OneDrive\\\\Desktop\\\\Work\\\\slotpot\\\\src\\\\components\\\\SimpleCarousel.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { TonIcon } from './IconComponents';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SimpleCarousel = ({\n  players,\n  isSpinning,\n  onSpinComplete,\n  contractWinner,\n  totalJackpotValue\n}) => {\n  _s();\n  const [wheelState, setWheelState] = useState('idle'); // 'idle', 'waiting', 'spinning', 'winner', 'finished'\n  const [lockedPlayers, setLockedPlayers] = useState([]); // Lock players during animation\n  const wheelRef = useRef();\n  const idleAnimationRef = useRef();\n  const currentPosition = useRef(0);\n  const winnerShowcaseTimeoutRef = useRef();\n\n  // Card dimensions (matching roulette example)\n  const CARD_WIDTH = 81; // 75px + 3px margin on each side\n\n  // Lock players when spinning starts to prevent them from changing during animation\n  useEffect(() => {\n    if (isSpinning && contractWinner && players.length > 0) {\n      console.log('üîí Locking players for animation:', players);\n      setLockedPlayers([...players]);\n    }\n  }, [isSpinning, contractWinner, players]);\n\n  // Use locked players during animation, regular players otherwise\n  const effectivePlayers = wheelState === 'spinning' || wheelState === 'winner' ? lockedPlayers : players;\n\n  // Render individual player card HTML\n  const renderPlayerCard = useCallback((player, key) => {\n    var _player$bet;\n    if (!player) return '<div class=\"waiting-card\">Waiting...</div>';\n    const isActive = player.isRealPlayer && player.bet > 0;\n    const avatar = player.avatar && player.avatar !== '‚ùì' ? player.avatar : \"/img/unknown.webp\";\n    const username = player.username || player.displayName || player.name || 'Player';\n    const bet = isActive ? ((_player$bet = player.bet) === null || _player$bet === void 0 ? void 0 : _player$bet.toFixed(3)) || '0.000' : '0.000';\n    return `\n      <div class=\"player-card ${isActive ? 'active' : 'inactive'}\" data-key=\"${key}\">\n        <div class=\"card-content\">\n          <div class=\"avatar-container\">\n            <img src=\"${avatar}\" alt=\"${username}\" class=\"player-avatar\" />\n          </div>\n          <div class=\"player-info\">\n            <p class=\"player-name\">${username}</p>\n            <div class=\"bet-info\">\n              <img src=\"${isActive ? 'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png' : '/img/solana.png'}\" \n                   class=\"coin-icon ${!isActive ? 'grayscale' : ''}\" alt=\"\" />\n              <span class=\"bet-amount\">${bet}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }, []);\n\n  // Initialize wheel with player rows for infinite scrolling\n  const initWheel = useCallback(() => {\n    if (!wheelRef.current || !effectivePlayers.length) return;\n    const wheel = wheelRef.current;\n    wheel.innerHTML = ''; // Clear existing content\n\n    // Create one continuous row with multiple player cycles for smooth infinite scroll\n    const row = document.createElement('div');\n    row.className = 'roulette-row';\n\n    // Create enough copies to ensure smooth infinite scrolling (50 copies)\n    for (let copyIndex = 0; copyIndex < 50; copyIndex++) {\n      effectivePlayers.forEach((player, playerIndex) => {\n        const card = document.createElement('div');\n        card.className = 'roulette-card';\n        card.innerHTML = renderPlayerCard(player, `${copyIndex}-${playerIndex}`);\n        row.appendChild(card);\n      });\n    }\n    wheel.appendChild(row);\n  }, [effectivePlayers, renderPlayerCard]);\n\n  // Idle movement - constant speed with true infinite scroll\n  const startIdleMovement = useCallback(() => {\n    if (!wheelRef.current || wheelState !== 'idle') return;\n    const animate = () => {\n      if (wheelState !== 'idle') return;\n      currentPosition.current -= 0.5; // Slower, smoother movement (0.5px per frame)\n\n      // True infinite scroll - reset when we've scrolled through several player cycles\n      const cycleWidth = effectivePlayers.length * CARD_WIDTH;\n      const resetPoint = -(cycleWidth * 10); // Reset after 10 cycles\n\n      if (currentPosition.current <= resetPoint) {\n        // Reset to a position that maintains visual continuity\n        currentPosition.current = -(cycleWidth * 5); // Reset to middle area\n      }\n      if (wheelRef.current) {\n        wheelRef.current.style.transform = `translate3d(${currentPosition.current}px, 0px, 0px)`;\n      }\n      idleAnimationRef.current = requestAnimationFrame(animate);\n    };\n    idleAnimationRef.current = requestAnimationFrame(animate);\n  }, [wheelState, effectivePlayers.length, CARD_WIDTH]);\n\n  // Stop idle movement\n  const stopIdleMovement = useCallback(() => {\n    if (idleAnimationRef.current) {\n      cancelAnimationFrame(idleAnimationRef.current);\n      idleAnimationRef.current = null;\n    }\n  }, []);\n\n  // Find winner position in player array\n  const findWinnerPosition = useCallback(winner => {\n    if (!winner || !effectivePlayers.length) return -1;\n    console.log('Looking for winner:', winner);\n    console.log('Available players:', effectivePlayers);\n    for (let i = 0; i < effectivePlayers.length; i++) {\n      const player = effectivePlayers[i];\n      if (player && player.address && (player.address === winner.winner || player.address === winner.fullAddress) || player && player.fullAddress && (player.fullAddress === winner.winner || player.fullAddress === winner.fullAddress) || player && player.username && player.username === winner.username || player && player.displayName && player.displayName === winner.displayName) {\n        console.log(`Found winner at position ${i}:`, player);\n        return i;\n      }\n    }\n    console.warn('Winner not found in player list');\n    return -1;\n  }, [effectivePlayers]);\n\n  // Spin wheel function with improved accuracy\n  const spinWheel = useCallback(targetWinner => {\n    if (wheelState === 'spinning' || !wheelRef.current) return;\n    console.log('Starting spin with winner:', targetWinner);\n    setWheelState('spinning');\n    stopIdleMovement();\n    const winnerPosition = findWinnerPosition(targetWinner);\n    if (winnerPosition === -1) {\n      console.warn('Winner not found in player list, spinning randomly');\n      // If winner not found, still spin but land on first player\n      const fallbackPosition = 0;\n      performSpin(fallbackPosition, targetWinner);\n      return;\n    }\n    performSpin(winnerPosition, targetWinner);\n  }, [wheelState, stopIdleMovement, findWinnerPosition, effectivePlayers.length, onSpinComplete, CARD_WIDTH]);\n\n  // Separate function to perform the actual spin animation\n  const performSpin = useCallback((winnerPosition, targetWinner) => {\n    const wheel = wheelRef.current;\n    if (!wheel) return;\n\n    // Calculate precise landing position with improved accuracy\n    const wheelWidth = wheel.offsetWidth;\n    const centerOffset = wheelWidth / 2; // Center of the wheel view\n\n    // Account for the fact that cards are positioned from their left edge\n    // We need to position the winner card so its CENTER aligns with the selector line\n    const targetCardLeftEdge = winnerPosition * CARD_WIDTH; // Left edge of winner card\n    const targetCardCenter = targetCardLeftEdge + CARD_WIDTH / 2; // Center of winner card\n\n    // Calculate how many full spins to do (3-5 full cycles for dramatic effect)\n    const fullSpins = 3 + Math.random() * 2; // 3-5 spins\n    const totalSpinDistance = fullSpins * effectivePlayers.length * CARD_WIDTH;\n\n    // Improved final position calculation:\n    // We want: wheel_center - target_card_center = 0\n    // So: final_position = current_position - total_spin_distance - target_card_center + wheel_center\n    const preciseFinalPosition = currentPosition.current - totalSpinDistance - targetCardCenter + centerOffset;\n\n    // Add small adjustment to ensure perfect centering (compensate for any rounding errors)\n    const adjustment = 0; // Fine-tune if needed\n    const finalPosition = preciseFinalPosition + adjustment;\n    console.log(`üéØ Spinning to winner position ${winnerPosition}:`);\n    console.log(`   - Card left edge: ${targetCardLeftEdge}px`);\n    console.log(`   - Card center: ${targetCardCenter}px`);\n    console.log(`   - Wheel center: ${centerOffset}px`);\n    console.log(`   - Current position: ${currentPosition.current}px`);\n    console.log(`   - Total spin distance: ${totalSpinDistance}px`);\n    console.log(`   - Final position: ${finalPosition}px`);\n\n    // Apply smooth CSS transition with perfect easing\n    wheel.style.transitionTimingFunction = 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'; // Smooth deceleration\n    wheel.style.transitionDuration = '4s'; // 4 second spin\n    wheel.style.transform = `translate3d(${finalPosition}px, 0px, 0px)`;\n\n    // Update current position\n    currentPosition.current = finalPosition;\n\n    // After spin animation completes, show winner for 4 seconds\n    setTimeout(() => {\n      console.log('Spin animation completed, showing winner');\n      setWheelState('winner');\n\n      // Highlight the winner card (find all instances of the winner across all cycles)\n      const allCards = wheel.querySelectorAll('.roulette-card');\n      console.log(`üéØ Highlighting winner at position ${winnerPosition} out of ${effectivePlayers.length} players`);\n\n      // Highlight all cards that represent the winner (across all 50 cycles)\n      allCards.forEach((card, index) => {\n        const cardPlayerIndex = index % effectivePlayers.length;\n        if (cardPlayerIndex === winnerPosition) {\n          card.classList.add('winner-highlight');\n          console.log(`‚ú® Highlighted card at index ${index} (player ${cardPlayerIndex})`);\n        }\n      });\n\n      // After showcasing winner for 4 seconds, go to finished state (not idle)\n      winnerShowcaseTimeoutRef.current = setTimeout(() => {\n        console.log('Winner showcase complete, entering finished state');\n\n        // Remove winner highlights\n        const highlightedCards = wheel.querySelectorAll('.winner-highlight');\n        highlightedCards.forEach(card => {\n          card.classList.remove('winner-highlight');\n        });\n\n        // Reset transition styles\n        wheel.style.transitionTimingFunction = '';\n        wheel.style.transitionDuration = '';\n\n        // Clear locked players\n        setLockedPlayers([]);\n\n        // Go to finished state instead of idle to prevent scrolling\n        setWheelState('finished');\n        onSpinComplete === null || onSpinComplete === void 0 ? void 0 : onSpinComplete(targetWinner);\n      }, 4000); // Show winner for 4 seconds (longer showcase)\n    }, 4000); // Wait for spin animation (4 seconds)\n  }, [effectivePlayers.length, CARD_WIDTH, onSpinComplete]);\n\n  // Handle state changes\n  useEffect(() => {\n    if (isSpinning && contractWinner && wheelState === 'waiting') {\n      // Backend responded with winner, start spinning\n      console.log('Starting roulette spin with winner:', contractWinner);\n      spinWheel(contractWinner);\n    } else if (isSpinning && !contractWinner && wheelState === 'idle') {\n      // Bet placed, stop and wait for backend\n      console.log('Stopping wheel, waiting for winner...');\n      setWheelState('waiting');\n      stopIdleMovement();\n    } else if (!isSpinning && wheelState !== 'idle' && wheelState !== 'winner' && wheelState !== 'finished') {\n      // Reset to idle state (but don't interrupt winner showcase or finished state)\n      console.log('Resetting to idle state');\n      setWheelState('idle');\n    }\n  }, [isSpinning, contractWinner, wheelState, spinWheel, stopIdleMovement]);\n\n  // Detect new game start and reset from finished state to idle\n  useEffect(() => {\n    // If we're in finished state and there's no winner (new game starting), reset to idle\n    if (wheelState === 'finished' && !contractWinner && !isSpinning) {\n      console.log('New game detected - resetting from finished to idle');\n      setWheelState('idle');\n    }\n  }, [wheelState, contractWinner, isSpinning]);\n\n  // Start/stop idle movement based on state\n  useEffect(() => {\n    if (wheelState === 'idle') {\n      startIdleMovement();\n    } else {\n      stopIdleMovement();\n    }\n    return () => stopIdleMovement();\n  }, [wheelState, startIdleMovement, stopIdleMovement]);\n\n  // Initialize wheel when effective players change\n  useEffect(() => {\n    initWheel();\n  }, [initWheel]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (winnerShowcaseTimeoutRef.current) {\n        clearTimeout(winnerShowcaseTimeoutRef.current);\n      }\n    };\n  }, []);\n  if (!effectivePlayers || effectivePlayers.length === 0) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"simple-carousel\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"carousel-message\",\n        children: \"Waiting for players to join...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 306,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 305,\n      columnNumber: 7\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"roulette-wrapper\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"roulette-selector\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 316,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: wheelRef,\n      className: \"roulette-wheel\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 319,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"wheel-state-indicator\",\n      children: [wheelState === 'idle' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFB0\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 323,\n        columnNumber: 35\n      }, this), wheelState === 'waiting' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\u23F3\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 324,\n        columnNumber: 38\n      }, this), wheelState === 'spinning' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFAF\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 325,\n        columnNumber: 39\n      }, this), wheelState === 'winner' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDF89\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 326,\n        columnNumber: 37\n      }, this), wheelState === 'finished' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFC1\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 327,\n        columnNumber: 39\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 322,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"absolute -top-1/4 -right-1/3 h-full opacity-75 will-change-transform z-[3] pointer-events-none\",\n      style: {\n        maskImage: 'linear-gradient(black, transparent 50%)'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"img\", {\n        src: \"/img/glare.webp\",\n        className: \"w-full object-cover object-center\",\n        alt: \"\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 335,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 331,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 314,\n    columnNumber: 5\n  }, this);\n};\n_s(SimpleCarousel, \"VIxi7lGLuxZ4CmPOzTtmWajujkE=\");\n_c = SimpleCarousel;\nexport default SimpleCarousel;\nvar _c;\n$RefreshReg$(_c, \"SimpleCarousel\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","TonIcon","jsxDEV","_jsxDEV","SimpleCarousel","players","isSpinning","onSpinComplete","contractWinner","totalJackpotValue","_s","wheelState","setWheelState","lockedPlayers","setLockedPlayers","wheelRef","idleAnimationRef","currentPosition","winnerShowcaseTimeoutRef","CARD_WIDTH","length","console","log","effectivePlayers","renderPlayerCard","player","key","_player$bet","isActive","isRealPlayer","bet","avatar","username","displayName","name","toFixed","initWheel","current","wheel","innerHTML","row","document","createElement","className","copyIndex","forEach","playerIndex","card","appendChild","startIdleMovement","animate","cycleWidth","resetPoint","style","transform","requestAnimationFrame","stopIdleMovement","cancelAnimationFrame","findWinnerPosition","winner","i","address","fullAddress","warn","spinWheel","targetWinner","winnerPosition","fallbackPosition","performSpin","wheelWidth","offsetWidth","centerOffset","targetCardLeftEdge","targetCardCenter","fullSpins","Math","random","totalSpinDistance","preciseFinalPosition","adjustment","finalPosition","transitionTimingFunction","transitionDuration","setTimeout","allCards","querySelectorAll","index","cardPlayerIndex","classList","add","highlightedCards","remove","clearTimeout","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","maskImage","src","alt","_c","$RefreshReg$"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/src/components/SimpleCarousel.js"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { TonIcon } from './IconComponents';\n\nconst SimpleCarousel = ({ \n  players, \n  isSpinning, \n  onSpinComplete, \n  contractWinner,\n  totalJackpotValue \n}) => {\n  const [wheelState, setWheelState] = useState('idle'); // 'idle', 'waiting', 'spinning', 'winner', 'finished'\n  const [lockedPlayers, setLockedPlayers] = useState([]); // Lock players during animation\n  const wheelRef = useRef();\n  const idleAnimationRef = useRef();\n  const currentPosition = useRef(0);\n  const winnerShowcaseTimeoutRef = useRef();\n  \n  // Card dimensions (matching roulette example)\n  const CARD_WIDTH = 81; // 75px + 3px margin on each side\n  \n  // Lock players when spinning starts to prevent them from changing during animation\n  useEffect(() => {\n    if (isSpinning && contractWinner && players.length > 0) {\n      console.log('üîí Locking players for animation:', players);\n      setLockedPlayers([...players]);\n    }\n  }, [isSpinning, contractWinner, players]);\n  \n  // Use locked players during animation, regular players otherwise\n  const effectivePlayers = wheelState === 'spinning' || wheelState === 'winner' ? lockedPlayers : players;\n  \n  // Render individual player card HTML\n  const renderPlayerCard = useCallback((player, key) => {\n    if (!player) return '<div class=\"waiting-card\">Waiting...</div>';\n    \n    const isActive = player.isRealPlayer && player.bet > 0;\n    const avatar = player.avatar && player.avatar !== '‚ùì' ? player.avatar : \"/img/unknown.webp\";\n    const username = player.username || player.displayName || player.name || 'Player';\n    const bet = isActive ? (player.bet?.toFixed(3) || '0.000') : '0.000';\n    \n    return `\n      <div class=\"player-card ${isActive ? 'active' : 'inactive'}\" data-key=\"${key}\">\n        <div class=\"card-content\">\n          <div class=\"avatar-container\">\n            <img src=\"${avatar}\" alt=\"${username}\" class=\"player-avatar\" />\n          </div>\n          <div class=\"player-info\">\n            <p class=\"player-name\">${username}</p>\n            <div class=\"bet-info\">\n              <img src=\"${isActive ? 'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png' : '/img/solana.png'}\" \n                   class=\"coin-icon ${!isActive ? 'grayscale' : ''}\" alt=\"\" />\n              <span class=\"bet-amount\">${bet}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }, []);\n\n  // Initialize wheel with player rows for infinite scrolling\n  const initWheel = useCallback(() => {\n    if (!wheelRef.current || !effectivePlayers.length) return;\n    \n    const wheel = wheelRef.current;\n    wheel.innerHTML = ''; // Clear existing content\n    \n    // Create one continuous row with multiple player cycles for smooth infinite scroll\n    const row = document.createElement('div');\n    row.className = 'roulette-row';\n    \n    // Create enough copies to ensure smooth infinite scrolling (50 copies)\n    for (let copyIndex = 0; copyIndex < 50; copyIndex++) {\n      effectivePlayers.forEach((player, playerIndex) => {\n        const card = document.createElement('div');\n        card.className = 'roulette-card';\n        card.innerHTML = renderPlayerCard(player, `${copyIndex}-${playerIndex}`);\n        row.appendChild(card);\n      });\n    }\n    \n    wheel.appendChild(row);\n  }, [effectivePlayers, renderPlayerCard]);\n\n  // Idle movement - constant speed with true infinite scroll\n  const startIdleMovement = useCallback(() => {\n    if (!wheelRef.current || wheelState !== 'idle') return;\n    \n    const animate = () => {\n      if (wheelState !== 'idle') return;\n      \n      currentPosition.current -= 0.5; // Slower, smoother movement (0.5px per frame)\n      \n      // True infinite scroll - reset when we've scrolled through several player cycles\n      const cycleWidth = effectivePlayers.length * CARD_WIDTH;\n      const resetPoint = -(cycleWidth * 10); // Reset after 10 cycles\n      \n      if (currentPosition.current <= resetPoint) {\n        // Reset to a position that maintains visual continuity\n        currentPosition.current = -(cycleWidth * 5); // Reset to middle area\n      }\n      \n      if (wheelRef.current) {\n        wheelRef.current.style.transform = `translate3d(${currentPosition.current}px, 0px, 0px)`;\n      }\n      \n      idleAnimationRef.current = requestAnimationFrame(animate);\n    };\n    \n    idleAnimationRef.current = requestAnimationFrame(animate);\n  }, [wheelState, effectivePlayers.length, CARD_WIDTH]);\n\n  // Stop idle movement\n  const stopIdleMovement = useCallback(() => {\n    if (idleAnimationRef.current) {\n      cancelAnimationFrame(idleAnimationRef.current);\n      idleAnimationRef.current = null;\n    }\n  }, []);\n\n  // Find winner position in player array\n  const findWinnerPosition = useCallback((winner) => {\n    if (!winner || !effectivePlayers.length) return -1;\n    \n    console.log('Looking for winner:', winner);\n    console.log('Available players:', effectivePlayers);\n    \n    for (let i = 0; i < effectivePlayers.length; i++) {\n      const player = effectivePlayers[i];\n      if (\n        (player && player.address && (player.address === winner.winner || player.address === winner.fullAddress)) ||\n        (player && player.fullAddress && (player.fullAddress === winner.winner || player.fullAddress === winner.fullAddress)) ||\n        (player && player.username && player.username === winner.username) ||\n        (player && player.displayName && player.displayName === winner.displayName)\n      ) {\n        console.log(`Found winner at position ${i}:`, player);\n        return i;\n      }\n    }\n    console.warn('Winner not found in player list');\n    return -1;\n  }, [effectivePlayers]);\n\n  // Spin wheel function with improved accuracy\n  const spinWheel = useCallback((targetWinner) => {\n    if (wheelState === 'spinning' || !wheelRef.current) return;\n    \n    console.log('Starting spin with winner:', targetWinner);\n    setWheelState('spinning');\n    stopIdleMovement();\n    \n    const winnerPosition = findWinnerPosition(targetWinner);\n    if (winnerPosition === -1) {\n      console.warn('Winner not found in player list, spinning randomly');\n      // If winner not found, still spin but land on first player\n      const fallbackPosition = 0;\n      performSpin(fallbackPosition, targetWinner);\n      return;\n    }\n\n    performSpin(winnerPosition, targetWinner);\n    \n  }, [wheelState, stopIdleMovement, findWinnerPosition, effectivePlayers.length, onSpinComplete, CARD_WIDTH]);\n\n  // Separate function to perform the actual spin animation\n  const performSpin = useCallback((winnerPosition, targetWinner) => {\n    const wheel = wheelRef.current;\n    if (!wheel) return;\n\n    // Calculate precise landing position with improved accuracy\n    const wheelWidth = wheel.offsetWidth;\n    const centerOffset = wheelWidth / 2; // Center of the wheel view\n    \n    // Account for the fact that cards are positioned from their left edge\n    // We need to position the winner card so its CENTER aligns with the selector line\n    const targetCardLeftEdge = winnerPosition * CARD_WIDTH; // Left edge of winner card\n    const targetCardCenter = targetCardLeftEdge + (CARD_WIDTH / 2); // Center of winner card\n    \n    // Calculate how many full spins to do (3-5 full cycles for dramatic effect)\n    const fullSpins = 3 + Math.random() * 2; // 3-5 spins\n    const totalSpinDistance = fullSpins * effectivePlayers.length * CARD_WIDTH;\n    \n    // Improved final position calculation:\n    // We want: wheel_center - target_card_center = 0\n    // So: final_position = current_position - total_spin_distance - target_card_center + wheel_center\n    const preciseFinalPosition = currentPosition.current - totalSpinDistance - targetCardCenter + centerOffset;\n    \n    // Add small adjustment to ensure perfect centering (compensate for any rounding errors)\n    const adjustment = 0; // Fine-tune if needed\n    const finalPosition = preciseFinalPosition + adjustment;\n    \n    console.log(`üéØ Spinning to winner position ${winnerPosition}:`);\n    console.log(`   - Card left edge: ${targetCardLeftEdge}px`);\n    console.log(`   - Card center: ${targetCardCenter}px`);\n    console.log(`   - Wheel center: ${centerOffset}px`);\n    console.log(`   - Current position: ${currentPosition.current}px`);\n    console.log(`   - Total spin distance: ${totalSpinDistance}px`);\n    console.log(`   - Final position: ${finalPosition}px`);\n    \n    // Apply smooth CSS transition with perfect easing\n    wheel.style.transitionTimingFunction = 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'; // Smooth deceleration\n    wheel.style.transitionDuration = '4s'; // 4 second spin\n    wheel.style.transform = `translate3d(${finalPosition}px, 0px, 0px)`;\n    \n    // Update current position\n    currentPosition.current = finalPosition;\n    \n    // After spin animation completes, show winner for 4 seconds\n    setTimeout(() => {\n      console.log('Spin animation completed, showing winner');\n      setWheelState('winner');\n      \n      // Highlight the winner card (find all instances of the winner across all cycles)\n      const allCards = wheel.querySelectorAll('.roulette-card');\n      console.log(`üéØ Highlighting winner at position ${winnerPosition} out of ${effectivePlayers.length} players`);\n      \n      // Highlight all cards that represent the winner (across all 50 cycles)\n      allCards.forEach((card, index) => {\n        const cardPlayerIndex = index % effectivePlayers.length;\n        if (cardPlayerIndex === winnerPosition) {\n          card.classList.add('winner-highlight');\n          console.log(`‚ú® Highlighted card at index ${index} (player ${cardPlayerIndex})`);\n        }\n      });\n      \n      // After showcasing winner for 4 seconds, go to finished state (not idle)\n      winnerShowcaseTimeoutRef.current = setTimeout(() => {\n        console.log('Winner showcase complete, entering finished state');\n        \n        // Remove winner highlights\n        const highlightedCards = wheel.querySelectorAll('.winner-highlight');\n        highlightedCards.forEach(card => {\n          card.classList.remove('winner-highlight');\n        });\n        \n        // Reset transition styles\n        wheel.style.transitionTimingFunction = '';\n        wheel.style.transitionDuration = '';\n        \n        // Clear locked players\n        setLockedPlayers([]);\n        \n        // Go to finished state instead of idle to prevent scrolling\n        setWheelState('finished');\n        onSpinComplete?.(targetWinner);\n      }, 4000); // Show winner for 4 seconds (longer showcase)\n      \n    }, 4000); // Wait for spin animation (4 seconds)\n    \n  }, [effectivePlayers.length, CARD_WIDTH, onSpinComplete]);\n\n  // Handle state changes\n  useEffect(() => {\n    if (isSpinning && contractWinner && wheelState === 'waiting') {\n      // Backend responded with winner, start spinning\n      console.log('Starting roulette spin with winner:', contractWinner);\n      spinWheel(contractWinner);\n    } else if (isSpinning && !contractWinner && wheelState === 'idle') {\n      // Bet placed, stop and wait for backend\n      console.log('Stopping wheel, waiting for winner...');\n      setWheelState('waiting');\n      stopIdleMovement();\n    } else if (!isSpinning && wheelState !== 'idle' && wheelState !== 'winner' && wheelState !== 'finished') {\n      // Reset to idle state (but don't interrupt winner showcase or finished state)\n      console.log('Resetting to idle state');\n      setWheelState('idle');\n    }\n  }, [isSpinning, contractWinner, wheelState, spinWheel, stopIdleMovement]);\n\n  // Detect new game start and reset from finished state to idle\n  useEffect(() => {\n    // If we're in finished state and there's no winner (new game starting), reset to idle\n    if (wheelState === 'finished' && !contractWinner && !isSpinning) {\n      console.log('New game detected - resetting from finished to idle');\n      setWheelState('idle');\n    }\n  }, [wheelState, contractWinner, isSpinning]);\n\n  // Start/stop idle movement based on state\n  useEffect(() => {\n    if (wheelState === 'idle') {\n      startIdleMovement();\n    } else {\n      stopIdleMovement();\n    }\n    \n    return () => stopIdleMovement();\n  }, [wheelState, startIdleMovement, stopIdleMovement]);\n\n  // Initialize wheel when effective players change\n  useEffect(() => {\n    initWheel();\n  }, [initWheel]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (winnerShowcaseTimeoutRef.current) {\n        clearTimeout(winnerShowcaseTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  if (!effectivePlayers || effectivePlayers.length === 0) {\n    return (\n      <div className=\"simple-carousel\">\n        <div className=\"carousel-message\">\n          Waiting for players to join...\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"roulette-wrapper\">\n      {/* Center selector line */}\n      <div className=\"roulette-selector\"></div>\n      \n      {/* Spinning wheel */}\n      <div ref={wheelRef} className=\"roulette-wheel\"></div>\n      \n      {/* State indicator */}\n      <div className=\"wheel-state-indicator\">\n        {wheelState === 'idle' && <span>üé∞</span>}\n        {wheelState === 'waiting' && <span>‚è≥</span>}\n        {wheelState === 'spinning' && <span>üéØ</span>}\n        {wheelState === 'winner' && <span>üéâ</span>}\n        {wheelState === 'finished' && <span>üèÅ</span>}\n      </div>\n      \n      {/* Glare Effect */}\n      <div \n        className=\"absolute -top-1/4 -right-1/3 h-full opacity-75 will-change-transform z-[3] pointer-events-none\"\n        style={{ maskImage: 'linear-gradient(black, transparent 50%)' }}\n      >\n        <img src=\"/img/glare.webp\" className=\"w-full object-cover object-center\" alt=\"\" />\n      </div>\n    </div>\n  );\n};\n\nexport default SimpleCarousel; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}