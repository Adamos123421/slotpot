{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeBoc = exports.deserializeBoc = exports.parseBoc = void 0;\nconst BitReader_1 = require(\"../BitReader\");\nconst BitString_1 = require(\"../BitString\");\nconst Cell_1 = require(\"../Cell\");\nconst topologicalSort_1 = require(\"./utils/topologicalSort\");\nconst bitsForNumber_1 = require(\"../../utils/bitsForNumber\");\nconst BitBuilder_1 = require(\"../BitBuilder\");\nconst descriptor_1 = require(\"./descriptor\");\nconst paddedBits_1 = require(\"../utils/paddedBits\");\nconst crc32c_1 = require(\"../../utils/crc32c\");\nfunction getHashesCount(levelMask) {\n  return getHashesCountFromMask(levelMask & 7);\n}\nfunction getHashesCountFromMask(mask) {\n  let n = 0;\n  for (let i = 0; i < 3; i++) {\n    n += mask & 1;\n    mask = mask >> 1;\n  }\n  return n + 1; // 1 repr + up to 3 higher hashes\n}\nfunction readCell(reader, sizeBytes) {\n  // D1\n  const d1 = reader.loadUint(8);\n  const refsCount = d1 % 8;\n  const exotic = !!(d1 & 8);\n  // D2\n  const d2 = reader.loadUint(8);\n  const dataBytesize = Math.ceil(d2 / 2);\n  const paddingAdded = !!(d2 % 2);\n  const levelMask = d1 >> 5;\n  const hasHashes = (d1 & 16) != 0;\n  const hash_bytes = 32;\n  const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;\n  const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;\n  reader.skip(hashesSize * 8);\n  reader.skip(depthSize * 8);\n  // Bits\n  let bits = BitString_1.BitString.EMPTY;\n  if (dataBytesize > 0) {\n    if (paddingAdded) {\n      bits = reader.loadPaddedBits(dataBytesize * 8);\n    } else {\n      bits = reader.loadBits(dataBytesize * 8);\n    }\n  }\n  // Refs\n  let refs = [];\n  for (let i = 0; i < refsCount; i++) {\n    refs.push(reader.loadUint(sizeBytes * 8));\n  }\n  // Result\n  return {\n    bits,\n    refs,\n    exotic\n  };\n}\nfunction calcCellSize(cell, sizeBytes) {\n  return 2 /* D1+D2 */ + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;\n}\nfunction parseBoc(src) {\n  let reader = new BitReader_1.BitReader(new BitString_1.BitString(src, 0, src.length * 8));\n  let magic = reader.loadUint(32);\n  if (magic === 0x68ff65f3) {\n    let size = reader.loadUint(8);\n    let offBytes = reader.loadUint(8);\n    let cells = reader.loadUint(size * 8);\n    let roots = reader.loadUint(size * 8); // Must be 1\n    let absent = reader.loadUint(size * 8);\n    let totalCellSize = reader.loadUint(offBytes * 8);\n    let index = reader.loadBuffer(cells * offBytes);\n    let cellData = reader.loadBuffer(totalCellSize);\n    return {\n      size,\n      offBytes,\n      cells,\n      roots,\n      absent,\n      totalCellSize,\n      index,\n      cellData,\n      root: [0]\n    };\n  } else if (magic === 0xacc3a728) {\n    let size = reader.loadUint(8);\n    let offBytes = reader.loadUint(8);\n    let cells = reader.loadUint(size * 8);\n    let roots = reader.loadUint(size * 8); // Must be 1\n    let absent = reader.loadUint(size * 8);\n    let totalCellSize = reader.loadUint(offBytes * 8);\n    let index = reader.loadBuffer(cells * offBytes);\n    let cellData = reader.loadBuffer(totalCellSize);\n    let crc32 = reader.loadBuffer(4);\n    if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {\n      throw Error('Invalid CRC32C');\n    }\n    return {\n      size,\n      offBytes,\n      cells,\n      roots,\n      absent,\n      totalCellSize,\n      index,\n      cellData,\n      root: [0]\n    };\n  } else if (magic === 0xb5ee9c72) {\n    let hasIdx = reader.loadUint(1);\n    let hasCrc32c = reader.loadUint(1);\n    let hasCacheBits = reader.loadUint(1);\n    let flags = reader.loadUint(2); // Must be 0\n    let size = reader.loadUint(3);\n    let offBytes = reader.loadUint(8);\n    let cells = reader.loadUint(size * 8);\n    let roots = reader.loadUint(size * 8);\n    let absent = reader.loadUint(size * 8);\n    let totalCellSize = reader.loadUint(offBytes * 8);\n    let root = [];\n    for (let i = 0; i < roots; i++) {\n      root.push(reader.loadUint(size * 8));\n    }\n    let index = null;\n    if (hasIdx) {\n      index = reader.loadBuffer(cells * offBytes);\n    }\n    let cellData = reader.loadBuffer(totalCellSize);\n    if (hasCrc32c) {\n      let crc32 = reader.loadBuffer(4);\n      if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {\n        throw Error('Invalid CRC32C');\n      }\n    }\n    return {\n      size,\n      offBytes,\n      cells,\n      roots,\n      absent,\n      totalCellSize,\n      index,\n      cellData,\n      root\n    };\n  } else {\n    throw Error('Invalid magic');\n  }\n}\nexports.parseBoc = parseBoc;\nfunction deserializeBoc(src) {\n  //\n  // Parse BOC\n  //\n  let boc = parseBoc(src);\n  let reader = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));\n  //\n  // Load cells\n  //\n  let cells = [];\n  for (let i = 0; i < boc.cells; i++) {\n    let cll = readCell(reader, boc.size);\n    cells.push({\n      ...cll,\n      result: null\n    });\n  }\n  //\n  // Build cells\n  //\n  for (let i = cells.length - 1; i >= 0; i--) {\n    if (cells[i].result) {\n      throw Error('Impossible');\n    }\n    let refs = [];\n    for (let r of cells[i].refs) {\n      if (!cells[r].result) {\n        throw Error('Invalid BOC file');\n      }\n      refs.push(cells[r].result);\n    }\n    cells[i].result = new Cell_1.Cell({\n      bits: cells[i].bits,\n      refs,\n      exotic: cells[i].exotic\n    });\n  }\n  //\n  // Load roots\n  //\n  let roots = [];\n  for (let i = 0; i < boc.root.length; i++) {\n    roots.push(cells[boc.root[i]].result);\n  }\n  //\n  // Return\n  //\n  return roots;\n}\nexports.deserializeBoc = deserializeBoc;\nfunction writeCellToBuilder(cell, refs, sizeBytes, to) {\n  let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.mask.value, cell.type);\n  let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);\n  to.writeUint(d1, 8);\n  to.writeUint(d2, 8);\n  to.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));\n  for (let r of refs) {\n    to.writeUint(r, sizeBytes * 8);\n  }\n}\nfunction serializeBoc(root, opts) {\n  // Sort cells\n  let allCells = (0, topologicalSort_1.topologicalSort)(root);\n  // Calculcate parameters\n  let cellsNum = allCells.length;\n  let has_idx = opts.idx;\n  let has_crc32c = opts.crc32;\n  let has_cache_bits = false;\n  let flags = 0;\n  let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, 'uint') / 8), 1);\n  let totalCellSize = 0;\n  let index = [];\n  for (let c of allCells) {\n    let sz = calcCellSize(c.cell, sizeBytes);\n    totalCellSize += sz;\n    index.push(totalCellSize);\n  }\n  let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, 'uint') / 8), 1);\n  let totalSize = (4 +\n  // magic\n  1 +\n  // flags and s_bytes\n  1 +\n  // offset_bytes\n  3 * sizeBytes +\n  // cells_num, roots, complete\n  offsetBytes +\n  // full_size\n  1 * sizeBytes + (\n  // root_idx\n  has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;\n  // Serialize\n  let builder = new BitBuilder_1.BitBuilder(totalSize);\n  builder.writeUint(0xb5ee9c72, 32); // Magic\n  builder.writeBit(has_idx); // Has index\n  builder.writeBit(has_crc32c); // Has crc32c\n  builder.writeBit(has_cache_bits); // Has cache bits\n  builder.writeUint(flags, 2); // Flags\n  builder.writeUint(sizeBytes, 3); // Size bytes\n  builder.writeUint(offsetBytes, 8); // Offset bytes\n  builder.writeUint(cellsNum, sizeBytes * 8); // Cells num\n  builder.writeUint(1, sizeBytes * 8); // Roots num\n  builder.writeUint(0, sizeBytes * 8); // Absent num\n  builder.writeUint(totalCellSize, offsetBytes * 8); // Total cell size\n  builder.writeUint(0, sizeBytes * 8); // Root id == 0\n  if (has_idx) {\n    // Index\n    for (let i = 0; i < cellsNum; i++) {\n      builder.writeUint(index[i], offsetBytes * 8);\n    }\n  }\n  for (let i = 0; i < cellsNum; i++) {\n    // Cells\n    writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder);\n  }\n  if (has_crc32c) {\n    let crc32 = (0, crc32c_1.crc32c)(builder.buffer()); // builder.buffer() is fast since it doesn't allocate new memory\n    builder.writeBuffer(crc32);\n  }\n  // Sanity Check\n  let res = builder.buffer();\n  if (res.length !== totalSize / 8) {\n    throw Error('Internal error');\n  }\n  return res;\n}\nexports.serializeBoc = serializeBoc;","map":{"version":3,"names":["Object","defineProperty","exports","value","serializeBoc","deserializeBoc","parseBoc","BitReader_1","require","BitString_1","Cell_1","topologicalSort_1","bitsForNumber_1","BitBuilder_1","descriptor_1","paddedBits_1","crc32c_1","getHashesCount","levelMask","getHashesCountFromMask","mask","n","i","readCell","reader","sizeBytes","d1","loadUint","refsCount","exotic","d2","dataBytesize","Math","ceil","paddingAdded","hasHashes","hash_bytes","hashesSize","depthSize","skip","bits","BitString","EMPTY","loadPaddedBits","loadBits","refs","push","calcCellSize","cell","length","src","BitReader","magic","size","offBytes","cells","roots","absent","totalCellSize","index","loadBuffer","cellData","root","crc32","crc32c","subarray","equals","Error","hasIdx","hasCrc32c","hasCacheBits","flags","boc","cll","result","r","Cell","writeCellToBuilder","to","getRefsDescriptor","type","getBitsDescriptor","writeUint","writeBuffer","bitsToPaddedBuffer","opts","allCells","topologicalSort","cellsNum","has_idx","idx","has_crc32c","has_cache_bits","max","bitsForNumber","c","sz","offsetBytes","totalSize","builder","BitBuilder","writeBit","buffer","res"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/boc/cell/serialization.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeBoc = exports.deserializeBoc = exports.parseBoc = void 0;\nconst BitReader_1 = require(\"../BitReader\");\nconst BitString_1 = require(\"../BitString\");\nconst Cell_1 = require(\"../Cell\");\nconst topologicalSort_1 = require(\"./utils/topologicalSort\");\nconst bitsForNumber_1 = require(\"../../utils/bitsForNumber\");\nconst BitBuilder_1 = require(\"../BitBuilder\");\nconst descriptor_1 = require(\"./descriptor\");\nconst paddedBits_1 = require(\"../utils/paddedBits\");\nconst crc32c_1 = require(\"../../utils/crc32c\");\nfunction getHashesCount(levelMask) {\n    return getHashesCountFromMask(levelMask & 7);\n}\nfunction getHashesCountFromMask(mask) {\n    let n = 0;\n    for (let i = 0; i < 3; i++) {\n        n += (mask & 1);\n        mask = mask >> 1;\n    }\n    return n + 1; // 1 repr + up to 3 higher hashes\n}\nfunction readCell(reader, sizeBytes) {\n    // D1\n    const d1 = reader.loadUint(8);\n    const refsCount = d1 % 8;\n    const exotic = !!(d1 & 8);\n    // D2\n    const d2 = reader.loadUint(8);\n    const dataBytesize = Math.ceil(d2 / 2);\n    const paddingAdded = !!(d2 % 2);\n    const levelMask = d1 >> 5;\n    const hasHashes = (d1 & 16) != 0;\n    const hash_bytes = 32;\n    const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;\n    const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;\n    reader.skip(hashesSize * 8);\n    reader.skip(depthSize * 8);\n    // Bits\n    let bits = BitString_1.BitString.EMPTY;\n    if (dataBytesize > 0) {\n        if (paddingAdded) {\n            bits = reader.loadPaddedBits(dataBytesize * 8);\n        }\n        else {\n            bits = reader.loadBits(dataBytesize * 8);\n        }\n    }\n    // Refs\n    let refs = [];\n    for (let i = 0; i < refsCount; i++) {\n        refs.push(reader.loadUint(sizeBytes * 8));\n    }\n    // Result\n    return {\n        bits,\n        refs,\n        exotic\n    };\n}\nfunction calcCellSize(cell, sizeBytes) {\n    return 2 /* D1+D2 */ + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;\n}\nfunction parseBoc(src) {\n    let reader = new BitReader_1.BitReader(new BitString_1.BitString(src, 0, src.length * 8));\n    let magic = reader.loadUint(32);\n    if (magic === 0x68ff65f3) {\n        let size = reader.loadUint(8);\n        let offBytes = reader.loadUint(8);\n        let cells = reader.loadUint(size * 8);\n        let roots = reader.loadUint(size * 8); // Must be 1\n        let absent = reader.loadUint(size * 8);\n        let totalCellSize = reader.loadUint(offBytes * 8);\n        let index = reader.loadBuffer(cells * offBytes);\n        let cellData = reader.loadBuffer(totalCellSize);\n        return {\n            size,\n            offBytes,\n            cells,\n            roots,\n            absent,\n            totalCellSize,\n            index,\n            cellData,\n            root: [0]\n        };\n    }\n    else if (magic === 0xacc3a728) {\n        let size = reader.loadUint(8);\n        let offBytes = reader.loadUint(8);\n        let cells = reader.loadUint(size * 8);\n        let roots = reader.loadUint(size * 8); // Must be 1\n        let absent = reader.loadUint(size * 8);\n        let totalCellSize = reader.loadUint(offBytes * 8);\n        let index = reader.loadBuffer(cells * offBytes);\n        let cellData = reader.loadBuffer(totalCellSize);\n        let crc32 = reader.loadBuffer(4);\n        if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {\n            throw Error('Invalid CRC32C');\n        }\n        return {\n            size,\n            offBytes,\n            cells,\n            roots,\n            absent,\n            totalCellSize,\n            index,\n            cellData,\n            root: [0]\n        };\n    }\n    else if (magic === 0xb5ee9c72) {\n        let hasIdx = reader.loadUint(1);\n        let hasCrc32c = reader.loadUint(1);\n        let hasCacheBits = reader.loadUint(1);\n        let flags = reader.loadUint(2); // Must be 0\n        let size = reader.loadUint(3);\n        let offBytes = reader.loadUint(8);\n        let cells = reader.loadUint(size * 8);\n        let roots = reader.loadUint(size * 8);\n        let absent = reader.loadUint(size * 8);\n        let totalCellSize = reader.loadUint(offBytes * 8);\n        let root = [];\n        for (let i = 0; i < roots; i++) {\n            root.push(reader.loadUint(size * 8));\n        }\n        let index = null;\n        if (hasIdx) {\n            index = reader.loadBuffer(cells * offBytes);\n        }\n        let cellData = reader.loadBuffer(totalCellSize);\n        if (hasCrc32c) {\n            let crc32 = reader.loadBuffer(4);\n            if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {\n                throw Error('Invalid CRC32C');\n            }\n        }\n        return {\n            size,\n            offBytes,\n            cells,\n            roots,\n            absent,\n            totalCellSize,\n            index,\n            cellData,\n            root\n        };\n    }\n    else {\n        throw Error('Invalid magic');\n    }\n}\nexports.parseBoc = parseBoc;\nfunction deserializeBoc(src) {\n    //\n    // Parse BOC\n    //\n    let boc = parseBoc(src);\n    let reader = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));\n    //\n    // Load cells\n    //\n    let cells = [];\n    for (let i = 0; i < boc.cells; i++) {\n        let cll = readCell(reader, boc.size);\n        cells.push({ ...cll, result: null });\n    }\n    //\n    // Build cells\n    //\n    for (let i = cells.length - 1; i >= 0; i--) {\n        if (cells[i].result) {\n            throw Error('Impossible');\n        }\n        let refs = [];\n        for (let r of cells[i].refs) {\n            if (!cells[r].result) {\n                throw Error('Invalid BOC file');\n            }\n            refs.push(cells[r].result);\n        }\n        cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });\n    }\n    //\n    // Load roots\n    //\n    let roots = [];\n    for (let i = 0; i < boc.root.length; i++) {\n        roots.push(cells[boc.root[i]].result);\n    }\n    //\n    // Return\n    //\n    return roots;\n}\nexports.deserializeBoc = deserializeBoc;\nfunction writeCellToBuilder(cell, refs, sizeBytes, to) {\n    let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.mask.value, cell.type);\n    let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);\n    to.writeUint(d1, 8);\n    to.writeUint(d2, 8);\n    to.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));\n    for (let r of refs) {\n        to.writeUint(r, sizeBytes * 8);\n    }\n}\nfunction serializeBoc(root, opts) {\n    // Sort cells\n    let allCells = (0, topologicalSort_1.topologicalSort)(root);\n    // Calculcate parameters\n    let cellsNum = allCells.length;\n    let has_idx = opts.idx;\n    let has_crc32c = opts.crc32;\n    let has_cache_bits = false;\n    let flags = 0;\n    let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, 'uint') / 8), 1);\n    let totalCellSize = 0;\n    let index = [];\n    for (let c of allCells) {\n        let sz = calcCellSize(c.cell, sizeBytes);\n        totalCellSize += sz;\n        index.push(totalCellSize);\n    }\n    let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, 'uint') / 8), 1);\n    let totalSize = (4 + // magic\n        1 + // flags and s_bytes\n        1 + // offset_bytes\n        3 * sizeBytes + // cells_num, roots, complete\n        offsetBytes + // full_size\n        1 * sizeBytes + // root_idx\n        (has_idx ? cellsNum * offsetBytes : 0) +\n        totalCellSize +\n        (has_crc32c ? 4 : 0)) * 8;\n    // Serialize\n    let builder = new BitBuilder_1.BitBuilder(totalSize);\n    builder.writeUint(0xb5ee9c72, 32); // Magic\n    builder.writeBit(has_idx); // Has index\n    builder.writeBit(has_crc32c); // Has crc32c\n    builder.writeBit(has_cache_bits); // Has cache bits\n    builder.writeUint(flags, 2); // Flags\n    builder.writeUint(sizeBytes, 3); // Size bytes\n    builder.writeUint(offsetBytes, 8); // Offset bytes\n    builder.writeUint(cellsNum, sizeBytes * 8); // Cells num\n    builder.writeUint(1, sizeBytes * 8); // Roots num\n    builder.writeUint(0, sizeBytes * 8); // Absent num\n    builder.writeUint(totalCellSize, offsetBytes * 8); // Total cell size\n    builder.writeUint(0, sizeBytes * 8); // Root id == 0\n    if (has_idx) { // Index\n        for (let i = 0; i < cellsNum; i++) {\n            builder.writeUint(index[i], offsetBytes * 8);\n        }\n    }\n    for (let i = 0; i < cellsNum; i++) { // Cells\n        writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder);\n    }\n    if (has_crc32c) {\n        let crc32 = (0, crc32c_1.crc32c)(builder.buffer()); // builder.buffer() is fast since it doesn't allocate new memory\n        builder.writeBuffer(crc32);\n    }\n    // Sanity Check\n    let res = builder.buffer();\n    if (res.length !== totalSize / 8) {\n        throw Error('Internal error');\n    }\n    return res;\n}\nexports.serializeBoc = serializeBoc;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}