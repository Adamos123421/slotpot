{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\adams\\\\OneDrive\\\\Desktop\\\\Work\\\\slotpot\\\\src\\\\components\\\\SimpleCarousel.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { TonIcon } from './IconComponents';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SimpleCarousel = ({\n  players,\n  isSpinning,\n  onSpinComplete,\n  contractWinner,\n  totalJackpotValue\n}) => {\n  _s();\n  const [wheelState, setWheelState] = useState('idle'); // 'idle', 'waiting', 'spinning', 'winner', 'finished'\n  const [lockedPlayers, setLockedPlayers] = useState([]); // Lock players during animation\n  const wheelRef = useRef();\n  const idleAnimationRef = useRef();\n  const currentPosition = useRef(0);\n  const winnerShowcaseTimeoutRef = useRef();\n\n  // Card dimensions (matching roulette example)\n  const CARD_WIDTH = 20; // 75px + 3px margin on each side\n\n  // Lock players when spinning starts to prevent them from changing during animation\n  useEffect(() => {\n    if (isSpinning && contractWinner && players.length > 0) {\n      // Locking players for animation\n      setLockedPlayers([...players]);\n    }\n  }, [isSpinning, contractWinner, players]);\n\n  // Use locked players during animation, regular players otherwise\n  const effectivePlayers = wheelState === 'spinning' || wheelState === 'winner' ? lockedPlayers : players;\n\n  // Render individual player card HTML\n  const renderPlayerCard = useCallback((player, key) => {\n    if (!player) {\n      return `\n        <div class=\"waiting-card\">\n          <div class=\"avatar-container\">\n            ?\n          </div>\n          <div class=\"waiting-text\">Waiting</div>\n          <div class=\"waiting-amount\">0.000</div>\n        </div>\n      `;\n    }\n\n    // Always show the amount if it exists, regardless of isRealPlayer\n    const amount = player.bet || player.amount || 0;\n    const isActive = amount > 0;\n    const avatar = player.avatar && player.avatar !== '‚ùì' && player.avatar !== 'üë§' ? player.avatar : `https://robohash.org/${player.address || player.name}.png?size=100x100`;\n    const username = player.username || player.displayName || player.name || 'Player';\n    const bet = amount.toFixed(3);\n    return `\n      <div class=\"player-card ${isActive ? 'active' : 'inactive'}\" data-key=\"${key}\">\n        <div class=\"card-content\">\n          <div class=\"avatar-container\">\n            <img src=\"${avatar}\" alt=\"${username}\" class=\"player-avatar\" />\n          </div>\n          <div class=\"player-info\">\n            <p class=\"player-name\">${username}</p>\n            <div class=\"bet-info\">\n              <div class=\"coin-icon ${!isActive ? 'grayscale' : ''}\"></div>\n              <span class=\"bet-amount\">${bet}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }, []);\n\n  // Initialize wheel with player rows for infinite scrolling\n  const initWheel = useCallback(() => {\n    if (!wheelRef.current || !effectivePlayers.length) return;\n    const wheel = wheelRef.current;\n    wheel.innerHTML = ''; // Clear existing content\n\n    // Create one continuous row with multiple player cycles for smooth infinite scroll\n    const row = document.createElement('div');\n    row.className = 'roulette-row';\n\n    // Create enough copies to ensure smooth infinite scrolling (50 copies)\n    for (let copyIndex = 0; copyIndex < 50; copyIndex++) {\n      effectivePlayers.forEach((player, playerIndex) => {\n        const card = document.createElement('div');\n        card.className = 'roulette-card';\n        card.innerHTML = renderPlayerCard(player, `${copyIndex}-${playerIndex}`);\n        row.appendChild(card);\n      });\n    }\n    wheel.appendChild(row);\n  }, [effectivePlayers, renderPlayerCard]);\n\n  // Idle movement - constant speed with true infinite scroll\n  const startIdleMovement = useCallback(() => {\n    if (!wheelRef.current || wheelState !== 'idle') return;\n    const animate = () => {\n      var _wheelRef$current;\n      if (wheelState !== 'idle') return;\n      currentPosition.current -= 0.5; // Slower, smoother movement (0.5px per frame)\n\n      // True infinite scroll - reset when we've scrolled through several player cycles\n      // Use actual card spacing for consistency\n      const firstCard = (_wheelRef$current = wheelRef.current) === null || _wheelRef$current === void 0 ? void 0 : _wheelRef$current.querySelector('.roulette-card');\n      const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n      const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n      const totalCardSpacing = actualCardWidth + cardMargin;\n      const cycleWidth = effectivePlayers.length * totalCardSpacing;\n      const resetPoint = -(cycleWidth * 10); // Reset after 10 cycles\n\n      if (currentPosition.current <= resetPoint) {\n        // Reset to a position that maintains visual continuity\n        currentPosition.current = -(cycleWidth * 5); // Reset to middle area\n      }\n      if (wheelRef.current) {\n        wheelRef.current.style.transform = `translate3d(${currentPosition.current}px, 0px, 0px)`;\n      }\n      idleAnimationRef.current = requestAnimationFrame(animate);\n    };\n    idleAnimationRef.current = requestAnimationFrame(animate);\n  }, [wheelState, effectivePlayers.length, CARD_WIDTH]);\n\n  // Stop idle movement\n  const stopIdleMovement = useCallback(() => {\n    if (idleAnimationRef.current) {\n      cancelAnimationFrame(idleAnimationRef.current);\n      idleAnimationRef.current = null;\n    }\n  }, []);\n\n  // Find winner position in player array\n  const findWinnerPosition = useCallback(winner => {\n    if (!winner || !effectivePlayers.length) return -1;\n    console.log('üîç Finding winner position for:', winner);\n    console.log('üîç Available players:', effectivePlayers.map(p => ({\n      address: p === null || p === void 0 ? void 0 : p.address,\n      fullAddress: p === null || p === void 0 ? void 0 : p.fullAddress,\n      username: p === null || p === void 0 ? void 0 : p.username\n    })));\n    for (let i = 0; i < effectivePlayers.length; i++) {\n      const player = effectivePlayers[i];\n      if (!player) continue;\n\n      // Try multiple matching strategies\n      const addressMatch = player.address && (player.address === winner.winner || player.address === winner.fullAddress) || player.fullAddress && (player.fullAddress === winner.winner || player.fullAddress === winner.fullAddress);\n      const usernameMatch = player.username && player.username === winner.username || player.displayName && player.displayName === winner.displayName || player.username && winner.username && player.username === winner.username || player.displayName && winner.winnerName && player.displayName === winner.winnerName;\n      if (addressMatch || usernameMatch) {\n        console.log(`‚úÖ Found winner at position ${i}:`, {\n          player: {\n            address: player.address,\n            fullAddress: player.fullAddress,\n            username: player.username\n          },\n          winner: {\n            winner: winner.winner,\n            fullAddress: winner.fullAddress,\n            username: winner.username\n          },\n          matchType: addressMatch ? 'address' : 'username'\n        });\n        return i;\n      }\n    }\n    console.warn('‚ùå Winner not found in player list. Winner data:', winner);\n    console.warn('‚ùå Available players:', effectivePlayers);\n    return -1;\n  }, [effectivePlayers]);\n\n  // Spin wheel function with improved accuracy\n  const spinWheel = useCallback(targetWinner => {\n    if (wheelState === 'spinning' || !wheelRef.current) return;\n    console.log('Starting spin with winner:', targetWinner);\n\n    // Play launch sound when spin starts\n    // Launch sound removed for performance\n\n    setWheelState('spinning');\n    stopIdleMovement();\n    const winnerPosition = findWinnerPosition(targetWinner);\n    if (winnerPosition === -1) {\n      console.warn('Winner not found in player list, using fallback strategy');\n\n      // Fallback 1: Try to find by username pattern (e.g., \"Player_3tsb\" -> look for any player with \"3tsb\")\n      const winnerUsername = targetWinner.username || targetWinner.winnerName;\n      if (winnerUsername && winnerUsername.includes('_')) {\n        const usernameSuffix = winnerUsername.split('_')[1];\n        for (let i = 0; i < effectivePlayers.length; i++) {\n          const player = effectivePlayers[i];\n          if (player && player.username && player.username.includes(usernameSuffix)) {\n            console.log(`üéØ Fallback: Found player with matching username suffix at position ${i}:`, player);\n            performSpin(i, targetWinner);\n            return;\n          }\n        }\n      }\n\n      // Fallback 2: If no match found, land on first active player\n      const firstActivePlayer = effectivePlayers.findIndex(p => p && (p.bet > 0 || p.amount > 0));\n      const fallbackPosition = firstActivePlayer !== -1 ? firstActivePlayer : 0;\n      console.log(`üéØ Fallback: Landing on position ${fallbackPosition} (first active player)`);\n      performSpin(fallbackPosition, targetWinner);\n      return;\n    }\n    performSpin(winnerPosition, targetWinner);\n  }, [wheelState, stopIdleMovement, findWinnerPosition, effectivePlayers.length, onSpinComplete, CARD_WIDTH]);\n\n  // Separate function to perform the actual spin animation\n  const performSpin = useCallback((winnerPosition, targetWinner) => {\n    const wheel = wheelRef.current;\n    if (!wheel) return;\n\n    // Calculate precise landing position\n    const wheelWidth = wheel.offsetWidth;\n    const centerOffset = wheelWidth / 2;\n    const firstCard = wheel.querySelector('.roulette-card');\n    const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n    const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n    const totalCardSpacing = actualCardWidth + cardMargin;\n    console.log(`üìè Card measurements: width=${actualCardWidth}px, margin=${cardMargin}px, total=${totalCardSpacing}px`);\n    console.log(`üéØ Winner found at array position: ${winnerPosition}`);\n    console.log(`üéØ Wheel width: ${wheelWidth}px, Center offset: ${centerOffset}px`);\n\n    // CLASSIC SLOT MACHINE ANIMATION: Fast slide then slow down to winner\n    const cycleLength = effectivePlayers.length * totalCardSpacing;\n    const currentAbsolutePosition = Math.abs(currentPosition.current);\n\n    // Calculate how far we need to slide to get the winner centered\n    // The winner card should be perfectly centered in the wheel\n    const winnerOffset = winnerPosition * totalCardSpacing;\n\n    // Slide at least 3 full cycles to create that \"fast spinning\" effect\n    // Then land precisely on the winner in the next visible cycle\n    const minimumSpinDistance = cycleLength * 3; // At least 3 full cycles\n    const targetCycle = Math.ceil((currentAbsolutePosition + minimumSpinDistance) / cycleLength);\n    const finalWinnerPosition = targetCycle * cycleLength + winnerOffset;\n\n    // Calculate the exact position to center the winner card\n    // The center of the winner card should align with the center of the wheel\n    // Add -50px adjustment to land exactly on the winner\n    const finalPosition = -(finalWinnerPosition + actualCardWidth / 2 - centerOffset - 20);\n    console.log(`üé∞ Classic slot machine calculation:`);\n    console.log(`   - Current position: ${currentPosition.current}px`);\n    console.log(`   - Winner position in array: ${winnerPosition}`);\n    console.log(`   - Winner offset: ${winnerOffset}px`);\n    console.log(`   - Minimum spin distance: ${minimumSpinDistance}px`);\n    console.log(`   - Target cycle: ${targetCycle}`);\n    console.log(`   - Final winner position: ${finalWinnerPosition}px`);\n    console.log(`   - Final position: ${finalPosition}px`);\n    console.log(`   - Total slide distance: ${Math.abs(finalPosition - currentPosition.current)}px`);\n    console.log(`   - Expected center alignment: winner card center at ${centerOffset}px`);\n\n    // Start ticking sound for the spinning effect - OPTIMIZED\n    let tickInterval = setInterval(() => {\n      // Sound effects removed for performance\n    }, 200); // Reduced frequency for better performance\n\n    // STAGE 1: Fast spinning for 2 seconds\n    wheel.style.transitionTimingFunction = 'linear';\n    wheel.style.transitionDuration = '2000ms';\n\n    // Slide 80% of the way during fast phase\n    const fastPhasePosition = currentPosition.current + (finalPosition - currentPosition.current) * 1;\n    wheel.style.transform = `translate3d(${fastPhasePosition}px, 0px, 0px)`;\n    currentPosition.current = fastPhasePosition;\n\n    // STAGE 2: Slow down dramatically for final 20% over 3 seconds\n    setTimeout(() => {\n      // Slower ticking sound\n      clearInterval(tickInterval);\n      tickInterval = setInterval(() => {\n        // Spin sound removed for performance\n      }, 300); // Much slower ticking\n\n      wheel.style.transitionTimingFunction = 'cubic-bezier(0.05, 0.1, 0.05, 1)';\n      wheel.style.transitionDuration = '3000ms';\n      wheel.style.transform = `translate3d(${finalPosition}px, 0px, 0px)`;\n      currentPosition.current = finalPosition;\n\n      // Stop ticking after slowdown completes\n      setTimeout(() => {\n        clearInterval(tickInterval);\n      }, 3000);\n    }, 2000); // Wait 2 seconds for fast phase\n\n    // After total animation (2s + 3s = 5s), show winner\n    setTimeout(() => {\n      console.log('Classic slot machine animation completed, showing winner');\n      setWheelState('winner');\n\n      // Highlight the winner card\n      const allCards = wheel.querySelectorAll('.roulette-card');\n      console.log(`üéØ Highlighting winner at position ${winnerPosition} out of ${effectivePlayers.length} players`);\n\n      // Find the card that should be in the center (winner card)\n      const centerCardIndex = Math.round(Math.abs(finalPosition) / totalCardSpacing);\n      console.log(`üéØ Center card index: ${centerCardIndex}, should be winner card`);\n\n      // Verify the center card is indeed the winner\n      const centerCard = allCards[centerCardIndex];\n      if (centerCard) {\n        const centerCardPlayerIndex = centerCardIndex % effectivePlayers.length;\n        console.log(`üéØ Center card player index: ${centerCardPlayerIndex}, Winner position: ${winnerPosition}`);\n        if (centerCardPlayerIndex === winnerPosition) {\n          console.log(`‚úÖ Perfect! Center card is the winner`);\n        } else {\n          console.warn(`‚ö†Ô∏è Center card is not the winner. Center: ${centerCardPlayerIndex}, Winner: ${winnerPosition}`);\n        }\n      }\n\n      // After showcasing winner for 4 seconds, go to finished state\n      winnerShowcaseTimeoutRef.current = setTimeout(() => {\n        console.log('Winner showcase complete, entering finished state');\n\n        // Remove winner highlights\n        const highlightedCards = wheel.querySelectorAll('.winner-highlight');\n        highlightedCards.forEach(card => {\n          card.classList.remove('winner-highlight');\n        });\n\n        // Reset transition styles\n        wheel.style.transitionTimingFunction = '';\n        wheel.style.transitionDuration = '';\n\n        // Clear locked players\n        setLockedPlayers([]);\n        setWheelState('finished');\n        onSpinComplete === null || onSpinComplete === void 0 ? void 0 : onSpinComplete(targetWinner);\n      }, 4000); // Show winner for 4 seconds\n    }, 5000); // Wait 5 seconds for both phases (2s fast + 3s slow)\n  }, [effectivePlayers.length, CARD_WIDTH, onSpinComplete]);\n\n  // Handle state changes\n  useEffect(() => {\n    if (isSpinning && contractWinner && wheelState === 'waiting') {\n      // Backend responded with winner, start spinning\n      console.log('Starting roulette spin with winner:', contractWinner);\n      spinWheel(contractWinner);\n    } else if (isSpinning && !contractWinner && wheelState === 'idle') {\n      // Bet placed, stop and wait for backend\n      console.log('Stopping wheel, waiting for winner...');\n      setWheelState('waiting');\n      stopIdleMovement();\n    } else if (!isSpinning && wheelState !== 'idle' && wheelState !== 'winner' && wheelState !== 'finished') {\n      // Reset to idle state (but don't interrupt winner showcase or finished state)\n      console.log('Resetting to idle state');\n      setWheelState('idle');\n    }\n  }, [isSpinning, contractWinner, wheelState, spinWheel, stopIdleMovement]);\n\n  // Detect new game start and reset from finished state to idle\n  useEffect(() => {\n    // If we're in finished state and there's no winner (new game starting), reset to idle\n    if (wheelState === 'finished' && !contractWinner && !isSpinning) {\n      console.log('New game detected - resetting from finished to idle');\n      setWheelState('idle');\n    }\n  }, [wheelState, contractWinner, isSpinning]);\n\n  // Start/stop idle movement based on state\n  useEffect(() => {\n    if (wheelState === 'idle') {\n      startIdleMovement();\n    } else {\n      stopIdleMovement();\n    }\n    return () => stopIdleMovement();\n  }, [wheelState, startIdleMovement, stopIdleMovement]);\n\n  // Initialize wheel when effective players change (but not during winner showcase)\n  useEffect(() => {\n    // Don't reinitialize during winner showcase or finished state to preserve highlighting\n    if (wheelState !== 'winner' && wheelState !== 'finished') {\n      initWheel();\n    }\n  }, [initWheel, wheelState]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (winnerShowcaseTimeoutRef.current) {\n        clearTimeout(winnerShowcaseTimeoutRef.current);\n      }\n    };\n  }, []);\n  if (!effectivePlayers || effectivePlayers.length === 0) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"simple-carousel\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"carousel-message\",\n        children: \"Waiting for players to join...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 416,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 415,\n      columnNumber: 7\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"roulette-wrapper\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"roulette-selector\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 426,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: wheelRef,\n      className: \"roulette-wheel\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 429,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"wheel-state-indicator\",\n      children: [wheelState === 'idle' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFB0\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 433,\n        columnNumber: 35\n      }, this), wheelState === 'waiting' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\u23F3\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 434,\n        columnNumber: 38\n      }, this), wheelState === 'spinning' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFAF\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 435,\n        columnNumber: 39\n      }, this), wheelState === 'winner' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDF89\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 436,\n        columnNumber: 37\n      }, this), wheelState === 'finished' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFC1\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 437,\n        columnNumber: 39\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 432,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"absolute -top-1/4 -right-1/3 h-full opacity-75 will-change-transform z-[3] pointer-events-none\",\n      style: {\n        maskImage: 'linear-gradient(black, transparent 50%)'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"img\", {\n        src: \"/img/glare.webp\",\n        className: \"w-full object-cover object-center\",\n        alt: \"\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 445,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 441,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 424,\n    columnNumber: 5\n  }, this);\n};\n_s(SimpleCarousel, \"VIxi7lGLuxZ4CmPOzTtmWajujkE=\");\n_c = SimpleCarousel;\nexport default SimpleCarousel;\nvar _c;\n$RefreshReg$(_c, \"SimpleCarousel\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","TonIcon","jsxDEV","_jsxDEV","SimpleCarousel","players","isSpinning","onSpinComplete","contractWinner","totalJackpotValue","_s","wheelState","setWheelState","lockedPlayers","setLockedPlayers","wheelRef","idleAnimationRef","currentPosition","winnerShowcaseTimeoutRef","CARD_WIDTH","length","effectivePlayers","renderPlayerCard","player","key","amount","bet","isActive","avatar","address","name","username","displayName","toFixed","initWheel","current","wheel","innerHTML","row","document","createElement","className","copyIndex","forEach","playerIndex","card","appendChild","startIdleMovement","animate","_wheelRef$current","firstCard","querySelector","actualCardWidth","offsetWidth","cardMargin","parseInt","getComputedStyle","marginLeft","marginRight","totalCardSpacing","cycleWidth","resetPoint","style","transform","requestAnimationFrame","stopIdleMovement","cancelAnimationFrame","findWinnerPosition","winner","console","log","map","p","fullAddress","i","addressMatch","usernameMatch","winnerName","matchType","warn","spinWheel","targetWinner","winnerPosition","winnerUsername","includes","usernameSuffix","split","performSpin","firstActivePlayer","findIndex","fallbackPosition","wheelWidth","centerOffset","cycleLength","currentAbsolutePosition","Math","abs","winnerOffset","minimumSpinDistance","targetCycle","ceil","finalWinnerPosition","finalPosition","tickInterval","setInterval","transitionTimingFunction","transitionDuration","fastPhasePosition","setTimeout","clearInterval","allCards","querySelectorAll","centerCardIndex","round","centerCard","centerCardPlayerIndex","highlightedCards","classList","remove","clearTimeout","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","maskImage","src","alt","_c","$RefreshReg$"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/src/components/SimpleCarousel.js"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { TonIcon } from './IconComponents';\n\n\nconst SimpleCarousel = ({ \n  players, \n  isSpinning, \n  onSpinComplete, \n  contractWinner,\n  totalJackpotValue \n}) => {\n  const [wheelState, setWheelState] = useState('idle'); // 'idle', 'waiting', 'spinning', 'winner', 'finished'\n  const [lockedPlayers, setLockedPlayers] = useState([]); // Lock players during animation\n  const wheelRef = useRef();\n  const idleAnimationRef = useRef();\n  const currentPosition = useRef(0);\n  const winnerShowcaseTimeoutRef = useRef();\n  \n  // Card dimensions (matching roulette example)\n  const CARD_WIDTH = 20; // 75px + 3px margin on each side\n  \n  // Lock players when spinning starts to prevent them from changing during animation\n  useEffect(() => {\n    if (isSpinning && contractWinner && players.length > 0) {\n      // Locking players for animation\n      setLockedPlayers([...players]);\n    }\n  }, [isSpinning, contractWinner, players]);\n  \n  // Use locked players during animation, regular players otherwise\n  const effectivePlayers = wheelState === 'spinning' || wheelState === 'winner' ? lockedPlayers : players;\n  \n  // Render individual player card HTML\n  const renderPlayerCard = useCallback((player, key) => {\n    if (!player) {\n      return `\n        <div class=\"waiting-card\">\n          <div class=\"avatar-container\">\n            ?\n          </div>\n          <div class=\"waiting-text\">Waiting</div>\n          <div class=\"waiting-amount\">0.000</div>\n        </div>\n      `;\n    }\n    \n    // Always show the amount if it exists, regardless of isRealPlayer\n    const amount = player.bet || player.amount || 0;\n    const isActive = amount > 0;\n    const avatar = player.avatar && player.avatar !== '‚ùì' && player.avatar !== 'üë§' ? \n      player.avatar : \n      `https://robohash.org/${player.address || player.name}.png?size=100x100`;\n    const username = player.username || player.displayName || player.name || 'Player';\n    const bet = amount.toFixed(3);\n    \n    return `\n      <div class=\"player-card ${isActive ? 'active' : 'inactive'}\" data-key=\"${key}\">\n        <div class=\"card-content\">\n          <div class=\"avatar-container\">\n            <img src=\"${avatar}\" alt=\"${username}\" class=\"player-avatar\" />\n          </div>\n          <div class=\"player-info\">\n            <p class=\"player-name\">${username}</p>\n            <div class=\"bet-info\">\n              <div class=\"coin-icon ${!isActive ? 'grayscale' : ''}\"></div>\n              <span class=\"bet-amount\">${bet}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }, []);\n\n  // Initialize wheel with player rows for infinite scrolling\n  const initWheel = useCallback(() => {\n    if (!wheelRef.current || !effectivePlayers.length) return;\n    \n    const wheel = wheelRef.current;\n    wheel.innerHTML = ''; // Clear existing content\n    \n    // Create one continuous row with multiple player cycles for smooth infinite scroll\n    const row = document.createElement('div');\n    row.className = 'roulette-row';\n    \n    // Create enough copies to ensure smooth infinite scrolling (50 copies)\n    for (let copyIndex = 0; copyIndex < 50; copyIndex++) {\n      effectivePlayers.forEach((player, playerIndex) => {\n        const card = document.createElement('div');\n        card.className = 'roulette-card';\n        card.innerHTML = renderPlayerCard(player, `${copyIndex}-${playerIndex}`);\n        row.appendChild(card);\n      });\n    }\n    \n    wheel.appendChild(row);\n  }, [effectivePlayers, renderPlayerCard]);\n\n  // Idle movement - constant speed with true infinite scroll\n  const startIdleMovement = useCallback(() => {\n    if (!wheelRef.current || wheelState !== 'idle') return;\n    \n    const animate = () => {\n      if (wheelState !== 'idle') return;\n      \n      currentPosition.current -= 0.5; // Slower, smoother movement (0.5px per frame)\n      \n      // True infinite scroll - reset when we've scrolled through several player cycles\n      // Use actual card spacing for consistency\n      const firstCard = wheelRef.current?.querySelector('.roulette-card');\n      const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n      const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n      const totalCardSpacing = actualCardWidth + cardMargin;\n      \n      const cycleWidth = effectivePlayers.length * totalCardSpacing;\n      const resetPoint = -(cycleWidth * 10); // Reset after 10 cycles\n      \n      if (currentPosition.current <= resetPoint) {\n        // Reset to a position that maintains visual continuity\n        currentPosition.current = -(cycleWidth * 5); // Reset to middle area\n      }\n      \n      if (wheelRef.current) {\n        wheelRef.current.style.transform = `translate3d(${currentPosition.current}px, 0px, 0px)`;\n      }\n      \n      idleAnimationRef.current = requestAnimationFrame(animate);\n    };\n    \n    idleAnimationRef.current = requestAnimationFrame(animate);\n  }, [wheelState, effectivePlayers.length, CARD_WIDTH]);\n\n  // Stop idle movement\n  const stopIdleMovement = useCallback(() => {\n    if (idleAnimationRef.current) {\n      cancelAnimationFrame(idleAnimationRef.current);\n      idleAnimationRef.current = null;\n    }\n  }, []);\n\n  // Find winner position in player array\n  const findWinnerPosition = useCallback((winner) => {\n    if (!winner || !effectivePlayers.length) return -1;\n    \n    console.log('üîç Finding winner position for:', winner);\n    console.log('üîç Available players:', effectivePlayers.map(p => ({ \n      address: p?.address, \n      fullAddress: p?.fullAddress, \n      username: p?.username \n    })));\n    \n    for (let i = 0; i < effectivePlayers.length; i++) {\n      const player = effectivePlayers[i];\n      if (!player) continue;\n      \n      // Try multiple matching strategies\n      const addressMatch = (\n        (player.address && (player.address === winner.winner || player.address === winner.fullAddress)) ||\n        (player.fullAddress && (player.fullAddress === winner.winner || player.fullAddress === winner.fullAddress))\n      );\n      \n      const usernameMatch = (\n        (player.username && player.username === winner.username) ||\n        (player.displayName && player.displayName === winner.displayName) ||\n        (player.username && winner.username && player.username === winner.username) ||\n        (player.displayName && winner.winnerName && player.displayName === winner.winnerName)\n      );\n      \n      if (addressMatch || usernameMatch) {\n        console.log(`‚úÖ Found winner at position ${i}:`, {\n          player: { address: player.address, fullAddress: player.fullAddress, username: player.username },\n          winner: { winner: winner.winner, fullAddress: winner.fullAddress, username: winner.username },\n          matchType: addressMatch ? 'address' : 'username'\n        });\n        return i;\n      }\n    }\n    \n    console.warn('‚ùå Winner not found in player list. Winner data:', winner);\n    console.warn('‚ùå Available players:', effectivePlayers);\n    return -1;\n  }, [effectivePlayers]);\n\n  // Spin wheel function with improved accuracy\n  const spinWheel = useCallback((targetWinner) => {\n    if (wheelState === 'spinning' || !wheelRef.current) return;\n    \n    console.log('Starting spin with winner:', targetWinner);\n    \n    // Play launch sound when spin starts\n            // Launch sound removed for performance\n    \n    setWheelState('spinning');\n    stopIdleMovement();\n    \n    const winnerPosition = findWinnerPosition(targetWinner);\n    if (winnerPosition === -1) {\n      console.warn('Winner not found in player list, using fallback strategy');\n      \n      // Fallback 1: Try to find by username pattern (e.g., \"Player_3tsb\" -> look for any player with \"3tsb\")\n      const winnerUsername = targetWinner.username || targetWinner.winnerName;\n      if (winnerUsername && winnerUsername.includes('_')) {\n        const usernameSuffix = winnerUsername.split('_')[1];\n        for (let i = 0; i < effectivePlayers.length; i++) {\n          const player = effectivePlayers[i];\n          if (player && player.username && player.username.includes(usernameSuffix)) {\n            console.log(`üéØ Fallback: Found player with matching username suffix at position ${i}:`, player);\n            performSpin(i, targetWinner);\n            return;\n          }\n        }\n      }\n      \n      // Fallback 2: If no match found, land on first active player\n      const firstActivePlayer = effectivePlayers.findIndex(p => p && (p.bet > 0 || p.amount > 0));\n      const fallbackPosition = firstActivePlayer !== -1 ? firstActivePlayer : 0;\n      console.log(`üéØ Fallback: Landing on position ${fallbackPosition} (first active player)`);\n      performSpin(fallbackPosition, targetWinner);\n      return;\n    }\n          \n    performSpin(winnerPosition, targetWinner);\n    \n  }, [wheelState, stopIdleMovement, findWinnerPosition, effectivePlayers.length, onSpinComplete, CARD_WIDTH]);\n\n  // Separate function to perform the actual spin animation\n  const performSpin = useCallback((winnerPosition, targetWinner) => {\n    const wheel = wheelRef.current;\n    if (!wheel) return;\n\n    // Calculate precise landing position\n    const wheelWidth = wheel.offsetWidth;\n    const centerOffset = wheelWidth / 2;\n    const firstCard = wheel.querySelector('.roulette-card');\n    const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n    const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n    const totalCardSpacing = actualCardWidth + cardMargin;\n    \n    console.log(`üìè Card measurements: width=${actualCardWidth}px, margin=${cardMargin}px, total=${totalCardSpacing}px`);\n    console.log(`üéØ Winner found at array position: ${winnerPosition}`);\n    console.log(`üéØ Wheel width: ${wheelWidth}px, Center offset: ${centerOffset}px`);\n    \n    // CLASSIC SLOT MACHINE ANIMATION: Fast slide then slow down to winner\n    const cycleLength = effectivePlayers.length * totalCardSpacing;\n    const currentAbsolutePosition = Math.abs(currentPosition.current);\n    \n    // Calculate how far we need to slide to get the winner centered\n    // The winner card should be perfectly centered in the wheel\n    const winnerOffset = winnerPosition * totalCardSpacing;\n    \n    // Slide at least 3 full cycles to create that \"fast spinning\" effect\n    // Then land precisely on the winner in the next visible cycle\n    const minimumSpinDistance = cycleLength * 3; // At least 3 full cycles\n    const targetCycle = Math.ceil((currentAbsolutePosition + minimumSpinDistance) / cycleLength);\n    const finalWinnerPosition = (targetCycle * cycleLength) + winnerOffset;\n    \n    // Calculate the exact position to center the winner card\n    // The center of the winner card should align with the center of the wheel\n    // Add -50px adjustment to land exactly on the winner\n    const finalPosition = -(finalWinnerPosition + (actualCardWidth / 2) - centerOffset - 20);\n    \n    console.log(`üé∞ Classic slot machine calculation:`);\n    console.log(`   - Current position: ${currentPosition.current}px`);\n    console.log(`   - Winner position in array: ${winnerPosition}`);\n    console.log(`   - Winner offset: ${winnerOffset}px`);\n    console.log(`   - Minimum spin distance: ${minimumSpinDistance}px`);\n    console.log(`   - Target cycle: ${targetCycle}`);\n    console.log(`   - Final winner position: ${finalWinnerPosition}px`);\n    console.log(`   - Final position: ${finalPosition}px`);\n    console.log(`   - Total slide distance: ${Math.abs(finalPosition - currentPosition.current)}px`);\n    console.log(`   - Expected center alignment: winner card center at ${centerOffset}px`);\n    \n    // Start ticking sound for the spinning effect - OPTIMIZED\n    let tickInterval = setInterval(() => {\n      // Sound effects removed for performance\n    }, 200); // Reduced frequency for better performance\n    \n    // STAGE 1: Fast spinning for 2 seconds\n    wheel.style.transitionTimingFunction = 'linear';\n    wheel.style.transitionDuration = '2000ms';\n    \n    // Slide 80% of the way during fast phase\n    const fastPhasePosition = currentPosition.current + ((finalPosition - currentPosition.current) * 1);\n    wheel.style.transform = `translate3d(${fastPhasePosition}px, 0px, 0px)`;\n    currentPosition.current = fastPhasePosition;\n    \n    // STAGE 2: Slow down dramatically for final 20% over 3 seconds\n    setTimeout(() => {\n      // Slower ticking sound\n      clearInterval(tickInterval);\n      tickInterval = setInterval(() => {\n        // Spin sound removed for performance\n      }, 300); // Much slower ticking\n      \n      wheel.style.transitionTimingFunction = 'cubic-bezier(0.05, 0.1, 0.05, 1)';\n      wheel.style.transitionDuration = '3000ms';\n      wheel.style.transform = `translate3d(${finalPosition}px, 0px, 0px)`;\n      currentPosition.current = finalPosition;\n      \n      // Stop ticking after slowdown completes\n      setTimeout(() => {\n        clearInterval(tickInterval);\n      }, 3000);\n      \n    }, 2000); // Wait 2 seconds for fast phase\n    \n    // After total animation (2s + 3s = 5s), show winner\n    setTimeout(() => {\n      console.log('Classic slot machine animation completed, showing winner');\n      setWheelState('winner');\n      \n      // Highlight the winner card\n      const allCards = wheel.querySelectorAll('.roulette-card');\n      console.log(`üéØ Highlighting winner at position ${winnerPosition} out of ${effectivePlayers.length} players`);\n      \n      // Find the card that should be in the center (winner card)\n      const centerCardIndex = Math.round(Math.abs(finalPosition) / totalCardSpacing);\n      console.log(`üéØ Center card index: ${centerCardIndex}, should be winner card`);\n      \n      \n      \n      // Verify the center card is indeed the winner\n      const centerCard = allCards[centerCardIndex];\n      if (centerCard) {\n        const centerCardPlayerIndex = centerCardIndex % effectivePlayers.length;\n        console.log(`üéØ Center card player index: ${centerCardPlayerIndex}, Winner position: ${winnerPosition}`);\n        if (centerCardPlayerIndex === winnerPosition) {\n          console.log(`‚úÖ Perfect! Center card is the winner`);\n        } else {\n          console.warn(`‚ö†Ô∏è Center card is not the winner. Center: ${centerCardPlayerIndex}, Winner: ${winnerPosition}`);\n        }\n      }\n      \n      // After showcasing winner for 4 seconds, go to finished state\n      winnerShowcaseTimeoutRef.current = setTimeout(() => {\n        console.log('Winner showcase complete, entering finished state');\n        \n        // Remove winner highlights\n        const highlightedCards = wheel.querySelectorAll('.winner-highlight');\n        highlightedCards.forEach(card => {\n          card.classList.remove('winner-highlight');\n        });\n        \n        // Reset transition styles\n        wheel.style.transitionTimingFunction = '';\n        wheel.style.transitionDuration = '';\n        \n        // Clear locked players\n        setLockedPlayers([]);\n        \n        setWheelState('finished');\n        onSpinComplete?.(targetWinner);\n      }, 4000); // Show winner for 4 seconds\n      \n    }, 5000); // Wait 5 seconds for both phases (2s fast + 3s slow)\n    \n  }, [effectivePlayers.length, CARD_WIDTH, onSpinComplete]);\n\n  // Handle state changes\n  useEffect(() => {\n    if (isSpinning && contractWinner && wheelState === 'waiting') {\n      // Backend responded with winner, start spinning\n      console.log('Starting roulette spin with winner:', contractWinner);\n      spinWheel(contractWinner);\n    } else if (isSpinning && !contractWinner && wheelState === 'idle') {\n      // Bet placed, stop and wait for backend\n      console.log('Stopping wheel, waiting for winner...');\n      setWheelState('waiting');\n      stopIdleMovement();\n    } else if (!isSpinning && wheelState !== 'idle' && wheelState !== 'winner' && wheelState !== 'finished') {\n      // Reset to idle state (but don't interrupt winner showcase or finished state)\n      console.log('Resetting to idle state');\n      setWheelState('idle');\n    }\n  }, [isSpinning, contractWinner, wheelState, spinWheel, stopIdleMovement]);\n\n  // Detect new game start and reset from finished state to idle\n  useEffect(() => {\n    // If we're in finished state and there's no winner (new game starting), reset to idle\n    if (wheelState === 'finished' && !contractWinner && !isSpinning) {\n      console.log('New game detected - resetting from finished to idle');\n      setWheelState('idle');\n    }\n  }, [wheelState, contractWinner, isSpinning]);\n\n  // Start/stop idle movement based on state\n  useEffect(() => {\n    if (wheelState === 'idle') {\n      startIdleMovement();\n    } else {\n      stopIdleMovement();\n    }\n    \n    return () => stopIdleMovement();\n  }, [wheelState, startIdleMovement, stopIdleMovement]);\n\n  // Initialize wheel when effective players change (but not during winner showcase)\n  useEffect(() => {\n    // Don't reinitialize during winner showcase or finished state to preserve highlighting\n    if (wheelState !== 'winner' && wheelState !== 'finished') {\n      initWheel();\n    }\n  }, [initWheel, wheelState]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (winnerShowcaseTimeoutRef.current) {\n        clearTimeout(winnerShowcaseTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  if (!effectivePlayers || effectivePlayers.length === 0) {\n    return (\n      <div className=\"simple-carousel\">\n        <div className=\"carousel-message\">\n          Waiting for players to join...\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"roulette-wrapper\">\n      {/* Center selector line */}\n      <div className=\"roulette-selector\"></div>\n      \n      {/* Spinning wheel */}\n      <div ref={wheelRef} className=\"roulette-wheel\"></div>\n      \n      {/* State indicator */}\n      <div className=\"wheel-state-indicator\">\n        {wheelState === 'idle' && <span>üé∞</span>}\n        {wheelState === 'waiting' && <span>‚è≥</span>}\n        {wheelState === 'spinning' && <span>üéØ</span>}\n        {wheelState === 'winner' && <span>üéâ</span>}\n        {wheelState === 'finished' && <span>üèÅ</span>}\n      </div>\n      \n      {/* Glare Effect */}\n      <div \n        className=\"absolute -top-1/4 -right-1/3 h-full opacity-75 will-change-transform z-[3] pointer-events-none\"\n        style={{ maskImage: 'linear-gradient(black, transparent 50%)' }}\n      >\n        <img src=\"/img/glare.webp\" className=\"w-full object-cover object-center\" alt=\"\" />\n              </div>\n    </div>\n  );\n};\n\nexport default SimpleCarousel; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}