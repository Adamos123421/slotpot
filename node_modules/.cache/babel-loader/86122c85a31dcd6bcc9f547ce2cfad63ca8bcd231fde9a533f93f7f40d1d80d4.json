{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.address = exports.Address = void 0;\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nconst crc16_1 = require(\"../utils/crc16\");\nconst bounceable_tag = 0x11;\nconst non_bounceable_tag = 0x51;\nconst test_flag = 0x80;\nfunction parseFriendlyAddress(src) {\n  if (typeof src === 'string' && !Address.isFriendly(src)) {\n    throw new Error('Unknown address type');\n  }\n  const data = Buffer.isBuffer(src) ? src : Buffer.from(src, 'base64');\n  // 1byte tag + 1byte workchain + 32 bytes hash + 2 byte crc\n  if (data.length !== 36) {\n    throw new Error('Unknown address type: byte length is not equal to 36');\n  }\n  // Prepare data\n  const addr = data.subarray(0, 34);\n  const crc = data.subarray(34, 36);\n  const calcedCrc = (0, crc16_1.crc16)(addr);\n  if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {\n    throw new Error('Invalid checksum: ' + src);\n  }\n  // Parse tag\n  let tag = addr[0];\n  let isTestOnly = false;\n  let isBounceable = false;\n  if (tag & test_flag) {\n    isTestOnly = true;\n    tag = tag ^ test_flag;\n  }\n  if (tag !== bounceable_tag && tag !== non_bounceable_tag) throw \"Unknown address tag\";\n  isBounceable = tag === bounceable_tag;\n  let workchain = null;\n  if (addr[1] === 0xff) {\n    // TODO we should read signed integer here\n    workchain = -1;\n  } else {\n    workchain = addr[1];\n  }\n  const hashPart = addr.subarray(2, 34);\n  return {\n    isTestOnly,\n    isBounceable,\n    workchain,\n    hashPart\n  };\n}\nclass Address {\n  static isAddress(src) {\n    return src instanceof Address;\n  }\n  static isFriendly(source) {\n    // Check length\n    if (source.length !== 48) {\n      return false;\n    }\n    // Check if address is valid base64\n    if (!/[A-Za-z0-9+/_-]+/.test(source)) {\n      return false;\n    }\n    return true;\n  }\n  static isRaw(source) {\n    // Check if has delimiter\n    if (source.indexOf(':') === -1) {\n      return false;\n    }\n    let [wc, hash] = source.split(':');\n    // wc is not valid\n    if (!Number.isInteger(parseFloat(wc))) {\n      return false;\n    }\n    // hash is not valid\n    if (!/[a-f0-9]+/.test(hash.toLowerCase())) {\n      return false;\n    }\n    // has is not correct\n    if (hash.length !== 64) {\n      return false;\n    }\n    return true;\n  }\n  static normalize(source) {\n    if (typeof source === 'string') {\n      return Address.parse(source).toString();\n    } else {\n      return source.toString();\n    }\n  }\n  static parse(source) {\n    if (Address.isFriendly(source)) {\n      return this.parseFriendly(source).address;\n    } else if (Address.isRaw(source)) {\n      return this.parseRaw(source);\n    } else {\n      throw new Error('Unknown address type: ' + source);\n    }\n  }\n  static parseRaw(source) {\n    let workChain = parseInt(source.split(\":\")[0]);\n    let hash = Buffer.from(source.split(\":\")[1], 'hex');\n    return new Address(workChain, hash);\n  }\n  static parseFriendly(source) {\n    if (Buffer.isBuffer(source)) {\n      let r = parseFriendlyAddress(source);\n      return {\n        isBounceable: r.isBounceable,\n        isTestOnly: r.isTestOnly,\n        address: new Address(r.workchain, r.hashPart)\n      };\n    } else {\n      let addr = source.replace(/\\-/g, '+').replace(/_/g, '\\/'); // Convert from url-friendly to true base64\n      let r = parseFriendlyAddress(addr);\n      return {\n        isBounceable: r.isBounceable,\n        isTestOnly: r.isTestOnly,\n        address: new Address(r.workchain, r.hashPart)\n      };\n    }\n  }\n  constructor(workChain, hash) {\n    this.toRawString = () => {\n      return this.workChain + ':' + this.hash.toString('hex');\n    };\n    this.toRaw = () => {\n      const addressWithChecksum = Buffer.alloc(36);\n      addressWithChecksum.set(this.hash);\n      addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);\n      return addressWithChecksum;\n    };\n    this.toStringBuffer = args => {\n      let testOnly = args && args.testOnly !== undefined ? args.testOnly : false;\n      let bounceable = args && args.bounceable !== undefined ? args.bounceable : true;\n      let tag = bounceable ? bounceable_tag : non_bounceable_tag;\n      if (testOnly) {\n        tag |= test_flag;\n      }\n      const addr = Buffer.alloc(34);\n      addr[0] = tag;\n      addr[1] = this.workChain;\n      addr.set(this.hash, 2);\n      const addressWithChecksum = Buffer.alloc(36);\n      addressWithChecksum.set(addr);\n      addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);\n      return addressWithChecksum;\n    };\n    this.toString = args => {\n      let urlSafe = args && args.urlSafe !== undefined ? args.urlSafe : true;\n      let buffer = this.toStringBuffer(args);\n      if (urlSafe) {\n        return buffer.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_');\n      } else {\n        return buffer.toString('base64');\n      }\n    };\n    this[_a] = () => this.toString();\n    if (hash.length !== 32) {\n      throw new Error('Invalid address hash length: ' + hash.length);\n    }\n    this.workChain = workChain;\n    this.hash = hash;\n    Object.freeze(this);\n  }\n  equals(src) {\n    if (src.workChain !== this.workChain) {\n      return false;\n    }\n    return src.hash.equals(this.hash);\n  }\n}\nexports.Address = Address;\n_a = symbol_inspect_1.default;\nfunction address(src) {\n  return Address.parse(src);\n}\nexports.address = address;","map":{"version":3,"names":["__importDefault","mod","__esModule","_a","Object","defineProperty","exports","value","address","Address","symbol_inspect_1","require","crc16_1","bounceable_tag","non_bounceable_tag","test_flag","parseFriendlyAddress","src","isFriendly","Error","data","Buffer","isBuffer","from","length","addr","subarray","crc","calcedCrc","crc16","tag","isTestOnly","isBounceable","workchain","hashPart","isAddress","source","test","isRaw","indexOf","wc","hash","split","Number","isInteger","parseFloat","toLowerCase","normalize","parse","toString","parseFriendly","parseRaw","workChain","parseInt","r","replace","constructor","toRawString","toRaw","addressWithChecksum","alloc","set","toStringBuffer","args","testOnly","undefined","bounceable","urlSafe","buffer","freeze","equals","default"],"sources":["C:/Users/adams/Downloads/GLL/slotpot/node_modules/@ton/core/dist/address/Address.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.address = exports.Address = void 0;\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nconst crc16_1 = require(\"../utils/crc16\");\nconst bounceable_tag = 0x11;\nconst non_bounceable_tag = 0x51;\nconst test_flag = 0x80;\nfunction parseFriendlyAddress(src) {\n    if (typeof src === 'string' && !Address.isFriendly(src)) {\n        throw new Error('Unknown address type');\n    }\n    const data = Buffer.isBuffer(src) ? src : Buffer.from(src, 'base64');\n    // 1byte tag + 1byte workchain + 32 bytes hash + 2 byte crc\n    if (data.length !== 36) {\n        throw new Error('Unknown address type: byte length is not equal to 36');\n    }\n    // Prepare data\n    const addr = data.subarray(0, 34);\n    const crc = data.subarray(34, 36);\n    const calcedCrc = (0, crc16_1.crc16)(addr);\n    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {\n        throw new Error('Invalid checksum: ' + src);\n    }\n    // Parse tag\n    let tag = addr[0];\n    let isTestOnly = false;\n    let isBounceable = false;\n    if (tag & test_flag) {\n        isTestOnly = true;\n        tag = tag ^ test_flag;\n    }\n    if ((tag !== bounceable_tag) && (tag !== non_bounceable_tag))\n        throw \"Unknown address tag\";\n    isBounceable = tag === bounceable_tag;\n    let workchain = null;\n    if (addr[1] === 0xff) { // TODO we should read signed integer here\n        workchain = -1;\n    }\n    else {\n        workchain = addr[1];\n    }\n    const hashPart = addr.subarray(2, 34);\n    return { isTestOnly, isBounceable, workchain, hashPart };\n}\nclass Address {\n    static isAddress(src) {\n        return src instanceof Address;\n    }\n    static isFriendly(source) {\n        // Check length\n        if (source.length !== 48) {\n            return false;\n        }\n        // Check if address is valid base64\n        if (!/[A-Za-z0-9+/_-]+/.test(source)) {\n            return false;\n        }\n        return true;\n    }\n    static isRaw(source) {\n        // Check if has delimiter\n        if (source.indexOf(':') === -1) {\n            return false;\n        }\n        let [wc, hash] = source.split(':');\n        // wc is not valid\n        if (!Number.isInteger(parseFloat(wc))) {\n            return false;\n        }\n        // hash is not valid\n        if (!/[a-f0-9]+/.test(hash.toLowerCase())) {\n            return false;\n        }\n        // has is not correct\n        if (hash.length !== 64) {\n            return false;\n        }\n        return true;\n    }\n    static normalize(source) {\n        if (typeof source === 'string') {\n            return Address.parse(source).toString();\n        }\n        else {\n            return source.toString();\n        }\n    }\n    static parse(source) {\n        if (Address.isFriendly(source)) {\n            return this.parseFriendly(source).address;\n        }\n        else if (Address.isRaw(source)) {\n            return this.parseRaw(source);\n        }\n        else {\n            throw new Error('Unknown address type: ' + source);\n        }\n    }\n    static parseRaw(source) {\n        let workChain = parseInt(source.split(\":\")[0]);\n        let hash = Buffer.from(source.split(\":\")[1], 'hex');\n        return new Address(workChain, hash);\n    }\n    static parseFriendly(source) {\n        if (Buffer.isBuffer(source)) {\n            let r = parseFriendlyAddress(source);\n            return {\n                isBounceable: r.isBounceable,\n                isTestOnly: r.isTestOnly,\n                address: new Address(r.workchain, r.hashPart)\n            };\n        }\n        else {\n            let addr = source.replace(/\\-/g, '+').replace(/_/g, '\\/'); // Convert from url-friendly to true base64\n            let r = parseFriendlyAddress(addr);\n            return {\n                isBounceable: r.isBounceable,\n                isTestOnly: r.isTestOnly,\n                address: new Address(r.workchain, r.hashPart)\n            };\n        }\n    }\n    constructor(workChain, hash) {\n        this.toRawString = () => {\n            return this.workChain + ':' + this.hash.toString('hex');\n        };\n        this.toRaw = () => {\n            const addressWithChecksum = Buffer.alloc(36);\n            addressWithChecksum.set(this.hash);\n            addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);\n            return addressWithChecksum;\n        };\n        this.toStringBuffer = (args) => {\n            let testOnly = (args && args.testOnly !== undefined) ? args.testOnly : false;\n            let bounceable = (args && args.bounceable !== undefined) ? args.bounceable : true;\n            let tag = bounceable ? bounceable_tag : non_bounceable_tag;\n            if (testOnly) {\n                tag |= test_flag;\n            }\n            const addr = Buffer.alloc(34);\n            addr[0] = tag;\n            addr[1] = this.workChain;\n            addr.set(this.hash, 2);\n            const addressWithChecksum = Buffer.alloc(36);\n            addressWithChecksum.set(addr);\n            addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);\n            return addressWithChecksum;\n        };\n        this.toString = (args) => {\n            let urlSafe = (args && args.urlSafe !== undefined) ? args.urlSafe : true;\n            let buffer = this.toStringBuffer(args);\n            if (urlSafe) {\n                return buffer.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_');\n            }\n            else {\n                return buffer.toString('base64');\n            }\n        };\n        this[_a] = () => this.toString();\n        if (hash.length !== 32) {\n            throw new Error('Invalid address hash length: ' + hash.length);\n        }\n        this.workChain = workChain;\n        this.hash = hash;\n        Object.freeze(this);\n    }\n    equals(src) {\n        if (src.workChain !== this.workChain) {\n            return false;\n        }\n        return src.hash.equals(this.hash);\n    }\n}\nexports.Address = Address;\n_a = symbol_inspect_1.default;\nfunction address(src) {\n    return Address.parse(src);\n}\nexports.address = address;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}