{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TupleReader = void 0;\nclass TupleReader {\n  constructor(items) {\n    this.items = [...items];\n  }\n  get remaining() {\n    return this.items.length;\n  }\n  peek() {\n    if (this.items.length === 0) {\n      throw Error('EOF');\n    }\n    return this.items[0];\n  }\n  pop() {\n    if (this.items.length === 0) {\n      throw Error('EOF');\n    }\n    let res = this.items[0];\n    this.items.splice(0, 1);\n    return res;\n  }\n  skip(num = 1) {\n    for (let i = 0; i < num; i++) {\n      this.pop();\n    }\n    return this;\n  }\n  readBigNumber() {\n    let popped = this.pop();\n    if (popped.type !== 'int') {\n      throw Error('Not a number');\n    }\n    return popped.value;\n  }\n  readBigNumberOpt() {\n    let popped = this.pop();\n    if (popped.type === 'null') {\n      return null;\n    }\n    if (popped.type !== 'int') {\n      throw Error('Not a number');\n    }\n    return popped.value;\n  }\n  readNumber() {\n    return Number(this.readBigNumber());\n  }\n  readNumberOpt() {\n    let r = this.readBigNumberOpt();\n    if (r !== null) {\n      return Number(r);\n    } else {\n      return null;\n    }\n  }\n  readBoolean() {\n    let res = this.readNumber();\n    return res === 0 ? false : true;\n  }\n  readBooleanOpt() {\n    let res = this.readNumberOpt();\n    if (res !== null) {\n      return res === 0 ? false : true;\n    } else {\n      return null;\n    }\n  }\n  readAddress() {\n    let r = this.readCell().beginParse().loadAddress();\n    if (r !== null) {\n      return r;\n    } else {\n      throw Error('Not an address');\n    }\n  }\n  readAddressOpt() {\n    let r = this.readCellOpt();\n    if (r !== null) {\n      return r.beginParse().loadMaybeAddress();\n    } else {\n      return null;\n    }\n  }\n  readCell() {\n    let popped = this.pop();\n    if (popped.type !== 'cell' && popped.type !== 'slice' && popped.type !== 'builder') {\n      throw Error('Not a cell: ' + popped.type);\n    }\n    return popped.cell;\n  }\n  readCellOpt() {\n    let popped = this.pop();\n    if (popped.type === 'null') {\n      return null;\n    }\n    if (popped.type !== 'cell' && popped.type !== 'slice' && popped.type !== 'builder') {\n      throw Error('Not a cell');\n    }\n    return popped.cell;\n  }\n  readTuple() {\n    let popped = this.pop();\n    if (popped.type !== 'tuple') {\n      throw Error('Not a tuple');\n    }\n    return new TupleReader(popped.items);\n  }\n  readTupleOpt() {\n    let popped = this.pop();\n    if (popped.type === 'null') {\n      return null;\n    }\n    if (popped.type !== 'tuple') {\n      throw Error('Not a tuple');\n    }\n    return new TupleReader(popped.items);\n  }\n  static readLispList(reader) {\n    const result = [];\n    let tail = reader;\n    while (tail !== null) {\n      var head = tail.pop();\n      if (tail.items.length === 0 || tail.items[0].type !== 'tuple' && tail.items[0].type !== 'null') {\n        throw Error('Lisp list consists only from (any, tuple) elements and ends with null');\n      }\n      tail = tail.readTupleOpt();\n      result.push(head);\n    }\n    return result;\n  }\n  readLispListDirect() {\n    if (this.items.length === 1 && this.items[0].type === 'null') {\n      return [];\n    }\n    return TupleReader.readLispList(this);\n  }\n  readLispList() {\n    return TupleReader.readLispList(this.readTupleOpt());\n  }\n  readBuffer() {\n    let s = this.readCell().beginParse();\n    if (s.remainingRefs !== 0) {\n      throw Error('Not a buffer');\n    }\n    if (s.remainingBits % 8 !== 0) {\n      throw Error('Not a buffer');\n    }\n    return s.loadBuffer(s.remainingBits / 8);\n  }\n  readBufferOpt() {\n    let popped = this.peek();\n    if (popped.type === 'null') {\n      return null;\n    }\n    let s = this.readCell().beginParse();\n    if (s.remainingRefs !== 0) {\n      throw Error('Not a buffer');\n    }\n    if (s.remainingBits % 8 !== 0) {\n      throw Error('Not a buffer');\n    }\n    return s.loadBuffer(s.remainingBits / 8);\n  }\n  readString() {\n    let s = this.readCell().beginParse();\n    return s.loadStringTail();\n  }\n  readStringOpt() {\n    let popped = this.peek();\n    if (popped.type === 'null') {\n      return null;\n    }\n    let s = this.readCell().beginParse();\n    return s.loadStringTail();\n  }\n}\nexports.TupleReader = TupleReader;","map":{"version":3,"names":["Object","defineProperty","exports","value","TupleReader","constructor","items","remaining","length","peek","Error","pop","res","splice","skip","num","i","readBigNumber","popped","type","readBigNumberOpt","readNumber","Number","readNumberOpt","r","readBoolean","readBooleanOpt","readAddress","readCell","beginParse","loadAddress","readAddressOpt","readCellOpt","loadMaybeAddress","cell","readTuple","readTupleOpt","readLispList","reader","result","tail","head","push","readLispListDirect","readBuffer","s","remainingRefs","remainingBits","loadBuffer","readBufferOpt","readString","loadStringTail","readStringOpt"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/tuple/reader.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TupleReader = void 0;\nclass TupleReader {\n    constructor(items) {\n        this.items = [...items];\n    }\n    get remaining() {\n        return this.items.length;\n    }\n    peek() {\n        if (this.items.length === 0) {\n            throw Error('EOF');\n        }\n        return this.items[0];\n    }\n    pop() {\n        if (this.items.length === 0) {\n            throw Error('EOF');\n        }\n        let res = this.items[0];\n        this.items.splice(0, 1);\n        return res;\n    }\n    skip(num = 1) {\n        for (let i = 0; i < num; i++) {\n            this.pop();\n        }\n        return this;\n    }\n    readBigNumber() {\n        let popped = this.pop();\n        if (popped.type !== 'int') {\n            throw Error('Not a number');\n        }\n        return popped.value;\n    }\n    readBigNumberOpt() {\n        let popped = this.pop();\n        if (popped.type === 'null') {\n            return null;\n        }\n        if (popped.type !== 'int') {\n            throw Error('Not a number');\n        }\n        return popped.value;\n    }\n    readNumber() {\n        return Number(this.readBigNumber());\n    }\n    readNumberOpt() {\n        let r = this.readBigNumberOpt();\n        if (r !== null) {\n            return Number(r);\n        }\n        else {\n            return null;\n        }\n    }\n    readBoolean() {\n        let res = this.readNumber();\n        return res === 0 ? false : true;\n    }\n    readBooleanOpt() {\n        let res = this.readNumberOpt();\n        if (res !== null) {\n            return res === 0 ? false : true;\n        }\n        else {\n            return null;\n        }\n    }\n    readAddress() {\n        let r = this.readCell().beginParse().loadAddress();\n        if (r !== null) {\n            return r;\n        }\n        else {\n            throw Error('Not an address');\n        }\n    }\n    readAddressOpt() {\n        let r = this.readCellOpt();\n        if (r !== null) {\n            return r.beginParse().loadMaybeAddress();\n        }\n        else {\n            return null;\n        }\n    }\n    readCell() {\n        let popped = this.pop();\n        if (popped.type !== 'cell' && popped.type !== 'slice' && popped.type !== 'builder') {\n            throw Error('Not a cell: ' + popped.type);\n        }\n        return popped.cell;\n    }\n    readCellOpt() {\n        let popped = this.pop();\n        if (popped.type === 'null') {\n            return null;\n        }\n        if (popped.type !== 'cell' && popped.type !== 'slice' && popped.type !== 'builder') {\n            throw Error('Not a cell');\n        }\n        return popped.cell;\n    }\n    readTuple() {\n        let popped = this.pop();\n        if (popped.type !== 'tuple') {\n            throw Error('Not a tuple');\n        }\n        return new TupleReader(popped.items);\n    }\n    readTupleOpt() {\n        let popped = this.pop();\n        if (popped.type === 'null') {\n            return null;\n        }\n        if (popped.type !== 'tuple') {\n            throw Error('Not a tuple');\n        }\n        return new TupleReader(popped.items);\n    }\n    static readLispList(reader) {\n        const result = [];\n        let tail = reader;\n        while (tail !== null) {\n            var head = tail.pop();\n            if (tail.items.length === 0 || (tail.items[0].type !== 'tuple' && tail.items[0].type !== 'null')) {\n                throw Error('Lisp list consists only from (any, tuple) elements and ends with null');\n            }\n            tail = tail.readTupleOpt();\n            result.push(head);\n        }\n        return result;\n    }\n    readLispListDirect() {\n        if (this.items.length === 1 && this.items[0].type === 'null') {\n            return [];\n        }\n        return TupleReader.readLispList(this);\n    }\n    readLispList() {\n        return TupleReader.readLispList(this.readTupleOpt());\n    }\n    readBuffer() {\n        let s = this.readCell().beginParse();\n        if (s.remainingRefs !== 0) {\n            throw Error('Not a buffer');\n        }\n        if (s.remainingBits % 8 !== 0) {\n            throw Error('Not a buffer');\n        }\n        return s.loadBuffer(s.remainingBits / 8);\n    }\n    readBufferOpt() {\n        let popped = this.peek();\n        if (popped.type === 'null') {\n            return null;\n        }\n        let s = this.readCell().beginParse();\n        if (s.remainingRefs !== 0) {\n            throw Error('Not a buffer');\n        }\n        if (s.remainingBits % 8 !== 0) {\n            throw Error('Not a buffer');\n        }\n        return s.loadBuffer(s.remainingBits / 8);\n    }\n    readString() {\n        let s = this.readCell().beginParse();\n        return s.loadStringTail();\n    }\n    readStringOpt() {\n        let popped = this.peek();\n        if (popped.type === 'null') {\n            return null;\n        }\n        let s = this.readCell().beginParse();\n        return s.loadStringTail();\n    }\n}\nexports.TupleReader = TupleReader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}