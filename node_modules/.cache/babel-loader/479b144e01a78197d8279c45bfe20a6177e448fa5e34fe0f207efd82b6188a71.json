{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitReader = void 0;\nconst Address_1 = require(\"../address/Address\");\nconst ExternalAddress_1 = require(\"../address/ExternalAddress\");\n/**\n * Class for reading bit strings\n */\nclass BitReader {\n  constructor(bits) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._checkpoints = [];\n    this._bits = bits;\n    this._offset = offset;\n  }\n  /**\n   * Offset in source bit string\n   */\n  get offset() {\n    return this._offset;\n  }\n  /**\n   * Number of bits remaining\n   */\n  get remaining() {\n    return this._bits.length - this._offset;\n  }\n  /**\n   * Skip bits\n   * @param bits number of bits to skip\n   */\n  skip(bits) {\n    if (bits < 0 || this._offset + bits > this._bits.length) {\n      throw new Error(\"Index \".concat(this._offset + bits, \" is out of bounds\"));\n    }\n    this._offset += bits;\n  }\n  /**\n   * Reset to the beginning or latest checkpoint\n   */\n  reset() {\n    if (this._checkpoints.length > 0) {\n      this._offset = this._checkpoints.pop();\n    } else {\n      this._offset = 0;\n    }\n  }\n  /**\n   * Save checkpoint\n   */\n  save() {\n    this._checkpoints.push(this._offset);\n  }\n  /**\n   * Load a single bit\n   * @returns true if the bit is set, false otherwise\n   */\n  loadBit() {\n    let r = this._bits.at(this._offset);\n    this._offset++;\n    return r;\n  }\n  /**\n   * Preload bit\n   * @returns true if the bit is set, false otherwise\n   */\n  preloadBit() {\n    return this._bits.at(this._offset);\n  }\n  /**\n   * Load bit string\n   * @param bits number of bits to read\n   * @returns new bitstring\n   */\n  loadBits(bits) {\n    let r = this._bits.substring(this._offset, bits);\n    this._offset += bits;\n    return r;\n  }\n  /**\n   * Preload bit string\n   * @param bits number of bits to read\n   * @returns new bitstring\n   */\n  preloadBits(bits) {\n    return this._bits.substring(this._offset, bits);\n  }\n  /**\n   * Load buffer\n   * @param bytes number of bytes\n   * @returns new buffer\n   */\n  loadBuffer(bytes) {\n    let buf = this._preloadBuffer(bytes, this._offset);\n    this._offset += bytes * 8;\n    return buf;\n  }\n  /**\n   * Preload buffer\n   * @param bytes number of bytes\n   * @returns new buffer\n   */\n  preloadBuffer(bytes) {\n    return this._preloadBuffer(bytes, this._offset);\n  }\n  /**\n   * Load uint value\n   * @param bits uint bits\n   * @returns read value as number\n   */\n  loadUint(bits) {\n    return Number(this.loadUintBig(bits));\n  }\n  /**\n   * Load uint value as bigint\n   * @param bits uint bits\n   * @returns read value as bigint\n   */\n  loadUintBig(bits) {\n    let loaded = this.preloadUintBig(bits);\n    this._offset += bits;\n    return loaded;\n  }\n  /**\n   * Preload uint value\n   * @param bits uint bits\n   * @returns read value as number\n   */\n  preloadUint(bits) {\n    return Number(this._preloadUint(bits, this._offset));\n  }\n  /**\n   * Preload uint value as bigint\n   * @param bits uint bits\n   * @returns read value as bigint\n   */\n  preloadUintBig(bits) {\n    return this._preloadUint(bits, this._offset);\n  }\n  /**\n   * Load int value\n   * @param bits int bits\n   * @returns read value as bigint\n   */\n  loadInt(bits) {\n    let res = this._preloadInt(bits, this._offset);\n    this._offset += bits;\n    return Number(res);\n  }\n  /**\n   * Load int value as bigint\n   * @param bits int bits\n   * @returns read value as bigint\n   */\n  loadIntBig(bits) {\n    let res = this._preloadInt(bits, this._offset);\n    this._offset += bits;\n    return res;\n  }\n  /**\n   * Preload int value\n   * @param bits int bits\n   * @returns read value as bigint\n   */\n  preloadInt(bits) {\n    return Number(this._preloadInt(bits, this._offset));\n  }\n  /**\n   * Preload int value\n   * @param bits int bits\n   * @returns read value as bigint\n   */\n  preloadIntBig(bits) {\n    return this._preloadInt(bits, this._offset);\n  }\n  /**\n   * Load varuint value\n   * @param bits number of bits to read the size\n   * @returns read value as bigint\n   */\n  loadVarUint(bits) {\n    let size = Number(this.loadUint(bits));\n    return Number(this.loadUintBig(size * 8));\n  }\n  /**\n   * Load varuint value\n   * @param bits number of bits to read the size\n   * @returns read value as bigint\n   */\n  loadVarUintBig(bits) {\n    let size = Number(this.loadUint(bits));\n    return this.loadUintBig(size * 8);\n  }\n  /**\n   * Preload varuint value\n   * @param bits number of bits to read the size\n   * @returns read value as bigint\n   */\n  preloadVarUint(bits) {\n    let size = Number(this._preloadUint(bits, this._offset));\n    return Number(this._preloadUint(size * 8, this._offset + bits));\n  }\n  /**\n   * Preload varuint value\n   * @param bits number of bits to read the size\n   * @returns read value as bigint\n   */\n  preloadVarUintBig(bits) {\n    let size = Number(this._preloadUint(bits, this._offset));\n    return this._preloadUint(size * 8, this._offset + bits);\n  }\n  /**\n   * Load varint value\n   * @param bits number of bits to read the size\n   * @returns read value as bigint\n   */\n  loadVarInt(bits) {\n    let size = Number(this.loadUint(bits));\n    return Number(this.loadIntBig(size * 8));\n  }\n  /**\n   * Load varint value\n   * @param bits number of bits to read the size\n   * @returns read value as bigint\n   */\n  loadVarIntBig(bits) {\n    let size = Number(this.loadUint(bits));\n    return this.loadIntBig(size * 8);\n  }\n  /**\n   * Preload varint value\n   * @param bits number of bits to read the size\n   * @returns read value as bigint\n   */\n  preloadVarInt(bits) {\n    let size = Number(this._preloadUint(bits, this._offset));\n    return Number(this._preloadInt(size * 8, this._offset + bits));\n  }\n  /**\n   * Preload varint value\n   * @param bits number of bits to read the size\n   * @returns read value as bigint\n   */\n  preloadVarIntBig(bits) {\n    let size = Number(this._preloadUint(bits, this._offset));\n    return this._preloadInt(size * 8, this._offset + bits);\n  }\n  /**\n   * Load coins value\n   * @returns read value as bigint\n   */\n  loadCoins() {\n    return this.loadVarUintBig(4);\n  }\n  /**\n   * Preload coins value\n   * @returns read value as bigint\n   */\n  preloadCoins() {\n    return this.preloadVarUintBig(4);\n  }\n  /**\n   * Load Address\n   * @returns Address\n   */\n  loadAddress() {\n    let type = Number(this._preloadUint(2, this._offset));\n    if (type === 2) {\n      return this._loadInternalAddress();\n    } else {\n      throw new Error(\"Invalid address: \" + type);\n    }\n  }\n  /**\n   * Load internal address\n   * @returns Address or null\n   */\n  loadMaybeAddress() {\n    let type = Number(this._preloadUint(2, this._offset));\n    if (type === 0) {\n      this._offset += 2;\n      return null;\n    } else if (type === 2) {\n      return this._loadInternalAddress();\n    } else {\n      throw new Error(\"Invalid address\");\n    }\n  }\n  /**\n   * Load external address\n   * @returns ExternalAddress\n   */\n  loadExternalAddress() {\n    let type = Number(this._preloadUint(2, this._offset));\n    if (type === 1) {\n      return this._loadExternalAddress();\n    } else {\n      throw new Error(\"Invalid address\");\n    }\n  }\n  /**\n   * Load external address\n   * @returns ExternalAddress or null\n   */\n  loadMaybeExternalAddress() {\n    let type = Number(this._preloadUint(2, this._offset));\n    if (type === 0) {\n      this._offset += 2;\n      return null;\n    } else if (type === 1) {\n      return this._loadExternalAddress();\n    } else {\n      throw new Error(\"Invalid address\");\n    }\n  }\n  /**\n   * Read address of any type\n   * @returns Address or ExternalAddress or null\n   */\n  loadAddressAny() {\n    let type = Number(this._preloadUint(2, this._offset));\n    if (type === 0) {\n      this._offset += 2;\n      return null;\n    } else if (type === 2) {\n      return this._loadInternalAddress();\n    } else if (type === 1) {\n      return this._loadExternalAddress();\n    } else if (type === 3) {\n      throw Error('Unsupported');\n    } else {\n      throw Error('Unreachable');\n    }\n  }\n  /**\n   * Load bit string that was padded to make it byte alligned. Used in BOC serialization\n   * @param bytes number of bytes to read\n   */\n  loadPaddedBits(bits) {\n    // Check that number of bits is byte alligned\n    if (bits % 8 !== 0) {\n      throw new Error(\"Invalid number of bits\");\n    }\n    // Skip padding\n    let length = bits;\n    while (true) {\n      if (this._bits.at(this._offset + length - 1)) {\n        length--;\n        break;\n      } else {\n        length--;\n      }\n    }\n    // Read substring\n    let r = this._bits.substring(this._offset, length);\n    this._offset += bits;\n    return r;\n  }\n  /**\n   * Clone BitReader\n   */\n  clone() {\n    return new BitReader(this._bits, this._offset);\n  }\n  /**\n   * Preload int from specific offset\n   * @param bits bits to preload\n   * @param offset offset to start from\n   * @returns read value as bigint\n   */\n  _preloadInt(bits, offset) {\n    if (bits == 0) {\n      return 0n;\n    }\n    let sign = this._bits.at(offset);\n    let res = 0n;\n    for (let i = 0; i < bits - 1; i++) {\n      if (this._bits.at(offset + 1 + i)) {\n        res += 1n << BigInt(bits - i - 1 - 1);\n      }\n    }\n    if (sign) {\n      res = res - (1n << BigInt(bits - 1));\n    }\n    return res;\n  }\n  /**\n   * Preload uint from specific offset\n   * @param bits bits to preload\n   * @param offset offset to start from\n   * @returns read value as bigint\n   */\n  _preloadUint(bits, offset) {\n    if (bits == 0) {\n      return 0n;\n    }\n    let res = 0n;\n    for (let i = 0; i < bits; i++) {\n      if (this._bits.at(offset + i)) {\n        res += 1n << BigInt(bits - i - 1);\n      }\n    }\n    return res;\n  }\n  _preloadBuffer(bytes, offset) {\n    // Try to load fast\n    let fastBuffer = this._bits.subbuffer(offset, bytes * 8);\n    if (fastBuffer) {\n      return fastBuffer;\n    }\n    // Load slow\n    let buf = Buffer.alloc(bytes);\n    for (let i = 0; i < bytes; i++) {\n      buf[i] = Number(this._preloadUint(8, offset + i * 8));\n    }\n    return buf;\n  }\n  _loadInternalAddress() {\n    let type = Number(this._preloadUint(2, this._offset));\n    if (type !== 2) {\n      throw Error('Invalid address');\n    }\n    // No Anycast supported\n    if (this._preloadUint(1, this._offset + 2) !== 0n) {\n      throw Error('Invalid address');\n    }\n    // Read address\n    let wc = Number(this._preloadInt(8, this._offset + 3));\n    let hash = this._preloadBuffer(32, this._offset + 11);\n    // Update offset\n    this._offset += 267;\n    return new Address_1.Address(wc, hash);\n  }\n  _loadExternalAddress() {\n    let type = Number(this._preloadUint(2, this._offset));\n    if (type !== 1) {\n      throw Error('Invalid address');\n    }\n    // Load length\n    let bits = Number(this._preloadUint(9, this._offset + 2));\n    // Load address\n    let value = this._preloadUint(bits, this._offset + 11);\n    // Update offset\n    this._offset += 11 + bits;\n    return new ExternalAddress_1.ExternalAddress(value, bits);\n  }\n}\nexports.BitReader = BitReader;","map":{"version":3,"names":["Object","defineProperty","exports","value","BitReader","Address_1","require","ExternalAddress_1","constructor","bits","offset","arguments","length","undefined","_checkpoints","_bits","_offset","remaining","skip","Error","concat","reset","pop","save","push","loadBit","r","at","preloadBit","loadBits","substring","preloadBits","loadBuffer","bytes","buf","_preloadBuffer","preloadBuffer","loadUint","Number","loadUintBig","loaded","preloadUintBig","preloadUint","_preloadUint","loadInt","res","_preloadInt","loadIntBig","preloadInt","preloadIntBig","loadVarUint","size","loadVarUintBig","preloadVarUint","preloadVarUintBig","loadVarInt","loadVarIntBig","preloadVarInt","preloadVarIntBig","loadCoins","preloadCoins","loadAddress","type","_loadInternalAddress","loadMaybeAddress","loadExternalAddress","_loadExternalAddress","loadMaybeExternalAddress","loadAddressAny","loadPaddedBits","clone","sign","i","BigInt","fastBuffer","subbuffer","Buffer","alloc","wc","hash","Address","ExternalAddress"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/boc/BitReader.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitReader = void 0;\nconst Address_1 = require(\"../address/Address\");\nconst ExternalAddress_1 = require(\"../address/ExternalAddress\");\n/**\n * Class for reading bit strings\n */\nclass BitReader {\n    constructor(bits, offset = 0) {\n        this._checkpoints = [];\n        this._bits = bits;\n        this._offset = offset;\n    }\n    /**\n     * Offset in source bit string\n     */\n    get offset() {\n        return this._offset;\n    }\n    /**\n     * Number of bits remaining\n     */\n    get remaining() {\n        return this._bits.length - this._offset;\n    }\n    /**\n     * Skip bits\n     * @param bits number of bits to skip\n     */\n    skip(bits) {\n        if (bits < 0 || this._offset + bits > this._bits.length) {\n            throw new Error(`Index ${this._offset + bits} is out of bounds`);\n        }\n        this._offset += bits;\n    }\n    /**\n     * Reset to the beginning or latest checkpoint\n     */\n    reset() {\n        if (this._checkpoints.length > 0) {\n            this._offset = this._checkpoints.pop();\n        }\n        else {\n            this._offset = 0;\n        }\n    }\n    /**\n     * Save checkpoint\n     */\n    save() {\n        this._checkpoints.push(this._offset);\n    }\n    /**\n     * Load a single bit\n     * @returns true if the bit is set, false otherwise\n     */\n    loadBit() {\n        let r = this._bits.at(this._offset);\n        this._offset++;\n        return r;\n    }\n    /**\n     * Preload bit\n     * @returns true if the bit is set, false otherwise\n     */\n    preloadBit() {\n        return this._bits.at(this._offset);\n    }\n    /**\n     * Load bit string\n     * @param bits number of bits to read\n     * @returns new bitstring\n     */\n    loadBits(bits) {\n        let r = this._bits.substring(this._offset, bits);\n        this._offset += bits;\n        return r;\n    }\n    /**\n     * Preload bit string\n     * @param bits number of bits to read\n     * @returns new bitstring\n     */\n    preloadBits(bits) {\n        return this._bits.substring(this._offset, bits);\n    }\n    /**\n     * Load buffer\n     * @param bytes number of bytes\n     * @returns new buffer\n     */\n    loadBuffer(bytes) {\n        let buf = this._preloadBuffer(bytes, this._offset);\n        this._offset += bytes * 8;\n        return buf;\n    }\n    /**\n     * Preload buffer\n     * @param bytes number of bytes\n     * @returns new buffer\n     */\n    preloadBuffer(bytes) {\n        return this._preloadBuffer(bytes, this._offset);\n    }\n    /**\n     * Load uint value\n     * @param bits uint bits\n     * @returns read value as number\n     */\n    loadUint(bits) {\n        return Number(this.loadUintBig(bits));\n    }\n    /**\n     * Load uint value as bigint\n     * @param bits uint bits\n     * @returns read value as bigint\n     */\n    loadUintBig(bits) {\n        let loaded = this.preloadUintBig(bits);\n        this._offset += bits;\n        return loaded;\n    }\n    /**\n     * Preload uint value\n     * @param bits uint bits\n     * @returns read value as number\n     */\n    preloadUint(bits) {\n        return Number(this._preloadUint(bits, this._offset));\n    }\n    /**\n     * Preload uint value as bigint\n     * @param bits uint bits\n     * @returns read value as bigint\n     */\n    preloadUintBig(bits) {\n        return this._preloadUint(bits, this._offset);\n    }\n    /**\n     * Load int value\n     * @param bits int bits\n     * @returns read value as bigint\n     */\n    loadInt(bits) {\n        let res = this._preloadInt(bits, this._offset);\n        this._offset += bits;\n        return Number(res);\n    }\n    /**\n     * Load int value as bigint\n     * @param bits int bits\n     * @returns read value as bigint\n     */\n    loadIntBig(bits) {\n        let res = this._preloadInt(bits, this._offset);\n        this._offset += bits;\n        return res;\n    }\n    /**\n     * Preload int value\n     * @param bits int bits\n     * @returns read value as bigint\n     */\n    preloadInt(bits) {\n        return Number(this._preloadInt(bits, this._offset));\n    }\n    /**\n     * Preload int value\n     * @param bits int bits\n     * @returns read value as bigint\n     */\n    preloadIntBig(bits) {\n        return this._preloadInt(bits, this._offset);\n    }\n    /**\n     * Load varuint value\n     * @param bits number of bits to read the size\n     * @returns read value as bigint\n     */\n    loadVarUint(bits) {\n        let size = Number(this.loadUint(bits));\n        return Number(this.loadUintBig(size * 8));\n    }\n    /**\n     * Load varuint value\n     * @param bits number of bits to read the size\n     * @returns read value as bigint\n     */\n    loadVarUintBig(bits) {\n        let size = Number(this.loadUint(bits));\n        return this.loadUintBig(size * 8);\n    }\n    /**\n     * Preload varuint value\n     * @param bits number of bits to read the size\n     * @returns read value as bigint\n     */\n    preloadVarUint(bits) {\n        let size = Number(this._preloadUint(bits, this._offset));\n        return Number(this._preloadUint(size * 8, this._offset + bits));\n    }\n    /**\n     * Preload varuint value\n     * @param bits number of bits to read the size\n     * @returns read value as bigint\n     */\n    preloadVarUintBig(bits) {\n        let size = Number(this._preloadUint(bits, this._offset));\n        return this._preloadUint(size * 8, this._offset + bits);\n    }\n    /**\n     * Load varint value\n     * @param bits number of bits to read the size\n     * @returns read value as bigint\n     */\n    loadVarInt(bits) {\n        let size = Number(this.loadUint(bits));\n        return Number(this.loadIntBig(size * 8));\n    }\n    /**\n     * Load varint value\n     * @param bits number of bits to read the size\n     * @returns read value as bigint\n     */\n    loadVarIntBig(bits) {\n        let size = Number(this.loadUint(bits));\n        return this.loadIntBig(size * 8);\n    }\n    /**\n     * Preload varint value\n     * @param bits number of bits to read the size\n     * @returns read value as bigint\n     */\n    preloadVarInt(bits) {\n        let size = Number(this._preloadUint(bits, this._offset));\n        return Number(this._preloadInt(size * 8, this._offset + bits));\n    }\n    /**\n     * Preload varint value\n     * @param bits number of bits to read the size\n     * @returns read value as bigint\n     */\n    preloadVarIntBig(bits) {\n        let size = Number(this._preloadUint(bits, this._offset));\n        return this._preloadInt(size * 8, this._offset + bits);\n    }\n    /**\n     * Load coins value\n     * @returns read value as bigint\n     */\n    loadCoins() {\n        return this.loadVarUintBig(4);\n    }\n    /**\n     * Preload coins value\n     * @returns read value as bigint\n     */\n    preloadCoins() {\n        return this.preloadVarUintBig(4);\n    }\n    /**\n     * Load Address\n     * @returns Address\n     */\n    loadAddress() {\n        let type = Number(this._preloadUint(2, this._offset));\n        if (type === 2) {\n            return this._loadInternalAddress();\n        }\n        else {\n            throw new Error(\"Invalid address: \" + type);\n        }\n    }\n    /**\n     * Load internal address\n     * @returns Address or null\n     */\n    loadMaybeAddress() {\n        let type = Number(this._preloadUint(2, this._offset));\n        if (type === 0) {\n            this._offset += 2;\n            return null;\n        }\n        else if (type === 2) {\n            return this._loadInternalAddress();\n        }\n        else {\n            throw new Error(\"Invalid address\");\n        }\n    }\n    /**\n     * Load external address\n     * @returns ExternalAddress\n     */\n    loadExternalAddress() {\n        let type = Number(this._preloadUint(2, this._offset));\n        if (type === 1) {\n            return this._loadExternalAddress();\n        }\n        else {\n            throw new Error(\"Invalid address\");\n        }\n    }\n    /**\n     * Load external address\n     * @returns ExternalAddress or null\n     */\n    loadMaybeExternalAddress() {\n        let type = Number(this._preloadUint(2, this._offset));\n        if (type === 0) {\n            this._offset += 2;\n            return null;\n        }\n        else if (type === 1) {\n            return this._loadExternalAddress();\n        }\n        else {\n            throw new Error(\"Invalid address\");\n        }\n    }\n    /**\n     * Read address of any type\n     * @returns Address or ExternalAddress or null\n     */\n    loadAddressAny() {\n        let type = Number(this._preloadUint(2, this._offset));\n        if (type === 0) {\n            this._offset += 2;\n            return null;\n        }\n        else if (type === 2) {\n            return this._loadInternalAddress();\n        }\n        else if (type === 1) {\n            return this._loadExternalAddress();\n        }\n        else if (type === 3) {\n            throw Error('Unsupported');\n        }\n        else {\n            throw Error('Unreachable');\n        }\n    }\n    /**\n     * Load bit string that was padded to make it byte alligned. Used in BOC serialization\n     * @param bytes number of bytes to read\n     */\n    loadPaddedBits(bits) {\n        // Check that number of bits is byte alligned\n        if (bits % 8 !== 0) {\n            throw new Error(\"Invalid number of bits\");\n        }\n        // Skip padding\n        let length = bits;\n        while (true) {\n            if (this._bits.at(this._offset + length - 1)) {\n                length--;\n                break;\n            }\n            else {\n                length--;\n            }\n        }\n        // Read substring\n        let r = this._bits.substring(this._offset, length);\n        this._offset += bits;\n        return r;\n    }\n    /**\n     * Clone BitReader\n     */\n    clone() {\n        return new BitReader(this._bits, this._offset);\n    }\n    /**\n     * Preload int from specific offset\n     * @param bits bits to preload\n     * @param offset offset to start from\n     * @returns read value as bigint\n     */\n    _preloadInt(bits, offset) {\n        if (bits == 0) {\n            return 0n;\n        }\n        let sign = this._bits.at(offset);\n        let res = 0n;\n        for (let i = 0; i < bits - 1; i++) {\n            if (this._bits.at(offset + 1 + i)) {\n                res += 1n << BigInt(bits - i - 1 - 1);\n            }\n        }\n        if (sign) {\n            res = res - (1n << BigInt(bits - 1));\n        }\n        return res;\n    }\n    /**\n     * Preload uint from specific offset\n     * @param bits bits to preload\n     * @param offset offset to start from\n     * @returns read value as bigint\n     */\n    _preloadUint(bits, offset) {\n        if (bits == 0) {\n            return 0n;\n        }\n        let res = 0n;\n        for (let i = 0; i < bits; i++) {\n            if (this._bits.at(offset + i)) {\n                res += 1n << BigInt(bits - i - 1);\n            }\n        }\n        return res;\n    }\n    _preloadBuffer(bytes, offset) {\n        // Try to load fast\n        let fastBuffer = this._bits.subbuffer(offset, bytes * 8);\n        if (fastBuffer) {\n            return fastBuffer;\n        }\n        // Load slow\n        let buf = Buffer.alloc(bytes);\n        for (let i = 0; i < bytes; i++) {\n            buf[i] = Number(this._preloadUint(8, offset + i * 8));\n        }\n        return buf;\n    }\n    _loadInternalAddress() {\n        let type = Number(this._preloadUint(2, this._offset));\n        if (type !== 2) {\n            throw Error('Invalid address');\n        }\n        // No Anycast supported\n        if (this._preloadUint(1, this._offset + 2) !== 0n) {\n            throw Error('Invalid address');\n        }\n        // Read address\n        let wc = Number(this._preloadInt(8, this._offset + 3));\n        let hash = this._preloadBuffer(32, this._offset + 11);\n        // Update offset\n        this._offset += 267;\n        return new Address_1.Address(wc, hash);\n    }\n    _loadExternalAddress() {\n        let type = Number(this._preloadUint(2, this._offset));\n        if (type !== 1) {\n            throw Error('Invalid address');\n        }\n        // Load length\n        let bits = Number(this._preloadUint(9, this._offset + 2));\n        // Load address\n        let value = this._preloadUint(bits, this._offset + 11);\n        // Update offset\n        this._offset += 11 + bits;\n        return new ExternalAddress_1.ExternalAddress(value, bits);\n    }\n}\nexports.BitReader = BitReader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}