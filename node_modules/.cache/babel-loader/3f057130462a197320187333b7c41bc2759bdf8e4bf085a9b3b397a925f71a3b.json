{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitBuilder = void 0;\nconst Address_1 = require(\"../address/Address\");\nconst ExternalAddress_1 = require(\"../address/ExternalAddress\");\nconst BitString_1 = require(\"./BitString\");\n/**\n * Class for building bit strings\n */\nclass BitBuilder {\n  constructor(size = 1023) {\n    this._buffer = Buffer.alloc(Math.ceil(size / 8));\n    this._length = 0;\n  }\n  /**\n   * Current number of bits written\n   */\n  get length() {\n    return this._length;\n  }\n  /**\n   * Write a single bit\n   * @param value bit to write, true or positive number for 1, false or zero or negative for 0\n   */\n  writeBit(value) {\n    // Check overflow\n    let n = this._length;\n    if (n > this._buffer.length * 8) {\n      throw new Error(\"BitBuilder overflow\");\n    }\n    // Set bit\n    if (typeof value === 'boolean' && value === true || typeof value === 'number' && value > 0) {\n      this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;\n    }\n    // Advance\n    this._length++;\n  }\n  /**\n   * Copy bits from BitString\n   * @param src source bits\n   */\n  writeBits(src) {\n    for (let i = 0; i < src.length; i++) {\n      this.writeBit(src.at(i));\n    }\n  }\n  /**\n   * Write bits from buffer\n   * @param src source buffer\n   */\n  writeBuffer(src) {\n    // Special case for aligned offsets\n    if (this._length % 8 === 0) {\n      if (this._length + src.length * 8 > this._buffer.length * 8) {\n        throw new Error(\"BitBuilder overflow\");\n      }\n      src.copy(this._buffer, this._length / 8);\n      this._length += src.length * 8;\n    } else {\n      for (let i = 0; i < src.length; i++) {\n        this.writeUint(src[i], 8);\n      }\n    }\n  }\n  /**\n   * Write uint value\n   * @param value value as bigint or number\n   * @param bits number of bits to write\n   */\n  writeUint(value, bits) {\n    if (bits < 0 || !Number.isSafeInteger(bits)) {\n      throw Error(`invalid bit length. Got ${bits}`);\n    }\n    const v = BigInt(value);\n    if (bits === 0) {\n      if (v !== 0n) {\n        throw Error(`value is not zero for ${bits} bits. Got ${value}`);\n      } else {\n        return;\n      }\n    }\n    const vBits = 1n << BigInt(bits);\n    if (v < 0 || v >= vBits) {\n      throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);\n    }\n    if (this._length + bits > this._buffer.length * 8) {\n      throw new Error(\"BitBuilder overflow\");\n    }\n    const tillByte = 8 - this._length % 8;\n    if (tillByte > 0) {\n      const bidx = Math.floor(this._length / 8);\n      if (bits < tillByte) {\n        const wb = Number(v);\n        this._buffer[bidx] |= wb << tillByte - bits;\n        this._length += bits;\n      } else {\n        const wb = Number(v >> BigInt(bits - tillByte));\n        this._buffer[bidx] |= wb;\n        this._length += tillByte;\n      }\n    }\n    bits -= tillByte;\n    while (bits > 0) {\n      if (bits >= 8) {\n        this._buffer[this._length / 8] = Number(v >> BigInt(bits - 8) & 0xffn);\n        this._length += 8;\n        bits -= 8;\n      } else {\n        this._buffer[this._length / 8] = Number(v << BigInt(8 - bits) & 0xffn);\n        this._length += bits;\n        bits = 0;\n      }\n    }\n  }\n  /**\n   * Write int value\n   * @param value value as bigint or number\n   * @param bits number of bits to write\n   */\n  writeInt(value, bits) {\n    let v = BigInt(value);\n    if (bits < 0 || !Number.isSafeInteger(bits)) {\n      throw Error(`invalid bit length. Got ${bits}`);\n    }\n    // Corner case for zero bits\n    if (bits === 0) {\n      if (value !== 0n) {\n        throw Error(`value is not zero for ${bits} bits. Got ${value}`);\n      } else {\n        return;\n      }\n    }\n    // Corner case for one bit\n    if (bits === 1) {\n      if (value !== -1n && value !== 0n) {\n        throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);\n      } else {\n        this.writeBit(value === -1n);\n        return;\n      }\n    }\n    // Check input\n    let vBits = 1n << BigInt(bits) - 1n;\n    if (v < -vBits || v >= vBits) {\n      throw Error(`value is out of range for ${bits} bits. Got ${value}`);\n    }\n    // Write sign\n    if (v < 0) {\n      this.writeBit(true);\n      v = vBits + v;\n    } else {\n      this.writeBit(false);\n    }\n    // Write value\n    this.writeUint(v, bits - 1);\n  }\n  /**\n   * Wrtie var uint value, used for serializing coins\n   * @param value value to write as bigint or number\n   * @param bits header bits to write size\n   */\n  writeVarUint(value, bits) {\n    let v = BigInt(value);\n    if (bits < 0 || !Number.isSafeInteger(bits)) {\n      throw Error(`invalid bit length. Got ${bits}`);\n    }\n    if (v < 0) {\n      throw Error(`value is negative. Got ${value}`);\n    }\n    // Corner case for zero\n    if (v === 0n) {\n      // Write zero size\n      this.writeUint(0, bits);\n      return;\n    }\n    // Calculate size\n    const sizeBytes = Math.ceil(v.toString(2).length / 8); // Fastest way in most environments\n    const sizeBits = sizeBytes * 8;\n    // Write size\n    this.writeUint(sizeBytes, bits);\n    // Write number\n    this.writeUint(v, sizeBits);\n  }\n  /**\n   * Wrtie var int value, used for serializing coins\n   * @param value value to write as bigint or number\n   * @param bits header bits to write size\n   */\n  writeVarInt(value, bits) {\n    let v = BigInt(value);\n    if (bits < 0 || !Number.isSafeInteger(bits)) {\n      throw Error(`invalid bit length. Got ${bits}`);\n    }\n    // Corner case for zero\n    if (v === 0n) {\n      // Write zero size\n      this.writeUint(0, bits);\n      return;\n    }\n    // Calculate size\n    let v2 = v > 0 ? v : -v;\n    const sizeBytes = 1 + Math.ceil(v2.toString(2).length / 8); // Fastest way in most environments\n    const sizeBits = sizeBytes * 8;\n    // Write size\n    this.writeUint(sizeBytes, bits);\n    // Write number\n    this.writeInt(v, sizeBits);\n  }\n  /**\n   * Write coins in var uint format\n   * @param amount amount to write\n   */\n  writeCoins(amount) {\n    this.writeVarUint(amount, 4);\n  }\n  /**\n   * Write address\n   * @param address write address or address external\n   */\n  writeAddress(address) {\n    // Is empty address\n    if (address === null || address === undefined) {\n      this.writeUint(0, 2); // Empty address\n      return;\n    }\n    // Is Internal Address\n    if (Address_1.Address.isAddress(address)) {\n      this.writeUint(2, 2); // Internal address\n      this.writeUint(0, 1); // No anycast\n      this.writeInt(address.workChain, 8);\n      this.writeBuffer(address.hash);\n      return;\n    }\n    // Is External Address\n    if (ExternalAddress_1.ExternalAddress.isAddress(address)) {\n      this.writeUint(1, 2); // External address\n      this.writeUint(address.bits, 9);\n      this.writeUint(address.value, address.bits);\n      return;\n    }\n    // Invalid address\n    throw Error(`Invalid address. Got ${address}`);\n  }\n  /**\n   * Build BitString\n   * @returns result bit string\n   */\n  build() {\n    return new BitString_1.BitString(this._buffer, 0, this._length);\n  }\n  /**\n   * Build into Buffer\n   * @returns result buffer\n   */\n  buffer() {\n    if (this._length % 8 !== 0) {\n      throw new Error(\"BitBuilder buffer is not byte aligned\");\n    }\n    return this._buffer.subarray(0, this._length / 8);\n  }\n}\nexports.BitBuilder = BitBuilder;","map":{"version":3,"names":["Object","defineProperty","exports","value","BitBuilder","Address_1","require","ExternalAddress_1","BitString_1","constructor","size","_buffer","Buffer","alloc","Math","ceil","_length","length","writeBit","n","Error","writeBits","src","i","at","writeBuffer","copy","writeUint","bits","Number","isSafeInteger","v","BigInt","vBits","tillByte","bidx","floor","wb","writeInt","writeVarUint","sizeBytes","toString","sizeBits","writeVarInt","v2","writeCoins","amount","writeAddress","address","undefined","Address","isAddress","workChain","hash","ExternalAddress","build","BitString","buffer","subarray"],"sources":["C:/Users/adams/Downloads/GLL/slotpot/node_modules/@ton/core/dist/boc/BitBuilder.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitBuilder = void 0;\nconst Address_1 = require(\"../address/Address\");\nconst ExternalAddress_1 = require(\"../address/ExternalAddress\");\nconst BitString_1 = require(\"./BitString\");\n/**\n * Class for building bit strings\n */\nclass BitBuilder {\n    constructor(size = 1023) {\n        this._buffer = Buffer.alloc(Math.ceil(size / 8));\n        this._length = 0;\n    }\n    /**\n     * Current number of bits written\n     */\n    get length() {\n        return this._length;\n    }\n    /**\n     * Write a single bit\n     * @param value bit to write, true or positive number for 1, false or zero or negative for 0\n     */\n    writeBit(value) {\n        // Check overflow\n        let n = this._length;\n        if (n > this._buffer.length * 8) {\n            throw new Error(\"BitBuilder overflow\");\n        }\n        // Set bit\n        if ((typeof value === 'boolean' && value === true) || (typeof value === 'number' && value > 0)) {\n            this._buffer[(n / 8) | 0] |= 1 << (7 - (n % 8));\n        }\n        // Advance\n        this._length++;\n    }\n    /**\n     * Copy bits from BitString\n     * @param src source bits\n     */\n    writeBits(src) {\n        for (let i = 0; i < src.length; i++) {\n            this.writeBit(src.at(i));\n        }\n    }\n    /**\n     * Write bits from buffer\n     * @param src source buffer\n     */\n    writeBuffer(src) {\n        // Special case for aligned offsets\n        if (this._length % 8 === 0) {\n            if (this._length + src.length * 8 > this._buffer.length * 8) {\n                throw new Error(\"BitBuilder overflow\");\n            }\n            src.copy(this._buffer, this._length / 8);\n            this._length += src.length * 8;\n        }\n        else {\n            for (let i = 0; i < src.length; i++) {\n                this.writeUint(src[i], 8);\n            }\n        }\n    }\n    /**\n     * Write uint value\n     * @param value value as bigint or number\n     * @param bits number of bits to write\n     */\n    writeUint(value, bits) {\n        if (bits < 0 || !Number.isSafeInteger(bits)) {\n            throw Error(`invalid bit length. Got ${bits}`);\n        }\n        const v = BigInt(value);\n        if (bits === 0) {\n            if (v !== 0n) {\n                throw Error(`value is not zero for ${bits} bits. Got ${value}`);\n            }\n            else {\n                return;\n            }\n        }\n        const vBits = (1n << BigInt(bits));\n        if (v < 0 || v >= vBits) {\n            throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);\n        }\n        if (this._length + bits > this._buffer.length * 8) {\n            throw new Error(\"BitBuilder overflow\");\n        }\n        const tillByte = 8 - (this._length % 8);\n        if (tillByte > 0) {\n            const bidx = Math.floor(this._length / 8);\n            if (bits < tillByte) {\n                const wb = Number(v);\n                this._buffer[bidx] |= wb << (tillByte - bits);\n                this._length += bits;\n            }\n            else {\n                const wb = Number(v >> BigInt(bits - tillByte));\n                this._buffer[bidx] |= wb;\n                this._length += tillByte;\n            }\n        }\n        bits -= tillByte;\n        while (bits > 0) {\n            if (bits >= 8) {\n                this._buffer[this._length / 8] = Number((v >> BigInt(bits - 8)) & 0xffn);\n                this._length += 8;\n                bits -= 8;\n            }\n            else {\n                this._buffer[this._length / 8] = Number((v << BigInt(8 - bits)) & 0xffn);\n                this._length += bits;\n                bits = 0;\n            }\n        }\n    }\n    /**\n     * Write int value\n     * @param value value as bigint or number\n     * @param bits number of bits to write\n     */\n    writeInt(value, bits) {\n        let v = BigInt(value);\n        if (bits < 0 || !Number.isSafeInteger(bits)) {\n            throw Error(`invalid bit length. Got ${bits}`);\n        }\n        // Corner case for zero bits\n        if (bits === 0) {\n            if (value !== 0n) {\n                throw Error(`value is not zero for ${bits} bits. Got ${value}`);\n            }\n            else {\n                return;\n            }\n        }\n        // Corner case for one bit\n        if (bits === 1) {\n            if (value !== -1n && value !== 0n) {\n                throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);\n            }\n            else {\n                this.writeBit(value === -1n);\n                return;\n            }\n        }\n        // Check input\n        let vBits = 1n << (BigInt(bits) - 1n);\n        if (v < -vBits || v >= vBits) {\n            throw Error(`value is out of range for ${bits} bits. Got ${value}`);\n        }\n        // Write sign\n        if (v < 0) {\n            this.writeBit(true);\n            v = vBits + v;\n        }\n        else {\n            this.writeBit(false);\n        }\n        // Write value\n        this.writeUint(v, bits - 1);\n    }\n    /**\n     * Wrtie var uint value, used for serializing coins\n     * @param value value to write as bigint or number\n     * @param bits header bits to write size\n     */\n    writeVarUint(value, bits) {\n        let v = BigInt(value);\n        if (bits < 0 || !Number.isSafeInteger(bits)) {\n            throw Error(`invalid bit length. Got ${bits}`);\n        }\n        if (v < 0) {\n            throw Error(`value is negative. Got ${value}`);\n        }\n        // Corner case for zero\n        if (v === 0n) {\n            // Write zero size\n            this.writeUint(0, bits);\n            return;\n        }\n        // Calculate size\n        const sizeBytes = Math.ceil((v.toString(2).length) / 8); // Fastest way in most environments\n        const sizeBits = sizeBytes * 8;\n        // Write size\n        this.writeUint(sizeBytes, bits);\n        // Write number\n        this.writeUint(v, sizeBits);\n    }\n    /**\n     * Wrtie var int value, used for serializing coins\n     * @param value value to write as bigint or number\n     * @param bits header bits to write size\n     */\n    writeVarInt(value, bits) {\n        let v = BigInt(value);\n        if (bits < 0 || !Number.isSafeInteger(bits)) {\n            throw Error(`invalid bit length. Got ${bits}`);\n        }\n        // Corner case for zero\n        if (v === 0n) {\n            // Write zero size\n            this.writeUint(0, bits);\n            return;\n        }\n        // Calculate size\n        let v2 = v > 0 ? v : -v;\n        const sizeBytes = 1 + Math.ceil((v2.toString(2).length) / 8); // Fastest way in most environments\n        const sizeBits = sizeBytes * 8;\n        // Write size\n        this.writeUint(sizeBytes, bits);\n        // Write number\n        this.writeInt(v, sizeBits);\n    }\n    /**\n     * Write coins in var uint format\n     * @param amount amount to write\n     */\n    writeCoins(amount) {\n        this.writeVarUint(amount, 4);\n    }\n    /**\n     * Write address\n     * @param address write address or address external\n     */\n    writeAddress(address) {\n        // Is empty address\n        if (address === null || address === undefined) {\n            this.writeUint(0, 2); // Empty address\n            return;\n        }\n        // Is Internal Address\n        if (Address_1.Address.isAddress(address)) {\n            this.writeUint(2, 2); // Internal address\n            this.writeUint(0, 1); // No anycast\n            this.writeInt(address.workChain, 8);\n            this.writeBuffer(address.hash);\n            return;\n        }\n        // Is External Address\n        if (ExternalAddress_1.ExternalAddress.isAddress(address)) {\n            this.writeUint(1, 2); // External address\n            this.writeUint(address.bits, 9);\n            this.writeUint(address.value, address.bits);\n            return;\n        }\n        // Invalid address\n        throw Error(`Invalid address. Got ${address}`);\n    }\n    /**\n     * Build BitString\n     * @returns result bit string\n     */\n    build() {\n        return new BitString_1.BitString(this._buffer, 0, this._length);\n    }\n    /**\n     * Build into Buffer\n     * @returns result buffer\n     */\n    buffer() {\n        if (this._length % 8 !== 0) {\n            throw new Error(\"BitBuilder buffer is not byte aligned\");\n        }\n        return this._buffer.subarray(0, this._length / 8);\n    }\n}\nexports.BitBuilder = BitBuilder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}