{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\adams\\\\OneDrive\\\\Desktop\\\\Work\\\\slotpot\\\\src\\\\components\\\\SimpleCarousel.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { TonIcon } from './IconComponents';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SimpleCarousel = ({\n  players,\n  isSpinning,\n  onSpinComplete,\n  contractWinner,\n  totalJackpotValue\n}) => {\n  _s();\n  const [wheelState, setWheelState] = useState('idle'); // 'idle', 'waiting', 'spinning', 'winner', 'finished'\n  const [lockedPlayers, setLockedPlayers] = useState([]); // Lock players during animation\n  const wheelRef = useRef();\n  const idleAnimationRef = useRef();\n  const currentPosition = useRef(0);\n  const winnerShowcaseTimeoutRef = useRef();\n\n  // Card dimensions (matching roulette example)\n  const CARD_WIDTH = 20; // 75px + 3px margin on each side\n\n  // Lock players when spinning starts to prevent them from changing during animation\n  useEffect(() => {\n    if (isSpinning && contractWinner && players.length > 0) {\n      // Locking players for animation\n      setLockedPlayers([...players]);\n    }\n  }, [isSpinning, contractWinner, players]);\n\n  // Use locked players during animation, regular players otherwise\n  const effectivePlayers = wheelState === 'spinning' || wheelState === 'winner' ? lockedPlayers : players;\n\n  // Render individual player card HTML\n  const renderPlayerCard = useCallback((player, key) => {\n    if (!player) {\n      return `\n        <div class=\"waiting-card\">\n          <div class=\"avatar-container\">\n            ?\n          </div>\n          <div class=\"waiting-text\">Waiting</div>\n          <div class=\"waiting-amount\">0.000</div>\n        </div>\n      `;\n    }\n\n    // Always show the amount if it exists, regardless of isRealPlayer\n    const amount = player.bet || player.amount || 0;\n    const isActive = amount > 0;\n    const avatar = player.avatar && player.avatar !== '‚ùì' && player.avatar !== 'üë§' ? player.avatar : `https://robohash.org/${player.address || player.name}.png?size=100x100`;\n    const username = player.username || player.displayName || player.name || 'Player';\n    const bet = amount.toFixed(3);\n    return `\n      <div class=\"player-card ${isActive ? 'active' : 'inactive'}\" data-key=\"${key}\">\n        <div class=\"card-content\">\n          <div class=\"avatar-container\">\n            <img src=\"${avatar}\" alt=\"${username}\" class=\"player-avatar\" />\n          </div>\n          <div class=\"player-info\">\n            <p class=\"player-name\">${username}</p>\n            <div class=\"bet-info\">\n              <div class=\"coin-icon ${!isActive ? 'grayscale' : ''}\"></div>\n              <span class=\"bet-amount\">${bet}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }, []);\n\n  // Initialize wheel with player rows for infinite scrolling\n  const initWheel = useCallback(() => {\n    if (!wheelRef.current || !effectivePlayers.length) return;\n    const wheel = wheelRef.current;\n    wheel.innerHTML = ''; // Clear existing content\n\n    // Create one continuous row with multiple player cycles for smooth infinite scroll\n    const row = document.createElement('div');\n    row.className = 'roulette-row';\n\n    // Create enough copies to ensure smooth infinite scrolling (10 copies)\n    for (let copyIndex = 0; copyIndex < 10; copyIndex++) {\n      effectivePlayers.forEach((player, playerIndex) => {\n        const card = document.createElement('div');\n        card.className = 'roulette-card';\n        card.innerHTML = renderPlayerCard(player, `${copyIndex}-${playerIndex}`);\n        row.appendChild(card);\n      });\n    }\n    wheel.appendChild(row);\n  }, [effectivePlayers, renderPlayerCard]);\n\n  // Idle movement - constant speed with true infinite scroll\n  const startIdleMovement = useCallback(() => {\n    if (!wheelRef.current || wheelState !== 'idle') return;\n    const animate = () => {\n      var _wheelRef$current;\n      if (wheelState !== 'idle') return;\n      currentPosition.current -= 0.5; // Slower, smoother movement (0.5px per frame)\n\n      // True infinite scroll - reset when we've scrolled through several player cycles\n      // Use actual card spacing for consistency\n      const firstCard = (_wheelRef$current = wheelRef.current) === null || _wheelRef$current === void 0 ? void 0 : _wheelRef$current.querySelector('.roulette-card');\n      const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n      const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n      const totalCardSpacing = actualCardWidth + cardMargin;\n      const cycleWidth = effectivePlayers.length * totalCardSpacing;\n      const resetPoint = -(cycleWidth * 10); // Reset after 10 cycles\n\n      if (currentPosition.current <= resetPoint) {\n        // Reset to a position that maintains visual continuity\n        currentPosition.current = -(cycleWidth * 5); // Reset to middle area\n      }\n      if (wheelRef.current) {\n        wheelRef.current.style.transform = `translate3d(${currentPosition.current}px, 0px, 0px)`;\n      }\n      idleAnimationRef.current = requestAnimationFrame(animate);\n    };\n    idleAnimationRef.current = requestAnimationFrame(animate);\n  }, [wheelState, effectivePlayers.length, CARD_WIDTH]);\n\n  // Stop idle movement\n  const stopIdleMovement = useCallback(() => {\n    if (idleAnimationRef.current) {\n      cancelAnimationFrame(idleAnimationRef.current);\n      idleAnimationRef.current = null;\n    }\n  }, []);\n\n  // Find winner position in player array\n  const findWinnerPosition = useCallback(winner => {\n    if (!winner || !effectivePlayers.length) return -1;\n    for (let i = 0; i < effectivePlayers.length; i++) {\n      const player = effectivePlayers[i];\n      if (!player) continue;\n\n      // Try multiple matching strategies\n      const addressMatch = player.address && (player.address === winner.winner || player.address === winner.fullAddress) || player.fullAddress && (player.fullAddress === winner.winner || player.fullAddress === winner.fullAddress);\n      const usernameMatch = player.username && player.username === winner.username || player.displayName && player.displayName === winner.displayName || player.username && winner.username && player.username === winner.username || player.displayName && winner.winnerName && player.displayName === winner.winnerName;\n      if (addressMatch || usernameMatch) {\n        return i;\n      }\n    }\n    return -1;\n  }, [effectivePlayers]);\n\n  // Spin wheel function with improved accuracy\n  const spinWheel = useCallback(targetWinner => {\n    if (wheelState === 'spinning' || !wheelRef.current) return;\n    setWheelState('spinning');\n    stopIdleMovement();\n    const winnerPosition = findWinnerPosition(targetWinner);\n    if (winnerPosition === -1) {\n      // Fallback 1: Try to find by username pattern (e.g., \"Player_3tsb\" -> look for any player with \"3tsb\")\n      const winnerUsername = targetWinner.username || targetWinner.winnerName;\n      if (winnerUsername && winnerUsername.includes('_')) {\n        const usernameSuffix = winnerUsername.split('_')[1];\n        for (let i = 0; i < effectivePlayers.length; i++) {\n          const player = effectivePlayers[i];\n          if (player && player.username && player.username.includes(usernameSuffix)) {\n            performSpin(i, targetWinner);\n            return;\n          }\n        }\n      }\n\n      // Fallback 2: If no match found, land on first active player\n      const firstActivePlayer = effectivePlayers.findIndex(p => p && (p.bet > 0 || p.amount > 0));\n      const fallbackPosition = firstActivePlayer !== -1 ? firstActivePlayer : 0;\n      performSpin(fallbackPosition, targetWinner);\n      return;\n    }\n    performSpin(winnerPosition, targetWinner);\n  }, [wheelState, stopIdleMovement, findWinnerPosition, effectivePlayers.length, onSpinComplete, CARD_WIDTH]);\n\n  // Separate function to perform the actual spin animation\n  const performSpin = useCallback((winnerPosition, targetWinner) => {\n    const wheel = wheelRef.current;\n    if (!wheel) return;\n\n    // Calculate precise landing position\n    const wheelWidth = wheel.offsetWidth;\n    const centerOffset = wheelWidth / 2;\n    const firstCard = wheel.querySelector('.roulette-card');\n    const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n    const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n    const totalCardSpacing = actualCardWidth + cardMargin;\n\n    // CLASSIC SLOT MACHINE ANIMATION: Fast slide then slow down to winner\n    const cycleLength = effectivePlayers.length * totalCardSpacing;\n    const currentAbsolutePosition = Math.abs(currentPosition.current);\n\n    // Calculate how far we need to slide to get the winner centered\n    // The winner card should be perfectly centered in the wheel\n    const winnerOffset = winnerPosition * totalCardSpacing;\n\n    // Slide at least 3 full cycles to create that \"fast spinning\" effect\n    // Then land precisely on the winner in the next visible cycle\n    const minimumSpinDistance = cycleLength * 3; // At least 3 full cycles\n    const targetCycle = Math.ceil((currentAbsolutePosition + minimumSpinDistance) / cycleLength);\n    const finalWinnerPosition = targetCycle * cycleLength + winnerOffset;\n\n    // Calculate the exact position to center the winner card\n    // The center of the winner card should align with the center of the wheel\n    // Add -50px adjustment to land exactly on the winner\n    const finalPosition = -(finalWinnerPosition + actualCardWidth / 2 - centerOffset - 20);\n\n    // Start ticking sound for the spinning effect\n    let tickInterval = setInterval(() => {\n      // Spin sound removed for performance\n    }, 100); // Fast ticking initially\n\n    // STAGE 1: Fast spinning for 2 seconds\n    wheel.style.transitionTimingFunction = 'linear';\n    wheel.style.transitionDuration = '2000ms';\n\n    // Slide 80% of the way during fast phase\n    const fastPhasePosition = currentPosition.current + (finalPosition - currentPosition.current) * 1;\n    wheel.style.transform = `translate3d(${fastPhasePosition}px, 0px, 0px)`;\n    currentPosition.current = fastPhasePosition;\n\n    // STAGE 2: Slow down dramatically for final 20% over 3 seconds\n    setTimeout(() => {\n      // Slower ticking sound\n      clearInterval(tickInterval);\n      tickInterval = setInterval(() => {\n        // Spin sound removed for performance\n      }, 300); // Much slower ticking\n\n      wheel.style.transitionTimingFunction = 'cubic-bezier(0.05, 0.1, 0.05, 1)';\n      wheel.style.transitionDuration = '3000ms';\n      wheel.style.transform = `translate3d(${finalPosition}px, 0px, 0px)`;\n      currentPosition.current = finalPosition;\n\n      // Stop ticking after slowdown completes\n      setTimeout(() => {\n        clearInterval(tickInterval);\n      }, 3000);\n    }, 2000); // Wait 2 seconds for fast phase\n\n    // After total animation (2s + 3s = 5s), show winner\n    setTimeout(() => {\n      setWheelState('winner');\n\n      // Highlight the winner card\n      const allCards = wheel.querySelectorAll('.roulette-card');\n\n      // Find the card that should be in the center (winner card)\n      const centerCardIndex = Math.round(Math.abs(finalPosition) / totalCardSpacing);\n\n      // Verify the center card is indeed the winner\n      const centerCard = allCards[centerCardIndex];\n      if (centerCard) {\n        const centerCardPlayerIndex = centerCardIndex % effectivePlayers.length;\n        if (centerCardPlayerIndex === winnerPosition) {} else {}\n      }\n\n      // After showcasing winner for 4 seconds, go to finished state\n      winnerShowcaseTimeoutRef.current = setTimeout(() => {\n        // Remove winner highlights\n        const highlightedCards = wheel.querySelectorAll('.winner-highlight');\n        highlightedCards.forEach(card => {\n          card.classList.remove('winner-highlight');\n        });\n\n        // Reset transition styles\n        wheel.style.transitionTimingFunction = '';\n        wheel.style.transitionDuration = '';\n\n        // Clear locked players\n        setLockedPlayers([]);\n        setWheelState('finished');\n        onSpinComplete === null || onSpinComplete === void 0 ? void 0 : onSpinComplete(targetWinner);\n      }, 4000); // Show winner for 4 seconds\n    }, 5000); // Wait 5 seconds for both phases (2s fast + 3s slow)\n  }, [effectivePlayers.length, CARD_WIDTH, onSpinComplete]);\n\n  // Handle state changes\n  useEffect(() => {\n    if (isSpinning && contractWinner && wheelState === 'waiting') {\n      // Backend responded with winner, start spinning\n      spinWheel(contractWinner);\n    } else if (isSpinning && !contractWinner && wheelState === 'idle') {\n      // Bet placed, stop and wait for backend\n      setWheelState('waiting');\n      stopIdleMovement();\n    } else if (!isSpinning && wheelState !== 'idle' && wheelState !== 'winner' && wheelState !== 'finished') {\n      // Reset to idle state (but don't interrupt winner showcase or finished state)\n      setWheelState('idle');\n    }\n  }, [isSpinning, contractWinner, wheelState, spinWheel, stopIdleMovement]);\n\n  // Detect new game start and reset from finished state to idle\n  useEffect(() => {\n    // If we're in finished state and there's no winner (new game starting), reset to idle\n    if (wheelState === 'finished' && !contractWinner && !isSpinning) {\n      setWheelState('idle');\n    }\n  }, [wheelState, contractWinner, isSpinning]);\n\n  // Start/stop idle movement based on state\n  useEffect(() => {\n    if (wheelState === 'idle') {\n      startIdleMovement();\n    } else {\n      stopIdleMovement();\n    }\n    return () => stopIdleMovement();\n  }, [wheelState, startIdleMovement, stopIdleMovement]);\n\n  // Initialize wheel when effective players change (but not during winner showcase)\n  useEffect(() => {\n    // Don't reinitialize during winner showcase or finished state to preserve highlighting\n    if (wheelState !== 'winner' && wheelState !== 'finished') {\n      initWheel();\n    }\n  }, [initWheel, wheelState]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (winnerShowcaseTimeoutRef.current) {\n        clearTimeout(winnerShowcaseTimeoutRef.current);\n      }\n    };\n  }, []);\n  if (!effectivePlayers || effectivePlayers.length === 0) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"simple-carousel\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"carousel-message\",\n        children: \"Waiting for players to join...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 367,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 366,\n      columnNumber: 7\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"roulette-wrapper\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"roulette-selector\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 377,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: wheelRef,\n      className: \"roulette-wheel\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 380,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"wheel-state-indicator\",\n      children: [wheelState === 'idle' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFB0\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 384,\n        columnNumber: 35\n      }, this), wheelState === 'waiting' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\u23F3\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 385,\n        columnNumber: 38\n      }, this), wheelState === 'spinning' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFAF\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 386,\n        columnNumber: 39\n      }, this), wheelState === 'winner' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDF89\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 387,\n        columnNumber: 37\n      }, this), wheelState === 'finished' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFC1\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 388,\n        columnNumber: 39\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 383,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"absolute -top-1/4 -right-1/3 h-full opacity-75 will-change-transform z-[3] pointer-events-none\",\n      style: {\n        maskImage: 'linear-gradient(black, transparent 50%)'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"img\", {\n        src: \"/img/glare.webp\",\n        className: \"w-full object-cover object-center\",\n        alt: \"\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 396,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 392,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 375,\n    columnNumber: 5\n  }, this);\n};\n_s(SimpleCarousel, \"VIxi7lGLuxZ4CmPOzTtmWajujkE=\");\n_c = SimpleCarousel;\nexport default SimpleCarousel;\nvar _c;\n$RefreshReg$(_c, \"SimpleCarousel\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","TonIcon","jsxDEV","_jsxDEV","SimpleCarousel","players","isSpinning","onSpinComplete","contractWinner","totalJackpotValue","_s","wheelState","setWheelState","lockedPlayers","setLockedPlayers","wheelRef","idleAnimationRef","currentPosition","winnerShowcaseTimeoutRef","CARD_WIDTH","length","effectivePlayers","renderPlayerCard","player","key","amount","bet","isActive","avatar","address","name","username","displayName","toFixed","initWheel","current","wheel","innerHTML","row","document","createElement","className","copyIndex","forEach","playerIndex","card","appendChild","startIdleMovement","animate","_wheelRef$current","firstCard","querySelector","actualCardWidth","offsetWidth","cardMargin","parseInt","getComputedStyle","marginLeft","marginRight","totalCardSpacing","cycleWidth","resetPoint","style","transform","requestAnimationFrame","stopIdleMovement","cancelAnimationFrame","findWinnerPosition","winner","i","addressMatch","fullAddress","usernameMatch","winnerName","spinWheel","targetWinner","winnerPosition","winnerUsername","includes","usernameSuffix","split","performSpin","firstActivePlayer","findIndex","p","fallbackPosition","wheelWidth","centerOffset","cycleLength","currentAbsolutePosition","Math","abs","winnerOffset","minimumSpinDistance","targetCycle","ceil","finalWinnerPosition","finalPosition","tickInterval","setInterval","transitionTimingFunction","transitionDuration","fastPhasePosition","setTimeout","clearInterval","allCards","querySelectorAll","centerCardIndex","round","centerCard","centerCardPlayerIndex","highlightedCards","classList","remove","clearTimeout","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","maskImage","src","alt","_c","$RefreshReg$"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/src/components/SimpleCarousel.js"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { TonIcon } from './IconComponents';\n\n\nconst SimpleCarousel = ({ \n  players, \n  isSpinning, \n  onSpinComplete, \n  contractWinner,\n  totalJackpotValue \n}) => {\n  const [wheelState, setWheelState] = useState('idle'); // 'idle', 'waiting', 'spinning', 'winner', 'finished'\n  const [lockedPlayers, setLockedPlayers] = useState([]); // Lock players during animation\n  const wheelRef = useRef();\n  const idleAnimationRef = useRef();\n  const currentPosition = useRef(0);\n  const winnerShowcaseTimeoutRef = useRef();\n  \n  // Card dimensions (matching roulette example)\n  const CARD_WIDTH = 20; // 75px + 3px margin on each side\n  \n  // Lock players when spinning starts to prevent them from changing during animation\n  useEffect(() => {\n    if (isSpinning && contractWinner && players.length > 0) {\n      // Locking players for animation\n      setLockedPlayers([...players]);\n    }\n  }, [isSpinning, contractWinner, players]);\n  \n  // Use locked players during animation, regular players otherwise\n  const effectivePlayers = wheelState === 'spinning' || wheelState === 'winner' ? lockedPlayers : players;\n  \n  // Render individual player card HTML\n  const renderPlayerCard = useCallback((player, key) => {\n    if (!player) {\n      return `\n        <div class=\"waiting-card\">\n          <div class=\"avatar-container\">\n            ?\n          </div>\n          <div class=\"waiting-text\">Waiting</div>\n          <div class=\"waiting-amount\">0.000</div>\n        </div>\n      `;\n    }\n    \n    // Always show the amount if it exists, regardless of isRealPlayer\n    const amount = player.bet || player.amount || 0;\n    const isActive = amount > 0;\n    const avatar = player.avatar && player.avatar !== '‚ùì' && player.avatar !== 'üë§' ? \n      player.avatar : \n      `https://robohash.org/${player.address || player.name}.png?size=100x100`;\n    const username = player.username || player.displayName || player.name || 'Player';\n    const bet = amount.toFixed(3);\n    \n    return `\n      <div class=\"player-card ${isActive ? 'active' : 'inactive'}\" data-key=\"${key}\">\n        <div class=\"card-content\">\n          <div class=\"avatar-container\">\n            <img src=\"${avatar}\" alt=\"${username}\" class=\"player-avatar\" />\n          </div>\n          <div class=\"player-info\">\n            <p class=\"player-name\">${username}</p>\n            <div class=\"bet-info\">\n              <div class=\"coin-icon ${!isActive ? 'grayscale' : ''}\"></div>\n              <span class=\"bet-amount\">${bet}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }, []);\n\n  // Initialize wheel with player rows for infinite scrolling\n  const initWheel = useCallback(() => {\n    if (!wheelRef.current || !effectivePlayers.length) return;\n    \n    const wheel = wheelRef.current;\n    wheel.innerHTML = ''; // Clear existing content\n    \n    // Create one continuous row with multiple player cycles for smooth infinite scroll\n    const row = document.createElement('div');\n    row.className = 'roulette-row';\n    \n    // Create enough copies to ensure smooth infinite scrolling (10 copies)\n    for (let copyIndex = 0; copyIndex < 10; copyIndex++) {\n      effectivePlayers.forEach((player, playerIndex) => {\n        const card = document.createElement('div');\n        card.className = 'roulette-card';\n        card.innerHTML = renderPlayerCard(player, `${copyIndex}-${playerIndex}`);\n        row.appendChild(card);\n      });\n    }\n    \n    wheel.appendChild(row);\n  }, [effectivePlayers, renderPlayerCard]);\n\n  // Idle movement - constant speed with true infinite scroll\n  const startIdleMovement = useCallback(() => {\n    if (!wheelRef.current || wheelState !== 'idle') return;\n    \n    const animate = () => {\n      if (wheelState !== 'idle') return;\n      \n      currentPosition.current -= 0.5; // Slower, smoother movement (0.5px per frame)\n      \n      // True infinite scroll - reset when we've scrolled through several player cycles\n      // Use actual card spacing for consistency\n      const firstCard = wheelRef.current?.querySelector('.roulette-card');\n      const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n      const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n      const totalCardSpacing = actualCardWidth + cardMargin;\n      \n      const cycleWidth = effectivePlayers.length * totalCardSpacing;\n      const resetPoint = -(cycleWidth * 10); // Reset after 10 cycles\n      \n      if (currentPosition.current <= resetPoint) {\n        // Reset to a position that maintains visual continuity\n        currentPosition.current = -(cycleWidth * 5); // Reset to middle area\n      }\n      \n      if (wheelRef.current) {\n        wheelRef.current.style.transform = `translate3d(${currentPosition.current}px, 0px, 0px)`;\n      }\n      \n      idleAnimationRef.current = requestAnimationFrame(animate);\n    };\n    \n    idleAnimationRef.current = requestAnimationFrame(animate);\n  }, [wheelState, effectivePlayers.length, CARD_WIDTH]);\n\n  // Stop idle movement\n  const stopIdleMovement = useCallback(() => {\n    if (idleAnimationRef.current) {\n      cancelAnimationFrame(idleAnimationRef.current);\n      idleAnimationRef.current = null;\n    }\n  }, []);\n\n  // Find winner position in player array\n  const findWinnerPosition = useCallback((winner) => {\n    if (!winner || !effectivePlayers.length) return -1;\n    \n    for (let i = 0; i < effectivePlayers.length; i++) {\n      const player = effectivePlayers[i];\n      if (!player) continue;\n      \n      // Try multiple matching strategies\n      const addressMatch = (\n        (player.address && (player.address === winner.winner || player.address === winner.fullAddress)) ||\n        (player.fullAddress && (player.fullAddress === winner.winner || player.fullAddress === winner.fullAddress))\n      );\n      \n      const usernameMatch = (\n        (player.username && player.username === winner.username) ||\n        (player.displayName && player.displayName === winner.displayName) ||\n        (player.username && winner.username && player.username === winner.username) ||\n        (player.displayName && winner.winnerName && player.displayName === winner.winnerName)\n      );\n      \n      if (addressMatch || usernameMatch) {\n        return i;\n      }\n    }\n    \n    return -1;\n  }, [effectivePlayers]);\n\n  // Spin wheel function with improved accuracy\n  const spinWheel = useCallback((targetWinner) => {\n    if (wheelState === 'spinning' || !wheelRef.current) return;\n    \n    setWheelState('spinning');\n    stopIdleMovement();\n    \n    const winnerPosition = findWinnerPosition(targetWinner);\n    if (winnerPosition === -1) {\n      // Fallback 1: Try to find by username pattern (e.g., \"Player_3tsb\" -> look for any player with \"3tsb\")\n      const winnerUsername = targetWinner.username || targetWinner.winnerName;\n      if (winnerUsername && winnerUsername.includes('_')) {\n        const usernameSuffix = winnerUsername.split('_')[1];\n        for (let i = 0; i < effectivePlayers.length; i++) {\n          const player = effectivePlayers[i];\n          if (player && player.username && player.username.includes(usernameSuffix)) {\n            performSpin(i, targetWinner);\n            return;\n          }\n        }\n      }\n      \n      // Fallback 2: If no match found, land on first active player\n      const firstActivePlayer = effectivePlayers.findIndex(p => p && (p.bet > 0 || p.amount > 0));\n      const fallbackPosition = firstActivePlayer !== -1 ? firstActivePlayer : 0;\n      performSpin(fallbackPosition, targetWinner);\n      return;\n    }\n          \n    performSpin(winnerPosition, targetWinner);\n    \n  }, [wheelState, stopIdleMovement, findWinnerPosition, effectivePlayers.length, onSpinComplete, CARD_WIDTH]);\n\n  // Separate function to perform the actual spin animation\n  const performSpin = useCallback((winnerPosition, targetWinner) => {\n    const wheel = wheelRef.current;\n    if (!wheel) return;\n\n    // Calculate precise landing position\n    const wheelWidth = wheel.offsetWidth;\n    const centerOffset = wheelWidth / 2;\n    const firstCard = wheel.querySelector('.roulette-card');\n    const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n    const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n    const totalCardSpacing = actualCardWidth + cardMargin;\n    \n    // CLASSIC SLOT MACHINE ANIMATION: Fast slide then slow down to winner\n    const cycleLength = effectivePlayers.length * totalCardSpacing;\n    const currentAbsolutePosition = Math.abs(currentPosition.current);\n    \n    // Calculate how far we need to slide to get the winner centered\n    // The winner card should be perfectly centered in the wheel\n    const winnerOffset = winnerPosition * totalCardSpacing;\n    \n    // Slide at least 3 full cycles to create that \"fast spinning\" effect\n    // Then land precisely on the winner in the next visible cycle\n    const minimumSpinDistance = cycleLength * 3; // At least 3 full cycles\n    const targetCycle = Math.ceil((currentAbsolutePosition + minimumSpinDistance) / cycleLength);\n    const finalWinnerPosition = (targetCycle * cycleLength) + winnerOffset;\n    \n    // Calculate the exact position to center the winner card\n    // The center of the winner card should align with the center of the wheel\n    // Add -50px adjustment to land exactly on the winner\n    const finalPosition = -(finalWinnerPosition + (actualCardWidth / 2) - centerOffset - 20);\n    \n    // Start ticking sound for the spinning effect\n    let tickInterval = setInterval(() => {\n              // Spin sound removed for performance\n    }, 100); // Fast ticking initially\n    \n    // STAGE 1: Fast spinning for 2 seconds\n    wheel.style.transitionTimingFunction = 'linear';\n    wheel.style.transitionDuration = '2000ms';\n    \n    // Slide 80% of the way during fast phase\n    const fastPhasePosition = currentPosition.current + ((finalPosition - currentPosition.current) * 1);\n    wheel.style.transform = `translate3d(${fastPhasePosition}px, 0px, 0px)`;\n    currentPosition.current = fastPhasePosition;\n    \n    // STAGE 2: Slow down dramatically for final 20% over 3 seconds\n    setTimeout(() => {\n      // Slower ticking sound\n      clearInterval(tickInterval);\n      tickInterval = setInterval(() => {\n        // Spin sound removed for performance\n      }, 300); // Much slower ticking\n      \n      wheel.style.transitionTimingFunction = 'cubic-bezier(0.05, 0.1, 0.05, 1)';\n      wheel.style.transitionDuration = '3000ms';\n      wheel.style.transform = `translate3d(${finalPosition}px, 0px, 0px)`;\n      currentPosition.current = finalPosition;\n      \n      // Stop ticking after slowdown completes\n      setTimeout(() => {\n        clearInterval(tickInterval);\n      }, 3000);\n      \n    }, 2000); // Wait 2 seconds for fast phase\n    \n    // After total animation (2s + 3s = 5s), show winner\n    setTimeout(() => {\n      setWheelState('winner');\n      \n      // Highlight the winner card\n      const allCards = wheel.querySelectorAll('.roulette-card');\n      \n      // Find the card that should be in the center (winner card)\n      const centerCardIndex = Math.round(Math.abs(finalPosition) / totalCardSpacing);\n      \n      \n      \n      // Verify the center card is indeed the winner\n      const centerCard = allCards[centerCardIndex];\n      if (centerCard) {\n        const centerCardPlayerIndex = centerCardIndex % effectivePlayers.length;\n        if (centerCardPlayerIndex === winnerPosition) {\n        } else {\n        }\n      }\n      \n      // After showcasing winner for 4 seconds, go to finished state\n      winnerShowcaseTimeoutRef.current = setTimeout(() => {\n        \n        // Remove winner highlights\n        const highlightedCards = wheel.querySelectorAll('.winner-highlight');\n        highlightedCards.forEach(card => {\n          card.classList.remove('winner-highlight');\n        });\n        \n        // Reset transition styles\n        wheel.style.transitionTimingFunction = '';\n        wheel.style.transitionDuration = '';\n        \n        // Clear locked players\n        setLockedPlayers([]);\n        \n        setWheelState('finished');\n        onSpinComplete?.(targetWinner);\n      }, 4000); // Show winner for 4 seconds\n      \n    }, 5000); // Wait 5 seconds for both phases (2s fast + 3s slow)\n    \n  }, [effectivePlayers.length, CARD_WIDTH, onSpinComplete]);\n\n  // Handle state changes\n  useEffect(() => {\n    if (isSpinning && contractWinner && wheelState === 'waiting') {\n      // Backend responded with winner, start spinning\n      spinWheel(contractWinner);\n    } else if (isSpinning && !contractWinner && wheelState === 'idle') {\n      // Bet placed, stop and wait for backend\n      setWheelState('waiting');\n      stopIdleMovement();\n    } else if (!isSpinning && wheelState !== 'idle' && wheelState !== 'winner' && wheelState !== 'finished') {\n      // Reset to idle state (but don't interrupt winner showcase or finished state)\n      setWheelState('idle');\n    }\n  }, [isSpinning, contractWinner, wheelState, spinWheel, stopIdleMovement]);\n\n  // Detect new game start and reset from finished state to idle\n  useEffect(() => {\n    // If we're in finished state and there's no winner (new game starting), reset to idle\n    if (wheelState === 'finished' && !contractWinner && !isSpinning) {\n      setWheelState('idle');\n    }\n  }, [wheelState, contractWinner, isSpinning]);\n\n  // Start/stop idle movement based on state\n  useEffect(() => {\n    if (wheelState === 'idle') {\n      startIdleMovement();\n    } else {\n      stopIdleMovement();\n    }\n    \n    return () => stopIdleMovement();\n  }, [wheelState, startIdleMovement, stopIdleMovement]);\n\n  // Initialize wheel when effective players change (but not during winner showcase)\n  useEffect(() => {\n    // Don't reinitialize during winner showcase or finished state to preserve highlighting\n    if (wheelState !== 'winner' && wheelState !== 'finished') {\n      initWheel();\n    }\n  }, [initWheel, wheelState]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (winnerShowcaseTimeoutRef.current) {\n        clearTimeout(winnerShowcaseTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  if (!effectivePlayers || effectivePlayers.length === 0) {\n    return (\n      <div className=\"simple-carousel\">\n        <div className=\"carousel-message\">\n          Waiting for players to join...\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"roulette-wrapper\">\n      {/* Center selector line */}\n      <div className=\"roulette-selector\"></div>\n      \n      {/* Spinning wheel */}\n      <div ref={wheelRef} className=\"roulette-wheel\"></div>\n      \n      {/* State indicator */}\n      <div className=\"wheel-state-indicator\">\n        {wheelState === 'idle' && <span>üé∞</span>}\n        {wheelState === 'waiting' && <span>‚è≥</span>}\n        {wheelState === 'spinning' && <span>üéØ</span>}\n        {wheelState === 'winner' && <span>üéâ</span>}\n        {wheelState === 'finished' && <span>üèÅ</span>}\n      </div>\n      \n      {/* Glare Effect */}\n      <div \n        className=\"absolute -top-1/4 -right-1/3 h-full opacity-75 will-change-transform z-[3] pointer-events-none\"\n        style={{ maskImage: 'linear-gradient(black, transparent 50%)' }}\n      >\n        <img src=\"/img/glare.webp\" className=\"w-full object-cover object-center\" alt=\"\" />\n              </div>\n    </div>\n  );\n};\n\nexport default SimpleCarousel; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}