{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ElectorContract = void 0;\nconst core_1 = require(\"@ton/core\");\nconst FrozenDictValue = {\n  serialize(src, builder) {\n    throw Error(\"not implemented\");\n  },\n  parse(src) {\n    const address = new core_1.Address(-1, src.loadBuffer(32));\n    const weight = src.loadUintBig(64);\n    const stake = src.loadCoins();\n    return {\n      address,\n      weight,\n      stake\n    };\n  }\n};\nconst EntitiesDictValue = {\n  serialize(src, builder) {\n    throw Error(\"not implemented\");\n  },\n  parse(src) {\n    const stake = src.loadCoins();\n    // skip time and maxFactor\n    src.skip(64);\n    const address = new core_1.Address(-1, src.loadBuffer(32));\n    const adnl = src.loadBuffer(32);\n    return {\n      stake,\n      address,\n      adnl\n    };\n  }\n};\nclass ElectorContract {\n  //readonly source: ContractSource = new UnknownContractSource('org.ton.elector', -1, 'Elector Contract');\n  static create() {\n    return new ElectorContract();\n  }\n  constructor() {\n    // Please note that we are NOT loading address from config to avoid mistake and send validator money to a wrong contract\n    this.address = core_1.Address.parseRaw('-1:3333333333333333333333333333333333333333333333333333333333333333');\n  }\n  async getReturnedStake(provider, address) {\n    if (address.workChain !== -1) {\n      throw Error('Only masterchain addresses could have stake');\n    }\n    const res = await provider.get('compute_returned_stake', [{\n      type: 'int',\n      value: BigInt('0x' + address.hash.toString('hex'))\n    }]);\n    return res.stack.readBigNumber();\n  }\n  async getPastElectionsList(provider) {\n    const res = await provider.get('past_elections_list', []);\n    const electionsListRaw = new core_1.TupleReader(res.stack.readLispList());\n    const elections = [];\n    while (electionsListRaw.remaining > 0) {\n      const electionsListEntry = electionsListRaw.readTuple();\n      const id = electionsListEntry.readNumber();\n      const unfreezeAt = electionsListEntry.readNumber();\n      electionsListEntry.pop(); // Ignore vset_hash\n      const stakeHeld = electionsListEntry.readNumber();\n      elections.push({\n        id,\n        unfreezeAt,\n        stakeHeld\n      });\n    }\n    return elections;\n  }\n  async getPastElections(provider) {\n    const res = await provider.get('past_elections', []);\n    const electionsRaw = new core_1.TupleReader(res.stack.readLispList());\n    const elections = [];\n    while (electionsRaw.remaining > 0) {\n      const electionsEntry = electionsRaw.readTuple();\n      const id = electionsEntry.readNumber();\n      const unfreezeAt = electionsEntry.readNumber();\n      const stakeHeld = electionsEntry.readNumber();\n      electionsEntry.pop(); // Ignore vset_hash\n      const frozenDict = electionsEntry.readCell();\n      const totalStake = electionsEntry.readBigNumber();\n      const bonuses = electionsEntry.readBigNumber();\n      let frozen = new Map();\n      const frozenData = frozenDict.beginParse().loadDictDirect(core_1.Dictionary.Keys.Buffer(32), FrozenDictValue);\n      for (const [key, value] of frozenData) {\n        frozen.set(BigInt(\"0x\" + key.toString(\"hex\")).toString(10), {\n          address: value[\"address\"],\n          weight: value[\"weight\"],\n          stake: value[\"stake\"]\n        });\n      }\n      elections.push({\n        id,\n        unfreezeAt,\n        stakeHeld,\n        totalStake,\n        bonuses,\n        frozen\n      });\n    }\n    return elections;\n  }\n  async getElectionEntities(provider) {\n    //\n    // NOTE: this method doesn't call get method since for some reason it doesn't work\n    //\n    const account = await provider.getState();\n    if (account.state.type !== 'active') {\n      throw Error('Unexpected error');\n    }\n    const cell = core_1.Cell.fromBoc(account.state.data)[0];\n    const cs = cell.beginParse();\n    if (!cs.loadBit()) {\n      return null;\n    }\n    // (es~load_uint(32), es~load_uint(32), es~load_grams(), es~load_grams(), es~load_dict(), es~load_int(1), es~load_int(1));\n    const sc = cs.loadRef().beginParse();\n    const startWorkTime = sc.loadUint(32);\n    const endElectionsTime = sc.loadUint(32);\n    const minStake = sc.loadCoins();\n    const allStakes = sc.loadCoins();\n    // var (stake, time, max_factor, addr, adnl_addr) = (cs~load_grams(), cs~load_uint(32), cs~load_uint(32), cs~load_uint(256), cs~load_uint(256));\n    const entitiesData = sc.loadDict(core_1.Dictionary.Keys.Buffer(32), EntitiesDictValue);\n    let entities = [];\n    // const failed = sc.loadBit();\n    // const finished = sc.loadBit();\n    if (entitiesData) {\n      for (const [key, value] of entitiesData) {\n        entities.push({\n          pubkey: key,\n          stake: value[\"stake\"],\n          address: value[\"address\"],\n          adnl: value[\"adnl\"]\n        });\n      }\n    }\n    return {\n      minStake,\n      allStakes,\n      endElectionsTime,\n      startWorkTime,\n      entities\n    };\n  }\n  // possible code for fetching data via get method if it is possible to set gas limit by request\n  // async getElectionEntities(block: number) {\n  //     const res = await this.client.runMethod(block, this.address, 'participant_list_extended');\n  //     if (res.exitCode !== 0 && res.exitCode !== 1) {\n  //         throw Error('Exit code: ' + res.exitCode);\n  //     }\n  //     let tuple = new TupleReader(res.result);\n  //     const startWorkTime = tuple.readNumber();\n  //     const endElectionsTime = tuple.readNumber();\n  //     const minStake = tuple.readBigNumber();\n  //     const allStakes = tuple.readBigNumber();\n  //     let entriesTuple = tuple.readTuple();\n  //     const entriesRaw = new TupleReader(entriesTuple.readLispList());\n  //     let entities: { pubkey: Buffer, stake: bigint, address: Address, adnl: Buffer }[] = [];\n  //     while (entriesRaw.remaining > 0) {\n  //         const electionsEntry = entriesRaw.readTuple();\n  //         const pubkey = electionsEntry.readBuffer();\n  //         const stake = electionsEntry.readBigNumber();\n  //         const address = electionsEntry.readAddress();\n  //         const adnl = electionsEntry.readBuffer();\n  //         entities.push({ pubkey, stake, address, adnl });\n  //     }\n  //     return { minStake, allStakes, endElectionsTime, startWorkTime, entities };\n  // }\n  async getActiveElectionId(provider) {\n    const res = await provider.get('active_election_id', []);\n    const electionId = res.stack.readNumber();\n    return electionId > 0 ? electionId : null;\n  }\n  async getComplaints(provider, electionId) {\n    const b = new core_1.TupleBuilder();\n    b.writeNumber(electionId);\n    const res = await provider.get('list_complaints', b.build());\n    if (res.stack.peek().type === 'null') {\n      return [];\n    }\n    //let tuple = new TupleReader(res.result);\n    const complaintsRaw = new core_1.TupleReader(res.stack.readLispList());\n    const results = [];\n    while (complaintsRaw.remaining > 0) {\n      const complaintsEntry = complaintsRaw.readTuple();\n      const id = complaintsEntry.readBigNumber();\n      const completeUnpackedComplaint = complaintsEntry.readTuple();\n      const unpackedComplaints = completeUnpackedComplaint.readTuple();\n      const publicKey = Buffer.from(unpackedComplaints.readBigNumber().toString(16), 'hex');\n      // prod_info#34 utime:uint32 mc_blk_ref:ExtBlkRef state_proof:^(MERKLE_PROOF Block)\n      // prod_proof:^(MERKLE_PROOF ShardState) = ProducerInfo;\n      // no_blk_gen from_utime:uint32 prod_info:^ProducerInfo = ComplaintDescr;\n      // no_blk_gen_diff prod_info_old:^ProducerInfo prod_info_new:^ProducerInfo = ComplaintDescr;\n      const description = unpackedComplaints.readCell();\n      const createdAt = unpackedComplaints.readNumber();\n      const severity = unpackedComplaints.readNumber();\n      const rewardAddress = new core_1.Address(-1, Buffer.from(unpackedComplaints.readBigNumber().toString(16), 'hex'));\n      const paid = unpackedComplaints.readBigNumber();\n      const suggestedFine = unpackedComplaints.readBigNumber();\n      const suggestedFinePart = unpackedComplaints.readBigNumber();\n      const votes = [];\n      const votersListRaw = new core_1.TupleReader(completeUnpackedComplaint.readLispList());\n      while (votersListRaw.remaining > 0) {\n        votes.push(votersListRaw.readNumber());\n      }\n      const vsetId = completeUnpackedComplaint.readBigNumber();\n      const remainingWeight = completeUnpackedComplaint.readBigNumber();\n      results.push({\n        id,\n        publicKey,\n        createdAt,\n        severity,\n        paid,\n        suggestedFine,\n        suggestedFinePart,\n        rewardAddress,\n        votes,\n        remainingWeight,\n        vsetId\n      });\n    }\n    return results;\n  }\n}\nexports.ElectorContract = ElectorContract;","map":{"version":3,"names":["Object","defineProperty","exports","value","ElectorContract","core_1","require","FrozenDictValue","serialize","src","builder","Error","parse","address","Address","loadBuffer","weight","loadUintBig","stake","loadCoins","EntitiesDictValue","skip","adnl","create","constructor","parseRaw","getReturnedStake","provider","workChain","res","get","type","BigInt","hash","toString","stack","readBigNumber","getPastElectionsList","electionsListRaw","TupleReader","readLispList","elections","remaining","electionsListEntry","readTuple","id","readNumber","unfreezeAt","pop","stakeHeld","push","getPastElections","electionsRaw","electionsEntry","frozenDict","readCell","totalStake","bonuses","frozen","Map","frozenData","beginParse","loadDictDirect","Dictionary","Keys","Buffer","key","set","getElectionEntities","account","getState","state","cell","Cell","fromBoc","data","cs","loadBit","sc","loadRef","startWorkTime","loadUint","endElectionsTime","minStake","allStakes","entitiesData","loadDict","entities","pubkey","getActiveElectionId","electionId","getComplaints","b","TupleBuilder","writeNumber","build","peek","complaintsRaw","results","complaintsEntry","completeUnpackedComplaint","unpackedComplaints","publicKey","from","description","createdAt","severity","rewardAddress","paid","suggestedFine","suggestedFinePart","votes","votersListRaw","vsetId","remainingWeight"],"sources":["C:/Users/adams/Downloads/GLL/slotpot/node_modules/@ton/ton/dist/elector/ElectorContract.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ElectorContract = void 0;\nconst core_1 = require(\"@ton/core\");\nconst FrozenDictValue = {\n    serialize(src, builder) {\n        throw Error(\"not implemented\");\n    },\n    parse(src) {\n        const address = new core_1.Address(-1, src.loadBuffer(32));\n        const weight = src.loadUintBig(64);\n        const stake = src.loadCoins();\n        return { address, weight, stake };\n    }\n};\nconst EntitiesDictValue = {\n    serialize(src, builder) {\n        throw Error(\"not implemented\");\n    },\n    parse(src) {\n        const stake = src.loadCoins();\n        // skip time and maxFactor\n        src.skip(64);\n        const address = new core_1.Address(-1, src.loadBuffer(32));\n        const adnl = src.loadBuffer(32);\n        return { stake, address, adnl };\n    }\n};\nclass ElectorContract {\n    //readonly source: ContractSource = new UnknownContractSource('org.ton.elector', -1, 'Elector Contract');\n    static create() {\n        return new ElectorContract();\n    }\n    constructor() {\n        // Please note that we are NOT loading address from config to avoid mistake and send validator money to a wrong contract\n        this.address = core_1.Address.parseRaw('-1:3333333333333333333333333333333333333333333333333333333333333333');\n    }\n    async getReturnedStake(provider, address) {\n        if (address.workChain !== -1) {\n            throw Error('Only masterchain addresses could have stake');\n        }\n        const res = await provider.get('compute_returned_stake', [{ type: 'int', value: BigInt('0x' + address.hash.toString('hex')) }]);\n        return res.stack.readBigNumber();\n    }\n    async getPastElectionsList(provider) {\n        const res = await provider.get('past_elections_list', []);\n        const electionsListRaw = new core_1.TupleReader(res.stack.readLispList());\n        const elections = [];\n        while (electionsListRaw.remaining > 0) {\n            const electionsListEntry = electionsListRaw.readTuple();\n            const id = electionsListEntry.readNumber();\n            const unfreezeAt = electionsListEntry.readNumber();\n            electionsListEntry.pop(); // Ignore vset_hash\n            const stakeHeld = electionsListEntry.readNumber();\n            elections.push({ id, unfreezeAt, stakeHeld });\n        }\n        return elections;\n    }\n    async getPastElections(provider) {\n        const res = await provider.get('past_elections', []);\n        const electionsRaw = new core_1.TupleReader(res.stack.readLispList());\n        const elections = [];\n        while (electionsRaw.remaining > 0) {\n            const electionsEntry = electionsRaw.readTuple();\n            const id = electionsEntry.readNumber();\n            const unfreezeAt = electionsEntry.readNumber();\n            const stakeHeld = electionsEntry.readNumber();\n            electionsEntry.pop(); // Ignore vset_hash\n            const frozenDict = electionsEntry.readCell();\n            const totalStake = electionsEntry.readBigNumber();\n            const bonuses = electionsEntry.readBigNumber();\n            let frozen = new Map();\n            const frozenData = frozenDict.beginParse().loadDictDirect(core_1.Dictionary.Keys.Buffer(32), FrozenDictValue);\n            for (const [key, value] of frozenData) {\n                frozen.set(BigInt(\"0x\" + key.toString(\"hex\")).toString(10), { address: value[\"address\"], weight: value[\"weight\"], stake: value[\"stake\"] });\n            }\n            elections.push({ id, unfreezeAt, stakeHeld, totalStake, bonuses, frozen });\n        }\n        return elections;\n    }\n    async getElectionEntities(provider) {\n        //\n        // NOTE: this method doesn't call get method since for some reason it doesn't work\n        //\n        const account = await provider.getState();\n        if (account.state.type !== 'active') {\n            throw Error('Unexpected error');\n        }\n        const cell = core_1.Cell.fromBoc(account.state.data)[0];\n        const cs = cell.beginParse();\n        if (!cs.loadBit()) {\n            return null;\n        }\n        // (es~load_uint(32), es~load_uint(32), es~load_grams(), es~load_grams(), es~load_dict(), es~load_int(1), es~load_int(1));\n        const sc = cs.loadRef().beginParse();\n        const startWorkTime = sc.loadUint(32);\n        const endElectionsTime = sc.loadUint(32);\n        const minStake = sc.loadCoins();\n        const allStakes = sc.loadCoins();\n        // var (stake, time, max_factor, addr, adnl_addr) = (cs~load_grams(), cs~load_uint(32), cs~load_uint(32), cs~load_uint(256), cs~load_uint(256));\n        const entitiesData = sc.loadDict(core_1.Dictionary.Keys.Buffer(32), EntitiesDictValue);\n        let entities = [];\n        // const failed = sc.loadBit();\n        // const finished = sc.loadBit();\n        if (entitiesData) {\n            for (const [key, value] of entitiesData) {\n                entities.push({ pubkey: key, stake: value[\"stake\"], address: value[\"address\"], adnl: value[\"adnl\"] });\n            }\n        }\n        return { minStake, allStakes, endElectionsTime, startWorkTime, entities };\n    }\n    // possible code for fetching data via get method if it is possible to set gas limit by request\n    // async getElectionEntities(block: number) {\n    //     const res = await this.client.runMethod(block, this.address, 'participant_list_extended');\n    //     if (res.exitCode !== 0 && res.exitCode !== 1) {\n    //         throw Error('Exit code: ' + res.exitCode);\n    //     }\n    //     let tuple = new TupleReader(res.result);\n    //     const startWorkTime = tuple.readNumber();\n    //     const endElectionsTime = tuple.readNumber();\n    //     const minStake = tuple.readBigNumber();\n    //     const allStakes = tuple.readBigNumber();\n    //     let entriesTuple = tuple.readTuple();\n    //     const entriesRaw = new TupleReader(entriesTuple.readLispList());\n    //     let entities: { pubkey: Buffer, stake: bigint, address: Address, adnl: Buffer }[] = [];\n    //     while (entriesRaw.remaining > 0) {\n    //         const electionsEntry = entriesRaw.readTuple();\n    //         const pubkey = electionsEntry.readBuffer();\n    //         const stake = electionsEntry.readBigNumber();\n    //         const address = electionsEntry.readAddress();\n    //         const adnl = electionsEntry.readBuffer();\n    //         entities.push({ pubkey, stake, address, adnl });\n    //     }\n    //     return { minStake, allStakes, endElectionsTime, startWorkTime, entities };\n    // }\n    async getActiveElectionId(provider) {\n        const res = await provider.get('active_election_id', []);\n        const electionId = res.stack.readNumber();\n        return electionId > 0 ? electionId : null;\n    }\n    async getComplaints(provider, electionId) {\n        const b = new core_1.TupleBuilder();\n        b.writeNumber(electionId);\n        const res = await provider.get('list_complaints', b.build());\n        if (res.stack.peek().type === 'null') {\n            return [];\n        }\n        //let tuple = new TupleReader(res.result);\n        const complaintsRaw = new core_1.TupleReader(res.stack.readLispList());\n        const results = [];\n        while (complaintsRaw.remaining > 0) {\n            const complaintsEntry = complaintsRaw.readTuple();\n            const id = complaintsEntry.readBigNumber();\n            const completeUnpackedComplaint = complaintsEntry.readTuple();\n            const unpackedComplaints = completeUnpackedComplaint.readTuple();\n            const publicKey = Buffer.from(unpackedComplaints.readBigNumber().toString(16), 'hex');\n            // prod_info#34 utime:uint32 mc_blk_ref:ExtBlkRef state_proof:^(MERKLE_PROOF Block)\n            // prod_proof:^(MERKLE_PROOF ShardState) = ProducerInfo;\n            // no_blk_gen from_utime:uint32 prod_info:^ProducerInfo = ComplaintDescr;\n            // no_blk_gen_diff prod_info_old:^ProducerInfo prod_info_new:^ProducerInfo = ComplaintDescr;\n            const description = unpackedComplaints.readCell();\n            const createdAt = unpackedComplaints.readNumber();\n            const severity = unpackedComplaints.readNumber();\n            const rewardAddress = new core_1.Address(-1, Buffer.from(unpackedComplaints.readBigNumber().toString(16), 'hex'));\n            const paid = unpackedComplaints.readBigNumber();\n            const suggestedFine = unpackedComplaints.readBigNumber();\n            const suggestedFinePart = unpackedComplaints.readBigNumber();\n            const votes = [];\n            const votersListRaw = new core_1.TupleReader(completeUnpackedComplaint.readLispList());\n            while (votersListRaw.remaining > 0) {\n                votes.push(votersListRaw.readNumber());\n            }\n            const vsetId = completeUnpackedComplaint.readBigNumber();\n            const remainingWeight = completeUnpackedComplaint.readBigNumber();\n            results.push({\n                id,\n                publicKey,\n                createdAt,\n                severity,\n                paid,\n                suggestedFine,\n                suggestedFinePart,\n                rewardAddress,\n                votes,\n                remainingWeight,\n                vsetId\n            });\n        }\n        return results;\n    }\n}\nexports.ElectorContract = ElectorContract;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}