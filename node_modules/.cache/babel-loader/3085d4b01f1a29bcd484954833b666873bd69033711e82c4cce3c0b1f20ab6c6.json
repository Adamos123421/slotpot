{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateMerkleProof = void 0;\nconst Builder_1 = require(\"../boc/Builder\");\nconst readUnaryLength_1 = require(\"./utils/readUnaryLength\");\nfunction convertToPrunedBranch(c) {\n  return (0, Builder_1.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).endCell({\n    exotic: true\n  });\n}\nfunction convertToMerkleProof(c) {\n  return (0, Builder_1.beginCell)().storeUint(3, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).storeRef(c).endCell({\n    exotic: true\n  });\n}\nfunction doGenerateMerkleProof(prefix, slice, n, key) {\n  // Reading label\n  const originalCell = slice.asCell();\n  let lb0 = slice.loadBit() ? 1 : 0;\n  let prefixLength = 0;\n  let pp = prefix;\n  if (lb0 === 0) {\n    // Short label detected\n    // Read\n    prefixLength = (0, readUnaryLength_1.readUnaryLength)(slice);\n    // Read prefix\n    for (let i = 0; i < prefixLength; i++) {\n      pp += slice.loadBit() ? '1' : '0';\n    }\n  } else {\n    let lb1 = slice.loadBit() ? 1 : 0;\n    if (lb1 === 0) {\n      // Long label detected\n      prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n      for (let i = 0; i < prefixLength; i++) {\n        pp += slice.loadBit() ? '1' : '0';\n      }\n    } else {\n      // Same label detected\n      let bit = slice.loadBit() ? '1' : '0';\n      prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n      for (let i = 0; i < prefixLength; i++) {\n        pp += bit;\n      }\n    }\n  }\n  if (n - prefixLength === 0) {\n    return originalCell;\n  } else {\n    let sl = originalCell.beginParse();\n    let left = sl.loadRef();\n    let right = sl.loadRef();\n    // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'\n    if (!left.isExotic) {\n      if (pp + '0' === key.slice(0, pp.length + 1)) {\n        left = doGenerateMerkleProof(pp + '0', left.beginParse(), n - prefixLength - 1, key);\n      } else {\n        left = convertToPrunedBranch(left);\n      }\n    }\n    if (!right.isExotic) {\n      if (pp + '1' === key.slice(0, pp.length + 1)) {\n        right = doGenerateMerkleProof(pp + '1', right.beginParse(), n - prefixLength - 1, key);\n      } else {\n        right = convertToPrunedBranch(right);\n      }\n    }\n    return (0, Builder_1.beginCell)().storeSlice(sl).storeRef(left).storeRef(right).endCell();\n  }\n}\nfunction generateMerkleProof(dict, key, keyObject) {\n  const s = (0, Builder_1.beginCell)().storeDictDirect(dict).endCell().beginParse();\n  return convertToMerkleProof(doGenerateMerkleProof('', s, keyObject.bits, keyObject.serialize(key).toString(2).padStart(keyObject.bits, '0')));\n}\nexports.generateMerkleProof = generateMerkleProof;","map":{"version":3,"names":["Object","defineProperty","exports","value","generateMerkleProof","Builder_1","require","readUnaryLength_1","convertToPrunedBranch","c","beginCell","storeUint","storeBuffer","hash","depth","endCell","exotic","convertToMerkleProof","storeRef","doGenerateMerkleProof","prefix","slice","n","key","originalCell","asCell","lb0","loadBit","prefixLength","pp","readUnaryLength","i","lb1","loadUint","Math","ceil","log2","bit","sl","beginParse","left","loadRef","right","isExotic","length","storeSlice","dict","keyObject","s","storeDictDirect","bits","serialize","toString","padStart"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/dict/generateMerkleProof.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateMerkleProof = void 0;\nconst Builder_1 = require(\"../boc/Builder\");\nconst readUnaryLength_1 = require(\"./utils/readUnaryLength\");\nfunction convertToPrunedBranch(c) {\n    return (0, Builder_1.beginCell)()\n        .storeUint(1, 8)\n        .storeUint(1, 8)\n        .storeBuffer(c.hash(0))\n        .storeUint(c.depth(0), 16)\n        .endCell({ exotic: true });\n}\nfunction convertToMerkleProof(c) {\n    return (0, Builder_1.beginCell)()\n        .storeUint(3, 8)\n        .storeBuffer(c.hash(0))\n        .storeUint(c.depth(0), 16)\n        .storeRef(c)\n        .endCell({ exotic: true });\n}\nfunction doGenerateMerkleProof(prefix, slice, n, key) {\n    // Reading label\n    const originalCell = slice.asCell();\n    let lb0 = slice.loadBit() ? 1 : 0;\n    let prefixLength = 0;\n    let pp = prefix;\n    if (lb0 === 0) {\n        // Short label detected\n        // Read\n        prefixLength = (0, readUnaryLength_1.readUnaryLength)(slice);\n        // Read prefix\n        for (let i = 0; i < prefixLength; i++) {\n            pp += slice.loadBit() ? '1' : '0';\n        }\n    }\n    else {\n        let lb1 = slice.loadBit() ? 1 : 0;\n        if (lb1 === 0) {\n            // Long label detected\n            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n            for (let i = 0; i < prefixLength; i++) {\n                pp += slice.loadBit() ? '1' : '0';\n            }\n        }\n        else {\n            // Same label detected\n            let bit = slice.loadBit() ? '1' : '0';\n            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n            for (let i = 0; i < prefixLength; i++) {\n                pp += bit;\n            }\n        }\n    }\n    if (n - prefixLength === 0) {\n        return originalCell;\n    }\n    else {\n        let sl = originalCell.beginParse();\n        let left = sl.loadRef();\n        let right = sl.loadRef();\n        // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'\n        if (!left.isExotic) {\n            if (pp + '0' === key.slice(0, pp.length + 1)) {\n                left = doGenerateMerkleProof(pp + '0', left.beginParse(), n - prefixLength - 1, key);\n            }\n            else {\n                left = convertToPrunedBranch(left);\n            }\n        }\n        if (!right.isExotic) {\n            if (pp + '1' === key.slice(0, pp.length + 1)) {\n                right = doGenerateMerkleProof(pp + '1', right.beginParse(), n - prefixLength - 1, key);\n            }\n            else {\n                right = convertToPrunedBranch(right);\n            }\n        }\n        return (0, Builder_1.beginCell)()\n            .storeSlice(sl)\n            .storeRef(left)\n            .storeRef(right)\n            .endCell();\n    }\n}\nfunction generateMerkleProof(dict, key, keyObject) {\n    const s = (0, Builder_1.beginCell)().storeDictDirect(dict).endCell().beginParse();\n    return convertToMerkleProof(doGenerateMerkleProof('', s, keyObject.bits, keyObject.serialize(key).toString(2).padStart(keyObject.bits, '0')));\n}\nexports.generateMerkleProof = generateMerkleProof;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}