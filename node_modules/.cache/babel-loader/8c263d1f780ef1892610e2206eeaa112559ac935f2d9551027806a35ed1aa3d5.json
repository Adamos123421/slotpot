{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deriveMnemonicsPath = exports.deriveMnemonicHardenedKey = exports.getMnemonicsMasterKeyFromSeed = void 0;\nconst mnemonic_1 = require(\"../mnemonic/mnemonic\");\nconst hmac_sha512_1 = require(\"../primitives/hmac_sha512\");\nconst HARDENED_OFFSET = 0x80000000;\nconst MNEMONICS_SEED = 'TON Mnemonics HD seed';\nasync function getMnemonicsMasterKeyFromSeed(seed) {\n  const I = await (0, hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, seed);\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n}\nexports.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;\n;\nasync function deriveMnemonicHardenedKey(parent, index) {\n  if (index >= HARDENED_OFFSET) {\n    throw Error('Key index must be less than offset');\n  }\n  // Key Derive Path: 0x00 + parent.key + index;\n  const indexBuffer = Buffer.alloc(4);\n  indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);\n  const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);\n  // Derive key\n  const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n}\nexports.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;\nasync function deriveMnemonicsPath(seed, path) {\n  let wordsCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 24;\n  let password = arguments.length > 3 ? arguments[3] : undefined;\n  let state = await getMnemonicsMasterKeyFromSeed(seed);\n  let remaining = [...path];\n  while (remaining.length > 0) {\n    let index = remaining[0];\n    remaining = remaining.slice(1);\n    state = await deriveMnemonicHardenedKey(state, index);\n  }\n  return await (0, mnemonic_1.mnemonicFromRandomSeed)(state.key, wordsCount, password);\n}\nexports.deriveMnemonicsPath = deriveMnemonicsPath;","map":{"version":3,"names":["Object","defineProperty","exports","value","deriveMnemonicsPath","deriveMnemonicHardenedKey","getMnemonicsMasterKeyFromSeed","mnemonic_1","require","hmac_sha512_1","HARDENED_OFFSET","MNEMONICS_SEED","seed","I","hmac_sha512","IL","slice","IR","key","chainCode","parent","index","Error","indexBuffer","Buffer","alloc","writeUInt32BE","data","concat","path","wordsCount","arguments","length","undefined","password","state","remaining","mnemonicFromRandomSeed"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/crypto/dist/hd/mnemonics.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deriveMnemonicsPath = exports.deriveMnemonicHardenedKey = exports.getMnemonicsMasterKeyFromSeed = void 0;\nconst mnemonic_1 = require(\"../mnemonic/mnemonic\");\nconst hmac_sha512_1 = require(\"../primitives/hmac_sha512\");\nconst HARDENED_OFFSET = 0x80000000;\nconst MNEMONICS_SEED = 'TON Mnemonics HD seed';\nasync function getMnemonicsMasterKeyFromSeed(seed) {\n    const I = await (0, hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, seed);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n}\nexports.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;\n;\nasync function deriveMnemonicHardenedKey(parent, index) {\n    if (index >= HARDENED_OFFSET) {\n        throw Error('Key index must be less than offset');\n    }\n    // Key Derive Path: 0x00 + parent.key + index;\n    const indexBuffer = Buffer.alloc(4);\n    indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);\n    const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);\n    // Derive key\n    const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n}\nexports.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;\nasync function deriveMnemonicsPath(seed, path, wordsCount = 24, password) {\n    let state = await getMnemonicsMasterKeyFromSeed(seed);\n    let remaining = [...path];\n    while (remaining.length > 0) {\n        let index = remaining[0];\n        remaining = remaining.slice(1);\n        state = await deriveMnemonicHardenedKey(state, index);\n    }\n    return await (0, mnemonic_1.mnemonicFromRandomSeed)(state.key, wordsCount, password);\n}\nexports.deriveMnemonicsPath = deriveMnemonicsPath;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}