{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\adams\\\\OneDrive\\\\Desktop\\\\Work\\\\slotpot\\\\src\\\\components\\\\SimpleCarousel.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { TonIcon } from './IconComponents';\nimport soundService from '../services/soundService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SimpleCarousel = ({\n  players,\n  isSpinning,\n  onSpinComplete,\n  contractWinner,\n  totalJackpotValue\n}) => {\n  _s();\n  const [wheelState, setWheelState] = useState('idle'); // 'idle', 'waiting', 'spinning', 'winner', 'finished'\n  const [lockedPlayers, setLockedPlayers] = useState([]); // Lock players during animation\n  const wheelRef = useRef();\n  const idleAnimationRef = useRef();\n  const currentPosition = useRef(0);\n  const winnerShowcaseTimeoutRef = useRef();\n\n  // Card dimensions (matching roulette example)\n  const CARD_WIDTH = 81; // 75px + 3px margin on each side\n\n  // Lock players when spinning starts to prevent them from changing during animation\n  useEffect(() => {\n    if (isSpinning && contractWinner && players.length > 0) {\n      console.log('üîí Locking players for animation:', players);\n      setLockedPlayers([...players]);\n    }\n  }, [isSpinning, contractWinner, players]);\n\n  // Use locked players during animation, regular players otherwise\n  const effectivePlayers = wheelState === 'spinning' || wheelState === 'winner' ? lockedPlayers : players;\n\n  // Render individual player card HTML\n  const renderPlayerCard = useCallback((player, key) => {\n    if (!player) {\n      return `\n        <div class=\"waiting-card\">\n          <div class=\"avatar-container\">\n            ?\n          </div>\n          <div class=\"waiting-text\">Waiting</div>\n          <div class=\"waiting-amount\">0.000</div>\n        </div>\n      `;\n    }\n\n    // Always show the amount if it exists, regardless of isRealPlayer\n    const amount = player.bet || player.amount || 0;\n    const isActive = amount > 0;\n    const avatar = player.avatar && player.avatar !== '‚ùì' ? player.avatar : \"/img/unknown.webp\";\n    const username = player.username || player.displayName || player.name || 'Player';\n    const bet = amount.toFixed(3);\n    return `\n      <div class=\"player-card ${isActive ? 'active' : 'inactive'}\" data-key=\"${key}\">\n        <div class=\"card-content\">\n          <div class=\"avatar-container\">\n            <img src=\"${avatar}\" alt=\"${username}\" class=\"player-avatar\" />\n          </div>\n          <div class=\"player-info\">\n            <p class=\"player-name\">${username}</p>\n            <div class=\"bet-info\">\n              <div class=\"coin-icon ${!isActive ? 'grayscale' : ''}\"></div>\n              <span class=\"bet-amount\">${bet}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }, []);\n\n  // Initialize wheel with player rows for infinite scrolling\n  const initWheel = useCallback(() => {\n    if (!wheelRef.current || !effectivePlayers.length) return;\n    const wheel = wheelRef.current;\n    wheel.innerHTML = ''; // Clear existing content\n\n    // Create one continuous row with multiple player cycles for smooth infinite scroll\n    const row = document.createElement('div');\n    row.className = 'roulette-row';\n\n    // Create enough copies to ensure smooth infinite scrolling (50 copies)\n    for (let copyIndex = 0; copyIndex < 50; copyIndex++) {\n      effectivePlayers.forEach((player, playerIndex) => {\n        const card = document.createElement('div');\n        card.className = 'roulette-card';\n        card.innerHTML = renderPlayerCard(player, `${copyIndex}-${playerIndex}`);\n        row.appendChild(card);\n      });\n    }\n    wheel.appendChild(row);\n  }, [effectivePlayers, renderPlayerCard]);\n\n  // Idle movement - constant speed with true infinite scroll\n  const startIdleMovement = useCallback(() => {\n    if (!wheelRef.current || wheelState !== 'idle') return;\n    const animate = () => {\n      var _wheelRef$current;\n      if (wheelState !== 'idle') return;\n      currentPosition.current -= 0.5; // Slower, smoother movement (0.5px per frame)\n\n      // True infinite scroll - reset when we've scrolled through several player cycles\n      // Use actual card spacing for consistency\n      const firstCard = (_wheelRef$current = wheelRef.current) === null || _wheelRef$current === void 0 ? void 0 : _wheelRef$current.querySelector('.roulette-card');\n      const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n      const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n      const totalCardSpacing = actualCardWidth + cardMargin;\n      const cycleWidth = effectivePlayers.length * totalCardSpacing;\n      const resetPoint = -(cycleWidth * 10); // Reset after 10 cycles\n\n      if (currentPosition.current <= resetPoint) {\n        // Reset to a position that maintains visual continuity\n        currentPosition.current = -(cycleWidth * 5); // Reset to middle area\n      }\n      if (wheelRef.current) {\n        wheelRef.current.style.transform = `translate3d(${currentPosition.current}px, 0px, 0px)`;\n      }\n      idleAnimationRef.current = requestAnimationFrame(animate);\n    };\n    idleAnimationRef.current = requestAnimationFrame(animate);\n  }, [wheelState, effectivePlayers.length, CARD_WIDTH]);\n\n  // Stop idle movement\n  const stopIdleMovement = useCallback(() => {\n    if (idleAnimationRef.current) {\n      cancelAnimationFrame(idleAnimationRef.current);\n      idleAnimationRef.current = null;\n    }\n  }, []);\n\n  // Find winner position in player array\n  const findWinnerPosition = useCallback(winner => {\n    if (!winner || !effectivePlayers.length) return -1;\n    console.log('Looking for winner:', winner);\n    console.log('Available players:', effectivePlayers);\n    for (let i = 0; i < effectivePlayers.length; i++) {\n      const player = effectivePlayers[i];\n      if (player && player.address && (player.address === winner.winner || player.address === winner.fullAddress) || player && player.fullAddress && (player.fullAddress === winner.winner || player.fullAddress === winner.fullAddress) || player && player.username && player.username === winner.username || player && player.displayName && player.displayName === winner.displayName) {\n        console.log(`Found winner at position ${i}:`, player);\n        return i;\n      }\n    }\n    console.warn('Winner not found in player list');\n    return -1;\n  }, [effectivePlayers]);\n\n  // Spin wheel function with improved accuracy\n  const spinWheel = useCallback(targetWinner => {\n    if (wheelState === 'spinning' || !wheelRef.current) return;\n    console.log('Starting spin with winner:', targetWinner);\n\n    // Play launch sound when spin starts\n    soundService.playLaunch();\n    setWheelState('spinning');\n    stopIdleMovement();\n    const winnerPosition = findWinnerPosition(targetWinner);\n    if (winnerPosition === -1) {\n      console.warn('Winner not found in player list, spinning randomly');\n      // If winner not found, still spin but land on first player\n      const fallbackPosition = 0;\n      performSpin(fallbackPosition, targetWinner);\n      return;\n    }\n    performSpin(winnerPosition, targetWinner);\n  }, [wheelState, stopIdleMovement, findWinnerPosition, effectivePlayers.length, onSpinComplete, CARD_WIDTH]);\n\n  // Separate function to perform the actual spin animation\n  const performSpin = useCallback((winnerPosition, targetWinner) => {\n    const wheel = wheelRef.current;\n    if (!wheel) return;\n\n    // Calculate precise landing position with improved accuracy\n    const wheelWidth = wheel.offsetWidth;\n    const centerOffset = wheelWidth / 2; // Center of the wheel view\n\n    // Get actual card measurements from DOM for precision\n    const firstCard = wheel.querySelector('.roulette-card');\n    const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n    const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n    const totalCardSpacing = actualCardWidth + cardMargin;\n    console.log(`üìè Card measurements: width=${actualCardWidth}px, margin=${cardMargin}px, total=${totalCardSpacing}px`);\n    console.log(`üéØ Winner found at array position: ${winnerPosition}`);\n    console.log(`üìã Total players in array: ${effectivePlayers.length}`);\n\n    // CRITICAL FIX: Account for the wheel's current position and center alignment\n    // The wheel shows multiple cards, and we need to center the winner under the selector line\n\n    // Calculate where the winner card should be positioned to be centered\n    // The selector line is at the center of the wheel view\n    const targetCardLeftEdge = winnerPosition * totalCardSpacing;\n    const targetCardCenter = targetCardLeftEdge + actualCardWidth / 2;\n\n    // DIRECT SLIDE APPROACH: Find the closest visible instance of the winner\n    // Since we have 50 cycles of cards, find the winner instance closest to current view\n\n    const cycleLength = effectivePlayers.length * totalCardSpacing;\n\n    // SIMPLIFIED APPROACH: Work within the current visible area\n    // Instead of complex cycle calculations, just find the winner relative to current position\n\n    // Current position is negative (wheel moves left), so we need to account for this\n    const currentAbsolutePosition = Math.abs(currentPosition.current);\n\n    // Find which cycle we're currently viewing\n    const currentCycle = Math.floor(currentAbsolutePosition / cycleLength);\n\n    // Calculate the winner position in the current and adjacent cycles\n    const winnerInCurrentCycle = currentCycle * cycleLength + winnerPosition * totalCardSpacing;\n    const winnerInNextCycle = (currentCycle + 1) * cycleLength + winnerPosition * totalCardSpacing;\n    const winnerInPrevCycle = Math.max(0, (currentCycle - 1) * cycleLength + winnerPosition * totalCardSpacing);\n\n    // Find which winner position is closest to our current view center\n    const currentViewCenter = currentAbsolutePosition + centerOffset;\n    const candidates = [winnerInPrevCycle, winnerInCurrentCycle, winnerInNextCycle];\n    let closestWinnerPosition = winnerInCurrentCycle;\n    let smallestDistance = Math.abs(winnerInCurrentCycle + actualCardWidth / 2 - currentViewCenter);\n    for (const candidatePos of candidates) {\n      const candidateCenter = candidatePos + actualCardWidth / 2;\n      const distance = Math.abs(candidateCenter - currentViewCenter);\n      if (distance < smallestDistance) {\n        smallestDistance = distance;\n        closestWinnerPosition = candidatePos;\n      }\n    }\n\n    // Calculate final position - we want to move the wheel so the winner is centered\n    // Since currentPosition is negative and we're moving left, we need:\n    // finalPosition = -closestWinnerPosition + centerOffset - (actualCardWidth / 2)\n    const finalPosition = -(closestWinnerPosition + actualCardWidth / 2 - centerOffset);\n    console.log(`üéØ Simplified slide calculation:`);\n    console.log(`   - Winner array position: ${winnerPosition}`);\n    console.log(`   - Cycle length: ${cycleLength}px`);\n    console.log(`   - Current absolute position: ${currentAbsolutePosition}px`);\n    console.log(`   - Current cycle: ${currentCycle}`);\n    console.log(`   - Current view center: ${currentViewCenter}px`);\n    console.log(`   - Winner candidates: [${winnerInPrevCycle}, ${winnerInCurrentCycle}, ${winnerInNextCycle}]`);\n    console.log(`   - Closest winner position: ${closestWinnerPosition}px`);\n    console.log(`   - Wheel center (selector): ${centerOffset}px`);\n    console.log(`   - Current position: ${currentPosition.current}px`);\n    console.log(`   - Final position: ${finalPosition}px`);\n    console.log(`   - Movement distance: ${Math.abs(finalPosition - currentPosition.current)}px`);\n\n    // Multi-stage dramatic slow-down animation\n    let tickInterval;\n    let currentStage = 0;\n    const performDramaticSpin = () => {\n      const stages = [\n      // Stage 1: Fast spinning (1.5s)\n      {\n        duration: 1500,\n        easing: 'cubic-bezier(0.4, 0, 0.6, 1)',\n        progress: 0.3,\n        // 30% of the way to target\n        tickSpeed: 100,\n        // Fast ticking\n        className: 'spinning'\n      },\n      // Stage 2: Visible slowdown (2s)\n      {\n        duration: 2000,\n        easing: 'cubic-bezier(0.25, 0.1, 0.4, 1)',\n        progress: 0.75,\n        // 75% of the way to target\n        tickSpeed: 200,\n        // Slower ticking\n        className: 'slowing-down'\n      },\n      // Stage 3: Final dramatic slowdown (2s)\n      {\n        duration: 2000,\n        easing: 'cubic-bezier(0.05, 0.1, 0.05, 1)',\n        progress: 1.0,\n        // Final position\n        tickSpeed: 400,\n        // Very slow ticking\n        className: 'final-slowdown'\n      }];\n      const executeStage = stageIndex => {\n        if (stageIndex >= stages.length) {\n          // All stages complete\n          clearInterval(tickInterval);\n          soundService.playWinner(); // Play winner sound at the end\n          return;\n        }\n        const stage = stages[stageIndex];\n        const targetForStage = currentPosition.current + (finalPosition - currentPosition.current) * stage.progress;\n\n        // Update wheel class for visual feedback\n        wheel.className = `carousel-track ${stage.className}`;\n\n        // Set transition properties\n        wheel.style.transitionTimingFunction = stage.easing;\n        wheel.style.transitionDuration = `${stage.duration}ms`;\n        wheel.style.transform = `translate3d(${targetForStage}px, 0px, 0px)`;\n\n        // Update tick sound interval\n        if (tickInterval) clearInterval(tickInterval);\n        tickInterval = setInterval(() => {\n          soundService.playSpin();\n        }, stage.tickSpeed);\n\n        // Update current position for next stage\n        currentPosition.current = targetForStage;\n\n        // Schedule next stage\n        setTimeout(() => {\n          executeStage(stageIndex + 1);\n        }, stage.duration);\n      };\n\n      // Start the dramatic sequence\n      executeStage(0);\n    };\n    performDramaticSpin();\n\n    // Update current position\n    currentPosition.current = finalPosition;\n\n    // After slide animation completes (total: 1.5s + 2s + 2s = 5.5s), show winner\n    setTimeout(() => {\n      console.log('Dramatic spin animation completed, showing winner');\n      setWheelState('winner');\n\n      // Highlight the winner card (find all instances of the winner across all cycles)\n      const allCards = wheel.querySelectorAll('.roulette-card');\n      console.log(`üéØ Highlighting winner at position ${winnerPosition} out of ${effectivePlayers.length} players`);\n\n      // Highlight all cards that represent the winner (across all 50 cycles)\n      allCards.forEach((card, index) => {\n        const cardPlayerIndex = index % effectivePlayers.length;\n        if (cardPlayerIndex === winnerPosition) {\n          card.classList.add('winner-highlight');\n          console.log(`‚ú® Highlighted card at index ${index} (player ${cardPlayerIndex})`);\n        }\n      });\n\n      // TEMPORARY DEBUG: Add visual indicators to see positioning\n      console.log(`üîç DEBUG: Checking final card positions after slide:`);\n      const wheelRect = wheel.getBoundingClientRect();\n      const selectorRect = wheel.parentElement.querySelector('.roulette-selector').getBoundingClientRect();\n      console.log(`   - Wheel left: ${wheelRect.left}px`);\n      console.log(`   - Selector left: ${selectorRect.left}px`);\n      console.log(`   - Selector center: ${selectorRect.left + selectorRect.width / 2}px`);\n\n      // Check which card is actually centered\n      allCards.forEach((card, index) => {\n        const cardRect = card.getBoundingClientRect();\n        const cardCenter = cardRect.left + cardRect.width / 2;\n        const distanceFromSelector = Math.abs(cardCenter - (selectorRect.left + selectorRect.width / 2));\n        if (distanceFromSelector < 20) {\n          // Within 20px of selector\n          const cardPlayerIndex = index % effectivePlayers.length;\n          console.log(`üéØ Card at selector: index ${index}, player ${cardPlayerIndex}, distance: ${distanceFromSelector}px`);\n        }\n      });\n\n      // After showcasing winner for 6 seconds, go to finished state\n      winnerShowcaseTimeoutRef.current = setTimeout(() => {\n        console.log('Winner showcase complete, entering finished state');\n\n        // Remove winner highlights\n        const highlightedCards = wheel.querySelectorAll('.winner-highlight');\n        highlightedCards.forEach(card => {\n          card.classList.remove('winner-highlight');\n        });\n\n        // Reset transition styles\n        wheel.style.transitionTimingFunction = '';\n        wheel.style.transitionDuration = '';\n\n        // Clear locked players\n        setLockedPlayers([]);\n\n        // Go to finished state instead of idle to prevent scrolling\n        setWheelState('finished');\n        onSpinComplete === null || onSpinComplete === void 0 ? void 0 : onSpinComplete(targetWinner);\n      }, 6000); // Show winner for 6 seconds\n    }, 3000); // Wait for slide animation (3 seconds)\n  }, [effectivePlayers.length, CARD_WIDTH, onSpinComplete]);\n\n  // Handle state changes\n  useEffect(() => {\n    if (isSpinning && contractWinner && wheelState === 'waiting') {\n      // Backend responded with winner, start spinning\n      console.log('Starting roulette spin with winner:', contractWinner);\n      spinWheel(contractWinner);\n    } else if (isSpinning && !contractWinner && wheelState === 'idle') {\n      // Bet placed, stop and wait for backend\n      console.log('Stopping wheel, waiting for winner...');\n      setWheelState('waiting');\n      stopIdleMovement();\n    } else if (!isSpinning && wheelState !== 'idle' && wheelState !== 'winner' && wheelState !== 'finished') {\n      // Reset to idle state (but don't interrupt winner showcase or finished state)\n      console.log('Resetting to idle state');\n      setWheelState('idle');\n    }\n  }, [isSpinning, contractWinner, wheelState, spinWheel, stopIdleMovement]);\n\n  // Detect new game start and reset from finished state to idle\n  useEffect(() => {\n    // If we're in finished state and there's no winner (new game starting), reset to idle\n    if (wheelState === 'finished' && !contractWinner && !isSpinning) {\n      console.log('New game detected - resetting from finished to idle');\n      setWheelState('idle');\n    }\n  }, [wheelState, contractWinner, isSpinning]);\n\n  // Start/stop idle movement based on state\n  useEffect(() => {\n    if (wheelState === 'idle') {\n      startIdleMovement();\n    } else {\n      stopIdleMovement();\n    }\n    return () => stopIdleMovement();\n  }, [wheelState, startIdleMovement, stopIdleMovement]);\n\n  // Initialize wheel when effective players change (but not during winner showcase)\n  useEffect(() => {\n    // Don't reinitialize during winner showcase or finished state to preserve highlighting\n    if (wheelState !== 'winner' && wheelState !== 'finished') {\n      initWheel();\n    }\n  }, [initWheel, wheelState]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (winnerShowcaseTimeoutRef.current) {\n        clearTimeout(winnerShowcaseTimeoutRef.current);\n      }\n    };\n  }, []);\n  if (!effectivePlayers || effectivePlayers.length === 0) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"simple-carousel\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"carousel-message\",\n        children: \"Waiting for players to join...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 462,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 461,\n      columnNumber: 7\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"roulette-wrapper\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"roulette-selector\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 472,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: wheelRef,\n      className: \"roulette-wheel\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 475,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"wheel-state-indicator\",\n      children: [wheelState === 'idle' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFB0\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 479,\n        columnNumber: 35\n      }, this), wheelState === 'waiting' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\u23F3\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 480,\n        columnNumber: 38\n      }, this), wheelState === 'spinning' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFAF\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 481,\n        columnNumber: 39\n      }, this), wheelState === 'winner' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDF89\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 482,\n        columnNumber: 37\n      }, this), wheelState === 'finished' && /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"\\uD83C\\uDFC1\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 483,\n        columnNumber: 39\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 478,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"absolute -top-1/4 -right-1/3 h-full opacity-75 will-change-transform z-[3] pointer-events-none\",\n      style: {\n        maskImage: 'linear-gradient(black, transparent 50%)'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"img\", {\n        src: \"/img/glare.webp\",\n        className: \"w-full object-cover object-center\",\n        alt: \"\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 491,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 487,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 470,\n    columnNumber: 5\n  }, this);\n};\n_s(SimpleCarousel, \"VIxi7lGLuxZ4CmPOzTtmWajujkE=\");\n_c = SimpleCarousel;\nexport default SimpleCarousel;\nvar _c;\n$RefreshReg$(_c, \"SimpleCarousel\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","TonIcon","soundService","jsxDEV","_jsxDEV","SimpleCarousel","players","isSpinning","onSpinComplete","contractWinner","totalJackpotValue","_s","wheelState","setWheelState","lockedPlayers","setLockedPlayers","wheelRef","idleAnimationRef","currentPosition","winnerShowcaseTimeoutRef","CARD_WIDTH","length","console","log","effectivePlayers","renderPlayerCard","player","key","amount","bet","isActive","avatar","username","displayName","name","toFixed","initWheel","current","wheel","innerHTML","row","document","createElement","className","copyIndex","forEach","playerIndex","card","appendChild","startIdleMovement","animate","_wheelRef$current","firstCard","querySelector","actualCardWidth","offsetWidth","cardMargin","parseInt","getComputedStyle","marginLeft","marginRight","totalCardSpacing","cycleWidth","resetPoint","style","transform","requestAnimationFrame","stopIdleMovement","cancelAnimationFrame","findWinnerPosition","winner","i","address","fullAddress","warn","spinWheel","targetWinner","playLaunch","winnerPosition","fallbackPosition","performSpin","wheelWidth","centerOffset","targetCardLeftEdge","targetCardCenter","cycleLength","currentAbsolutePosition","Math","abs","currentCycle","floor","winnerInCurrentCycle","winnerInNextCycle","winnerInPrevCycle","max","currentViewCenter","candidates","closestWinnerPosition","smallestDistance","candidatePos","candidateCenter","distance","finalPosition","tickInterval","currentStage","performDramaticSpin","stages","duration","easing","progress","tickSpeed","executeStage","stageIndex","clearInterval","playWinner","stage","targetForStage","transitionTimingFunction","transitionDuration","setInterval","playSpin","setTimeout","allCards","querySelectorAll","index","cardPlayerIndex","classList","add","wheelRect","getBoundingClientRect","selectorRect","parentElement","left","width","cardRect","cardCenter","distanceFromSelector","highlightedCards","remove","clearTimeout","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","maskImage","src","alt","_c","$RefreshReg$"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/src/components/SimpleCarousel.js"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { TonIcon } from './IconComponents';\nimport soundService from '../services/soundService';\n\nconst SimpleCarousel = ({ \n  players, \n  isSpinning, \n  onSpinComplete, \n  contractWinner,\n  totalJackpotValue \n}) => {\n  const [wheelState, setWheelState] = useState('idle'); // 'idle', 'waiting', 'spinning', 'winner', 'finished'\n  const [lockedPlayers, setLockedPlayers] = useState([]); // Lock players during animation\n  const wheelRef = useRef();\n  const idleAnimationRef = useRef();\n  const currentPosition = useRef(0);\n  const winnerShowcaseTimeoutRef = useRef();\n  \n  // Card dimensions (matching roulette example)\n  const CARD_WIDTH = 81; // 75px + 3px margin on each side\n  \n  // Lock players when spinning starts to prevent them from changing during animation\n  useEffect(() => {\n    if (isSpinning && contractWinner && players.length > 0) {\n      console.log('üîí Locking players for animation:', players);\n      setLockedPlayers([...players]);\n    }\n  }, [isSpinning, contractWinner, players]);\n  \n  // Use locked players during animation, regular players otherwise\n  const effectivePlayers = wheelState === 'spinning' || wheelState === 'winner' ? lockedPlayers : players;\n  \n  // Render individual player card HTML\n  const renderPlayerCard = useCallback((player, key) => {\n    if (!player) {\n      return `\n        <div class=\"waiting-card\">\n          <div class=\"avatar-container\">\n            ?\n          </div>\n          <div class=\"waiting-text\">Waiting</div>\n          <div class=\"waiting-amount\">0.000</div>\n        </div>\n      `;\n    }\n    \n    // Always show the amount if it exists, regardless of isRealPlayer\n    const amount = player.bet || player.amount || 0;\n    const isActive = amount > 0;\n    const avatar = player.avatar && player.avatar !== '‚ùì' ? player.avatar : \"/img/unknown.webp\";\n    const username = player.username || player.displayName || player.name || 'Player';\n    const bet = amount.toFixed(3);\n    \n    return `\n      <div class=\"player-card ${isActive ? 'active' : 'inactive'}\" data-key=\"${key}\">\n        <div class=\"card-content\">\n          <div class=\"avatar-container\">\n            <img src=\"${avatar}\" alt=\"${username}\" class=\"player-avatar\" />\n          </div>\n          <div class=\"player-info\">\n            <p class=\"player-name\">${username}</p>\n            <div class=\"bet-info\">\n              <div class=\"coin-icon ${!isActive ? 'grayscale' : ''}\"></div>\n              <span class=\"bet-amount\">${bet}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }, []);\n\n  // Initialize wheel with player rows for infinite scrolling\n  const initWheel = useCallback(() => {\n    if (!wheelRef.current || !effectivePlayers.length) return;\n    \n    const wheel = wheelRef.current;\n    wheel.innerHTML = ''; // Clear existing content\n    \n    // Create one continuous row with multiple player cycles for smooth infinite scroll\n    const row = document.createElement('div');\n    row.className = 'roulette-row';\n    \n    // Create enough copies to ensure smooth infinite scrolling (50 copies)\n    for (let copyIndex = 0; copyIndex < 50; copyIndex++) {\n      effectivePlayers.forEach((player, playerIndex) => {\n        const card = document.createElement('div');\n        card.className = 'roulette-card';\n        card.innerHTML = renderPlayerCard(player, `${copyIndex}-${playerIndex}`);\n        row.appendChild(card);\n      });\n    }\n    \n    wheel.appendChild(row);\n  }, [effectivePlayers, renderPlayerCard]);\n\n  // Idle movement - constant speed with true infinite scroll\n  const startIdleMovement = useCallback(() => {\n    if (!wheelRef.current || wheelState !== 'idle') return;\n    \n    const animate = () => {\n      if (wheelState !== 'idle') return;\n      \n      currentPosition.current -= 0.5; // Slower, smoother movement (0.5px per frame)\n      \n      // True infinite scroll - reset when we've scrolled through several player cycles\n      // Use actual card spacing for consistency\n      const firstCard = wheelRef.current?.querySelector('.roulette-card');\n      const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n      const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n      const totalCardSpacing = actualCardWidth + cardMargin;\n      \n      const cycleWidth = effectivePlayers.length * totalCardSpacing;\n      const resetPoint = -(cycleWidth * 10); // Reset after 10 cycles\n      \n      if (currentPosition.current <= resetPoint) {\n        // Reset to a position that maintains visual continuity\n        currentPosition.current = -(cycleWidth * 5); // Reset to middle area\n      }\n      \n      if (wheelRef.current) {\n        wheelRef.current.style.transform = `translate3d(${currentPosition.current}px, 0px, 0px)`;\n      }\n      \n      idleAnimationRef.current = requestAnimationFrame(animate);\n    };\n    \n    idleAnimationRef.current = requestAnimationFrame(animate);\n  }, [wheelState, effectivePlayers.length, CARD_WIDTH]);\n\n  // Stop idle movement\n  const stopIdleMovement = useCallback(() => {\n    if (idleAnimationRef.current) {\n      cancelAnimationFrame(idleAnimationRef.current);\n      idleAnimationRef.current = null;\n    }\n  }, []);\n\n  // Find winner position in player array\n  const findWinnerPosition = useCallback((winner) => {\n    if (!winner || !effectivePlayers.length) return -1;\n    \n    console.log('Looking for winner:', winner);\n    console.log('Available players:', effectivePlayers);\n    \n    for (let i = 0; i < effectivePlayers.length; i++) {\n      const player = effectivePlayers[i];\n      if (\n        (player && player.address && (player.address === winner.winner || player.address === winner.fullAddress)) ||\n        (player && player.fullAddress && (player.fullAddress === winner.winner || player.fullAddress === winner.fullAddress)) ||\n        (player && player.username && player.username === winner.username) ||\n        (player && player.displayName && player.displayName === winner.displayName)\n      ) {\n        console.log(`Found winner at position ${i}:`, player);\n        return i;\n      }\n    }\n    console.warn('Winner not found in player list');\n    return -1;\n  }, [effectivePlayers]);\n\n  // Spin wheel function with improved accuracy\n  const spinWheel = useCallback((targetWinner) => {\n    if (wheelState === 'spinning' || !wheelRef.current) return;\n    \n    console.log('Starting spin with winner:', targetWinner);\n    \n    // Play launch sound when spin starts\n    soundService.playLaunch();\n    \n    setWheelState('spinning');\n    stopIdleMovement();\n    \n    const winnerPosition = findWinnerPosition(targetWinner);\n    if (winnerPosition === -1) {\n      console.warn('Winner not found in player list, spinning randomly');\n      // If winner not found, still spin but land on first player\n      const fallbackPosition = 0;\n      performSpin(fallbackPosition, targetWinner);\n            return;\n          }\n          \n    performSpin(winnerPosition, targetWinner);\n    \n  }, [wheelState, stopIdleMovement, findWinnerPosition, effectivePlayers.length, onSpinComplete, CARD_WIDTH]);\n\n  // Separate function to perform the actual spin animation\n  const performSpin = useCallback((winnerPosition, targetWinner) => {\n    const wheel = wheelRef.current;\n    if (!wheel) return;\n\n    // Calculate precise landing position with improved accuracy\n    const wheelWidth = wheel.offsetWidth;\n    const centerOffset = wheelWidth / 2; // Center of the wheel view\n    \n    // Get actual card measurements from DOM for precision\n    const firstCard = wheel.querySelector('.roulette-card');\n    const actualCardWidth = firstCard ? firstCard.offsetWidth : CARD_WIDTH;\n    const cardMargin = firstCard ? parseInt(getComputedStyle(firstCard).marginLeft) + parseInt(getComputedStyle(firstCard).marginRight) : 6;\n    const totalCardSpacing = actualCardWidth + cardMargin;\n    \n    console.log(`üìè Card measurements: width=${actualCardWidth}px, margin=${cardMargin}px, total=${totalCardSpacing}px`);\n    console.log(`üéØ Winner found at array position: ${winnerPosition}`);\n    console.log(`üìã Total players in array: ${effectivePlayers.length}`);\n    \n    // CRITICAL FIX: Account for the wheel's current position and center alignment\n    // The wheel shows multiple cards, and we need to center the winner under the selector line\n    \n    // Calculate where the winner card should be positioned to be centered\n    // The selector line is at the center of the wheel view\n    const targetCardLeftEdge = winnerPosition * totalCardSpacing;\n    const targetCardCenter = targetCardLeftEdge + (actualCardWidth / 2);\n    \n    // DIRECT SLIDE APPROACH: Find the closest visible instance of the winner\n    // Since we have 50 cycles of cards, find the winner instance closest to current view\n    \n    const cycleLength = effectivePlayers.length * totalCardSpacing;\n    \n    // SIMPLIFIED APPROACH: Work within the current visible area\n    // Instead of complex cycle calculations, just find the winner relative to current position\n    \n    // Current position is negative (wheel moves left), so we need to account for this\n    const currentAbsolutePosition = Math.abs(currentPosition.current);\n    \n    // Find which cycle we're currently viewing\n    const currentCycle = Math.floor(currentAbsolutePosition / cycleLength);\n    \n    // Calculate the winner position in the current and adjacent cycles\n    const winnerInCurrentCycle = currentCycle * cycleLength + (winnerPosition * totalCardSpacing);\n    const winnerInNextCycle = (currentCycle + 1) * cycleLength + (winnerPosition * totalCardSpacing);\n    const winnerInPrevCycle = Math.max(0, (currentCycle - 1) * cycleLength + (winnerPosition * totalCardSpacing));\n    \n    // Find which winner position is closest to our current view center\n    const currentViewCenter = currentAbsolutePosition + centerOffset;\n    const candidates = [winnerInPrevCycle, winnerInCurrentCycle, winnerInNextCycle];\n    \n    let closestWinnerPosition = winnerInCurrentCycle;\n    let smallestDistance = Math.abs(winnerInCurrentCycle + (actualCardWidth / 2) - currentViewCenter);\n    \n    for (const candidatePos of candidates) {\n      const candidateCenter = candidatePos + (actualCardWidth / 2);\n      const distance = Math.abs(candidateCenter - currentViewCenter);\n      if (distance < smallestDistance) {\n        smallestDistance = distance;\n        closestWinnerPosition = candidatePos;\n      }\n    }\n    \n    // Calculate final position - we want to move the wheel so the winner is centered\n    // Since currentPosition is negative and we're moving left, we need:\n    // finalPosition = -closestWinnerPosition + centerOffset - (actualCardWidth / 2)\n    const finalPosition = -(closestWinnerPosition + (actualCardWidth / 2) - centerOffset);\n    \n         console.log(`üéØ Simplified slide calculation:`);\n     console.log(`   - Winner array position: ${winnerPosition}`);\n     console.log(`   - Cycle length: ${cycleLength}px`);\n     console.log(`   - Current absolute position: ${currentAbsolutePosition}px`);\n     console.log(`   - Current cycle: ${currentCycle}`);\n     console.log(`   - Current view center: ${currentViewCenter}px`);\n     console.log(`   - Winner candidates: [${winnerInPrevCycle}, ${winnerInCurrentCycle}, ${winnerInNextCycle}]`);\n     console.log(`   - Closest winner position: ${closestWinnerPosition}px`);\n     console.log(`   - Wheel center (selector): ${centerOffset}px`);\n     console.log(`   - Current position: ${currentPosition.current}px`);\n     console.log(`   - Final position: ${finalPosition}px`);\n     console.log(`   - Movement distance: ${Math.abs(finalPosition - currentPosition.current)}px`);\n    \n    // Multi-stage dramatic slow-down animation\n    let tickInterval;\n    let currentStage = 0;\n    \n    const performDramaticSpin = () => {\n      const stages = [\n        // Stage 1: Fast spinning (1.5s)\n        {\n          duration: 1500,\n          easing: 'cubic-bezier(0.4, 0, 0.6, 1)',\n          progress: 0.3, // 30% of the way to target\n          tickSpeed: 100, // Fast ticking\n          className: 'spinning'\n        },\n        // Stage 2: Visible slowdown (2s)\n        {\n          duration: 2000,\n          easing: 'cubic-bezier(0.25, 0.1, 0.4, 1)',\n          progress: 0.75, // 75% of the way to target\n          tickSpeed: 200, // Slower ticking\n          className: 'slowing-down'\n        },\n        // Stage 3: Final dramatic slowdown (2s)\n        {\n          duration: 2000,\n          easing: 'cubic-bezier(0.05, 0.1, 0.05, 1)',\n          progress: 1.0, // Final position\n          tickSpeed: 400, // Very slow ticking\n          className: 'final-slowdown'\n        }\n      ];\n      \n      const executeStage = (stageIndex) => {\n        if (stageIndex >= stages.length) {\n          // All stages complete\n          clearInterval(tickInterval);\n          soundService.playWinner(); // Play winner sound at the end\n          return;\n        }\n        \n        const stage = stages[stageIndex];\n        const targetForStage = currentPosition.current + ((finalPosition - currentPosition.current) * stage.progress);\n        \n        // Update wheel class for visual feedback\n        wheel.className = `carousel-track ${stage.className}`;\n        \n        // Set transition properties\n        wheel.style.transitionTimingFunction = stage.easing;\n        wheel.style.transitionDuration = `${stage.duration}ms`;\n        wheel.style.transform = `translate3d(${targetForStage}px, 0px, 0px)`;\n        \n        // Update tick sound interval\n        if (tickInterval) clearInterval(tickInterval);\n        tickInterval = setInterval(() => {\n          soundService.playSpin();\n        }, stage.tickSpeed);\n        \n        // Update current position for next stage\n        currentPosition.current = targetForStage;\n        \n        // Schedule next stage\n        setTimeout(() => {\n          executeStage(stageIndex + 1);\n        }, stage.duration);\n      };\n      \n      // Start the dramatic sequence\n      executeStage(0);\n    };\n    \n    performDramaticSpin();\n    \n    // Update current position\n    currentPosition.current = finalPosition;\n    \n    // After slide animation completes (total: 1.5s + 2s + 2s = 5.5s), show winner\n    setTimeout(() => {\n      console.log('Dramatic spin animation completed, showing winner');\n      setWheelState('winner');\n      \n      // Highlight the winner card (find all instances of the winner across all cycles)\n      const allCards = wheel.querySelectorAll('.roulette-card');\n      console.log(`üéØ Highlighting winner at position ${winnerPosition} out of ${effectivePlayers.length} players`);\n      \n      // Highlight all cards that represent the winner (across all 50 cycles)\n      allCards.forEach((card, index) => {\n        const cardPlayerIndex = index % effectivePlayers.length;\n        if (cardPlayerIndex === winnerPosition) {\n          card.classList.add('winner-highlight');\n          console.log(`‚ú® Highlighted card at index ${index} (player ${cardPlayerIndex})`);\n        }\n      });\n      \n      // TEMPORARY DEBUG: Add visual indicators to see positioning\n      console.log(`üîç DEBUG: Checking final card positions after slide:`);\n      const wheelRect = wheel.getBoundingClientRect();\n      const selectorRect = wheel.parentElement.querySelector('.roulette-selector').getBoundingClientRect();\n      console.log(`   - Wheel left: ${wheelRect.left}px`);\n      console.log(`   - Selector left: ${selectorRect.left}px`);\n      console.log(`   - Selector center: ${selectorRect.left + selectorRect.width/2}px`);\n      \n      // Check which card is actually centered\n      allCards.forEach((card, index) => {\n        const cardRect = card.getBoundingClientRect();\n        const cardCenter = cardRect.left + cardRect.width / 2;\n        const distanceFromSelector = Math.abs(cardCenter - (selectorRect.left + selectorRect.width/2));\n        if (distanceFromSelector < 20) { // Within 20px of selector\n          const cardPlayerIndex = index % effectivePlayers.length;\n          console.log(`üéØ Card at selector: index ${index}, player ${cardPlayerIndex}, distance: ${distanceFromSelector}px`);\n        }\n      });\n      \n      // After showcasing winner for 6 seconds, go to finished state\n      winnerShowcaseTimeoutRef.current = setTimeout(() => {\n        console.log('Winner showcase complete, entering finished state');\n        \n        // Remove winner highlights\n        const highlightedCards = wheel.querySelectorAll('.winner-highlight');\n        highlightedCards.forEach(card => {\n          card.classList.remove('winner-highlight');\n        });\n        \n        // Reset transition styles\n        wheel.style.transitionTimingFunction = '';\n        wheel.style.transitionDuration = '';\n        \n        // Clear locked players\n        setLockedPlayers([]);\n        \n        // Go to finished state instead of idle to prevent scrolling\n        setWheelState('finished');\n        onSpinComplete?.(targetWinner);\n      }, 6000); // Show winner for 6 seconds\n      \n    }, 3000); // Wait for slide animation (3 seconds)\n    \n  }, [effectivePlayers.length, CARD_WIDTH, onSpinComplete]);\n\n  // Handle state changes\n  useEffect(() => {\n    if (isSpinning && contractWinner && wheelState === 'waiting') {\n      // Backend responded with winner, start spinning\n      console.log('Starting roulette spin with winner:', contractWinner);\n      spinWheel(contractWinner);\n    } else if (isSpinning && !contractWinner && wheelState === 'idle') {\n      // Bet placed, stop and wait for backend\n      console.log('Stopping wheel, waiting for winner...');\n      setWheelState('waiting');\n      stopIdleMovement();\n    } else if (!isSpinning && wheelState !== 'idle' && wheelState !== 'winner' && wheelState !== 'finished') {\n      // Reset to idle state (but don't interrupt winner showcase or finished state)\n      console.log('Resetting to idle state');\n      setWheelState('idle');\n    }\n  }, [isSpinning, contractWinner, wheelState, spinWheel, stopIdleMovement]);\n\n  // Detect new game start and reset from finished state to idle\n  useEffect(() => {\n    // If we're in finished state and there's no winner (new game starting), reset to idle\n    if (wheelState === 'finished' && !contractWinner && !isSpinning) {\n      console.log('New game detected - resetting from finished to idle');\n      setWheelState('idle');\n    }\n  }, [wheelState, contractWinner, isSpinning]);\n\n  // Start/stop idle movement based on state\n  useEffect(() => {\n    if (wheelState === 'idle') {\n      startIdleMovement();\n    } else {\n      stopIdleMovement();\n    }\n    \n    return () => stopIdleMovement();\n  }, [wheelState, startIdleMovement, stopIdleMovement]);\n\n  // Initialize wheel when effective players change (but not during winner showcase)\n  useEffect(() => {\n    // Don't reinitialize during winner showcase or finished state to preserve highlighting\n    if (wheelState !== 'winner' && wheelState !== 'finished') {\n      initWheel();\n    }\n  }, [initWheel, wheelState]);\n\n  // Cleanup timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (winnerShowcaseTimeoutRef.current) {\n        clearTimeout(winnerShowcaseTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  if (!effectivePlayers || effectivePlayers.length === 0) {\n    return (\n      <div className=\"simple-carousel\">\n        <div className=\"carousel-message\">\n          Waiting for players to join...\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"roulette-wrapper\">\n      {/* Center selector line */}\n      <div className=\"roulette-selector\"></div>\n      \n      {/* Spinning wheel */}\n      <div ref={wheelRef} className=\"roulette-wheel\"></div>\n      \n      {/* State indicator */}\n      <div className=\"wheel-state-indicator\">\n        {wheelState === 'idle' && <span>üé∞</span>}\n        {wheelState === 'waiting' && <span>‚è≥</span>}\n        {wheelState === 'spinning' && <span>üéØ</span>}\n        {wheelState === 'winner' && <span>üéâ</span>}\n        {wheelState === 'finished' && <span>üèÅ</span>}\n      </div>\n      \n      {/* Glare Effect */}\n      <div \n        className=\"absolute -top-1/4 -right-1/3 h-full opacity-75 will-change-transform z-[3] pointer-events-none\"\n        style={{ maskImage: 'linear-gradient(black, transparent 50%)' }}\n      >\n        <img src=\"/img/glare.webp\" className=\"w-full object-cover object-center\" alt=\"\" />\n              </div>\n    </div>\n  );\n};\n\nexport default SimpleCarousel; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}