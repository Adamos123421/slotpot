{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dictionary = void 0;\nconst Address_1 = require(\"../address/Address\");\nconst Builder_1 = require(\"../boc/Builder\");\nconst Cell_1 = require(\"../boc/Cell\");\nconst BitString_1 = require(\"../boc/BitString\");\nconst generateMerkleProof_1 = require(\"./generateMerkleProof\");\nconst generateMerkleUpdate_1 = require(\"./generateMerkleUpdate\");\nconst parseDict_1 = require(\"./parseDict\");\nconst serializeDict_1 = require(\"./serializeDict\");\nconst internalKeySerializer_1 = require(\"./utils/internalKeySerializer\");\nclass Dictionary {\n  /**\n   * Create an empty map\n   * @param key key type\n   * @param value value type\n   * @returns Dictionary<K, V>\n   */\n  static empty(key, value) {\n    if (key && value) {\n      return new Dictionary(new Map(), key, value);\n    } else {\n      return new Dictionary(new Map(), null, null);\n    }\n  }\n  /**\n   * Load dictionary from slice\n   * @param key key description\n   * @param value value description\n   * @param src slice\n   * @returns Dictionary<K, V>\n   */\n  static load(key, value, sc) {\n    let slice;\n    if (sc instanceof Cell_1.Cell) {\n      if (sc.isExotic) {\n        return Dictionary.empty(key, value);\n      }\n      slice = sc.beginParse();\n    } else {\n      slice = sc;\n    }\n    let cell = slice.loadMaybeRef();\n    if (cell && !cell.isExotic) {\n      return Dictionary.loadDirect(key, value, cell.beginParse());\n    } else {\n      return Dictionary.empty(key, value);\n    }\n  }\n  /**\n   * Low level method for rare dictionaries from system contracts.\n   * Loads dictionary from slice directly without going to the ref.\n   *\n   * @param key key description\n   * @param value value description\n   * @param sc slice\n   * @returns Dictionary<K, V>\n   */\n  static loadDirect(key, value, sc) {\n    if (!sc) {\n      return Dictionary.empty(key, value);\n    }\n    let slice;\n    if (sc instanceof Cell_1.Cell) {\n      slice = sc.beginParse();\n    } else {\n      slice = sc;\n    }\n    let values = (0, parseDict_1.parseDict)(slice, key.bits, value.parse);\n    let prepare = new Map();\n    for (let [k, v] of values) {\n      prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k)), v);\n    }\n    return new Dictionary(prepare, key, value);\n  }\n  constructor(values, key, value) {\n    this._key = key;\n    this._value = value;\n    this._map = values;\n  }\n  get size() {\n    return this._map.size;\n  }\n  get(key) {\n    return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));\n  }\n  has(key) {\n    return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));\n  }\n  set(key, value) {\n    this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);\n    return this;\n  }\n  delete(key) {\n    const k = (0, internalKeySerializer_1.serializeInternalKey)(key);\n    return this._map.delete(k);\n  }\n  clear() {\n    this._map.clear();\n  }\n  *[Symbol.iterator]() {\n    for (const [k, v] of this._map) {\n      const key = (0, internalKeySerializer_1.deserializeInternalKey)(k);\n      yield [key, v];\n    }\n  }\n  keys() {\n    return Array.from(this._map.keys()).map(v => (0, internalKeySerializer_1.deserializeInternalKey)(v));\n  }\n  values() {\n    return Array.from(this._map.values());\n  }\n  store(builder, key, value) {\n    if (this._map.size === 0) {\n      builder.storeBit(0);\n    } else {\n      // Resolve serializer\n      let resolvedKey = this._key;\n      if (key !== null && key !== undefined) {\n        resolvedKey = key;\n      }\n      let resolvedValue = this._value;\n      if (value !== null && value !== undefined) {\n        resolvedValue = value;\n      }\n      if (!resolvedKey) {\n        throw Error('Key serializer is not defined');\n      }\n      if (!resolvedValue) {\n        throw Error('Value serializer is not defined');\n      }\n      // Prepare map\n      let prepared = new Map();\n      for (const [k, v] of this._map) {\n        prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);\n      }\n      // Store\n      builder.storeBit(1);\n      let dd = (0, Builder_1.beginCell)();\n      (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);\n      builder.storeRef(dd.endCell());\n    }\n  }\n  storeDirect(builder, key, value) {\n    if (this._map.size === 0) {\n      throw Error('Cannot store empty dictionary directly');\n    }\n    // Resolve serializer\n    let resolvedKey = this._key;\n    if (key !== null && key !== undefined) {\n      resolvedKey = key;\n    }\n    let resolvedValue = this._value;\n    if (value !== null && value !== undefined) {\n      resolvedValue = value;\n    }\n    if (!resolvedKey) {\n      throw Error('Key serializer is not defined');\n    }\n    if (!resolvedValue) {\n      throw Error('Value serializer is not defined');\n    }\n    // Prepare map\n    let prepared = new Map();\n    for (const [k, v] of this._map) {\n      prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);\n    }\n    // Store\n    (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder);\n  }\n  generateMerkleProof(key) {\n    return (0, generateMerkleProof_1.generateMerkleProof)(this, key, this._key);\n  }\n  generateMerkleUpdate(key, newValue) {\n    return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key, this._key, newValue);\n  }\n}\nexports.Dictionary = Dictionary;\nDictionary.Keys = {\n  /**\n   * Standard address key\n   * @returns DictionaryKey<Address>\n   */\n  Address: () => {\n    return createAddressKey();\n  },\n  /**\n   * Create standard big integer key\n   * @param bits number of bits\n   * @returns DictionaryKey<bigint>\n   */\n  BigInt: bits => {\n    return createBigIntKey(bits);\n  },\n  /**\n   * Create integer key\n   * @param bits bits of integer\n   * @returns DictionaryKey<number>\n   */\n  Int: bits => {\n    return createIntKey(bits);\n  },\n  /**\n   * Create standard unsigned big integer key\n   * @param bits number of bits\n   * @returns DictionaryKey<bigint>\n   */\n  BigUint: bits => {\n    return createBigUintKey(bits);\n  },\n  /**\n   * Create standard unsigned integer key\n   * @param bits number of bits\n   * @returns DictionaryKey<number>\n   */\n  Uint: bits => {\n    return createUintKey(bits);\n  },\n  /**\n   * Create standard buffer key\n   * @param bytes number of bytes of a buffer\n   * @returns DictionaryKey<Buffer>\n   */\n  Buffer: bytes => {\n    return createBufferKey(bytes);\n  },\n  /**\n   * Create BitString key\n   * @param bits key length\n   * @returns DictionaryKey<BitString>\n   * Point is that Buffer has to be 8 bit aligned,\n   * while key is TVM dictionary doesn't have to be\n   * aligned at all.\n   */\n  BitString: bits => {\n    return createBitStringKey(bits);\n  }\n};\nDictionary.Values = {\n  /**\n   * Create standard integer value\n   * @returns DictionaryValue<bigint>\n   */\n  BigInt: bits => {\n    return createBigIntValue(bits);\n  },\n  /**\n   * Create standard integer value\n   * @returns DictionaryValue<number>\n   */\n  Int: bits => {\n    return createIntValue(bits);\n  },\n  /**\n   * Create big var int\n   * @param bits nubmer of header bits\n   * @returns DictionaryValue<bigint>\n   */\n  BigVarInt: bits => {\n    return createBigVarIntValue(bits);\n  },\n  /**\n   * Create standard unsigned integer value\n   * @param bits number of bits\n   * @returns DictionaryValue<bigint>\n   */\n  BigUint: bits => {\n    return createBigUintValue(bits);\n  },\n  /**\n   * Create standard unsigned integer value\n   * @param bits number of bits\n   * @returns DictionaryValue<bigint>\n   */\n  Uint: bits => {\n    return createUintValue(bits);\n  },\n  /**\n   * Create big var int\n   * @param bits nubmer of header bits\n   * @returns DictionaryValue<bigint>\n   */\n  BigVarUint: bits => {\n    return createBigVarUintValue(bits);\n  },\n  /**\n   * Create standard boolean value\n   * @returns DictionaryValue<boolean>\n   */\n  Bool: () => {\n    return createBooleanValue();\n  },\n  /**\n   * Create standard address value\n   * @returns DictionaryValue<Address>\n   */\n  Address: () => {\n    return createAddressValue();\n  },\n  /**\n   * Create standard cell value\n   * @returns DictionaryValue<Cell>\n   */\n  Cell: () => {\n    return createCellValue();\n  },\n  /**\n   * Create Builder value\n   * @param bytes number of bytes of a buffer\n   * @returns DictionaryValue<Builder>\n   */\n  Buffer: bytes => {\n    return createBufferValue(bytes);\n  },\n  /**\n   * Create BitString value\n   * @param requested bit length\n   * @returns DictionaryValue<BitString>\n   * Point is that Buffer is not applicable\n   * when length is not 8 bit alligned.\n   */\n  BitString: bits => {\n    return createBitStringValue(bits);\n  },\n  /**\n   * Create dictionary value\n   * @param key\n   * @param value\n   */\n  Dictionary: (key, value) => {\n    return createDictionaryValue(key, value);\n  }\n};\n//\n// Keys and Values\n//\nfunction createAddressKey() {\n  return {\n    bits: 267,\n    serialize: src => {\n      if (!Address_1.Address.isAddress(src)) {\n        throw Error('Key is not an address');\n      }\n      return (0, Builder_1.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);\n    },\n    parse: src => {\n      return (0, Builder_1.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();\n    }\n  };\n}\nfunction createBigIntKey(bits) {\n  return {\n    bits,\n    serialize: src => {\n      if (typeof src !== 'bigint') {\n        throw Error('Key is not a bigint');\n      }\n      return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);\n    },\n    parse: src => {\n      return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);\n    }\n  };\n}\nfunction createIntKey(bits) {\n  return {\n    bits: bits,\n    serialize: src => {\n      if (typeof src !== 'number') {\n        throw Error('Key is not a number');\n      }\n      if (!Number.isSafeInteger(src)) {\n        throw Error('Key is not a safe integer: ' + src);\n      }\n      return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);\n    },\n    parse: src => {\n      return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);\n    }\n  };\n}\nfunction createBigUintKey(bits) {\n  return {\n    bits,\n    serialize: src => {\n      if (typeof src !== 'bigint') {\n        throw Error('Key is not a bigint');\n      }\n      if (src < 0) {\n        throw Error('Key is negative: ' + src);\n      }\n      return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);\n    },\n    parse: src => {\n      return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);\n    }\n  };\n}\nfunction createUintKey(bits) {\n  return {\n    bits,\n    serialize: src => {\n      if (typeof src !== 'number') {\n        throw Error('Key is not a number');\n      }\n      if (!Number.isSafeInteger(src)) {\n        throw Error('Key is not a safe integer: ' + src);\n      }\n      if (src < 0) {\n        throw Error('Key is negative: ' + src);\n      }\n      return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);\n    },\n    parse: src => {\n      return Number((0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));\n    }\n  };\n}\nfunction createBufferKey(bytes) {\n  return {\n    bits: bytes * 8,\n    serialize: src => {\n      if (!Buffer.isBuffer(src)) {\n        throw Error('Key is not a buffer');\n      }\n      return (0, Builder_1.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);\n    },\n    parse: src => {\n      return (0, Builder_1.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);\n    }\n  };\n}\nfunction createBitStringKey(bits) {\n  return {\n    bits,\n    serialize: src => {\n      if (!BitString_1.BitString.isBitString(src)) throw Error('Key is not a BitString');\n      return (0, Builder_1.beginCell)().storeBits(src).endCell().beginParse().loadUintBig(bits);\n    },\n    parse: src => {\n      return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadBits(bits);\n    }\n  };\n}\nfunction createIntValue(bits) {\n  return {\n    serialize: (src, buidler) => {\n      buidler.storeInt(src, bits);\n    },\n    parse: src => {\n      return src.loadInt(bits);\n    }\n  };\n}\nfunction createBigIntValue(bits) {\n  return {\n    serialize: (src, buidler) => {\n      buidler.storeInt(src, bits);\n    },\n    parse: src => {\n      return src.loadIntBig(bits);\n    }\n  };\n}\nfunction createBigVarIntValue(bits) {\n  return {\n    serialize: (src, buidler) => {\n      buidler.storeVarInt(src, bits);\n    },\n    parse: src => {\n      return src.loadVarIntBig(bits);\n    }\n  };\n}\nfunction createBigVarUintValue(bits) {\n  return {\n    serialize: (src, buidler) => {\n      buidler.storeVarUint(src, bits);\n    },\n    parse: src => {\n      return src.loadVarUintBig(bits);\n    }\n  };\n}\nfunction createUintValue(bits) {\n  return {\n    serialize: (src, buidler) => {\n      buidler.storeUint(src, bits);\n    },\n    parse: src => {\n      return src.loadUint(bits);\n    }\n  };\n}\nfunction createBigUintValue(bits) {\n  return {\n    serialize: (src, buidler) => {\n      buidler.storeUint(src, bits);\n    },\n    parse: src => {\n      return src.loadUintBig(bits);\n    }\n  };\n}\nfunction createBooleanValue() {\n  return {\n    serialize: (src, buidler) => {\n      buidler.storeBit(src);\n    },\n    parse: src => {\n      return src.loadBit();\n    }\n  };\n}\nfunction createAddressValue() {\n  return {\n    serialize: (src, buidler) => {\n      buidler.storeAddress(src);\n    },\n    parse: src => {\n      return src.loadAddress();\n    }\n  };\n}\nfunction createCellValue() {\n  return {\n    serialize: (src, buidler) => {\n      buidler.storeRef(src);\n    },\n    parse: src => {\n      return src.loadRef();\n    }\n  };\n}\nfunction createDictionaryValue(key, value) {\n  return {\n    serialize: (src, buidler) => {\n      src.store(buidler);\n    },\n    parse: src => {\n      return Dictionary.load(key, value, src);\n    }\n  };\n}\nfunction createBufferValue(size) {\n  return {\n    serialize: (src, buidler) => {\n      if (src.length !== size) {\n        throw Error('Invalid buffer size');\n      }\n      buidler.storeBuffer(src);\n    },\n    parse: src => {\n      return src.loadBuffer(size);\n    }\n  };\n}\nfunction createBitStringValue(bits) {\n  return {\n    serialize: (src, builder) => {\n      if (src.length !== bits) {\n        throw Error('Invalid BitString size');\n      }\n      builder.storeBits(src);\n    },\n    parse: src => {\n      return src.loadBits(bits);\n    }\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Dictionary","Address_1","require","Builder_1","Cell_1","BitString_1","generateMerkleProof_1","generateMerkleUpdate_1","parseDict_1","serializeDict_1","internalKeySerializer_1","empty","key","Map","load","sc","slice","Cell","isExotic","beginParse","cell","loadMaybeRef","loadDirect","values","parseDict","bits","parse","prepare","k","v","set","serializeInternalKey","constructor","_key","_value","_map","size","get","has","delete","clear","Symbol","iterator","deserializeInternalKey","keys","Array","from","map","store","builder","storeBit","resolvedKey","undefined","resolvedValue","Error","prepared","serialize","dd","beginCell","serializeDict","storeRef","endCell","storeDirect","generateMerkleProof","generateMerkleUpdate","newValue","Keys","Address","createAddressKey","BigInt","createBigIntKey","Int","createIntKey","BigUint","createBigUintKey","Uint","createUintKey","Buffer","bytes","createBufferKey","BitString","createBitStringKey","Values","createBigIntValue","createIntValue","BigVarInt","createBigVarIntValue","createBigUintValue","createUintValue","BigVarUint","createBigVarUintValue","Bool","createBooleanValue","createAddressValue","createCellValue","createBufferValue","createBitStringValue","createDictionaryValue","src","isAddress","storeAddress","preloadUintBig","storeUint","loadAddress","storeInt","loadUintBig","loadIntBig","Number","isSafeInteger","loadInt","loadUint","isBuffer","storeBuffer","loadBuffer","isBitString","storeBits","loadBits","buidler","storeVarInt","loadVarIntBig","storeVarUint","loadVarUintBig","loadBit","loadRef","length"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/dict/Dictionary.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Dictionary = void 0;\nconst Address_1 = require(\"../address/Address\");\nconst Builder_1 = require(\"../boc/Builder\");\nconst Cell_1 = require(\"../boc/Cell\");\nconst BitString_1 = require(\"../boc/BitString\");\nconst generateMerkleProof_1 = require(\"./generateMerkleProof\");\nconst generateMerkleUpdate_1 = require(\"./generateMerkleUpdate\");\nconst parseDict_1 = require(\"./parseDict\");\nconst serializeDict_1 = require(\"./serializeDict\");\nconst internalKeySerializer_1 = require(\"./utils/internalKeySerializer\");\nclass Dictionary {\n    /**\n     * Create an empty map\n     * @param key key type\n     * @param value value type\n     * @returns Dictionary<K, V>\n     */\n    static empty(key, value) {\n        if (key && value) {\n            return new Dictionary(new Map(), key, value);\n        }\n        else {\n            return new Dictionary(new Map(), null, null);\n        }\n    }\n    /**\n     * Load dictionary from slice\n     * @param key key description\n     * @param value value description\n     * @param src slice\n     * @returns Dictionary<K, V>\n     */\n    static load(key, value, sc) {\n        let slice;\n        if (sc instanceof Cell_1.Cell) {\n            if (sc.isExotic) {\n                return Dictionary.empty(key, value);\n            }\n            slice = sc.beginParse();\n        }\n        else {\n            slice = sc;\n        }\n        let cell = slice.loadMaybeRef();\n        if (cell && !cell.isExotic) {\n            return Dictionary.loadDirect(key, value, cell.beginParse());\n        }\n        else {\n            return Dictionary.empty(key, value);\n        }\n    }\n    /**\n     * Low level method for rare dictionaries from system contracts.\n     * Loads dictionary from slice directly without going to the ref.\n     *\n     * @param key key description\n     * @param value value description\n     * @param sc slice\n     * @returns Dictionary<K, V>\n     */\n    static loadDirect(key, value, sc) {\n        if (!sc) {\n            return Dictionary.empty(key, value);\n        }\n        let slice;\n        if (sc instanceof Cell_1.Cell) {\n            slice = sc.beginParse();\n        }\n        else {\n            slice = sc;\n        }\n        let values = (0, parseDict_1.parseDict)(slice, key.bits, value.parse);\n        let prepare = new Map();\n        for (let [k, v] of values) {\n            prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k)), v);\n        }\n        return new Dictionary(prepare, key, value);\n    }\n    constructor(values, key, value) {\n        this._key = key;\n        this._value = value;\n        this._map = values;\n    }\n    get size() {\n        return this._map.size;\n    }\n    get(key) {\n        return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));\n    }\n    has(key) {\n        return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));\n    }\n    set(key, value) {\n        this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);\n        return this;\n    }\n    delete(key) {\n        const k = (0, internalKeySerializer_1.serializeInternalKey)(key);\n        return this._map.delete(k);\n    }\n    clear() {\n        this._map.clear();\n    }\n    *[Symbol.iterator]() {\n        for (const [k, v] of this._map) {\n            const key = (0, internalKeySerializer_1.deserializeInternalKey)(k);\n            yield [key, v];\n        }\n    }\n    keys() {\n        return Array.from(this._map.keys()).map((v) => (0, internalKeySerializer_1.deserializeInternalKey)(v));\n    }\n    values() {\n        return Array.from(this._map.values());\n    }\n    store(builder, key, value) {\n        if (this._map.size === 0) {\n            builder.storeBit(0);\n        }\n        else {\n            // Resolve serializer\n            let resolvedKey = this._key;\n            if (key !== null && key !== undefined) {\n                resolvedKey = key;\n            }\n            let resolvedValue = this._value;\n            if (value !== null && value !== undefined) {\n                resolvedValue = value;\n            }\n            if (!resolvedKey) {\n                throw Error('Key serializer is not defined');\n            }\n            if (!resolvedValue) {\n                throw Error('Value serializer is not defined');\n            }\n            // Prepare map\n            let prepared = new Map();\n            for (const [k, v] of this._map) {\n                prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);\n            }\n            // Store\n            builder.storeBit(1);\n            let dd = (0, Builder_1.beginCell)();\n            (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);\n            builder.storeRef(dd.endCell());\n        }\n    }\n    storeDirect(builder, key, value) {\n        if (this._map.size === 0) {\n            throw Error('Cannot store empty dictionary directly');\n        }\n        // Resolve serializer\n        let resolvedKey = this._key;\n        if (key !== null && key !== undefined) {\n            resolvedKey = key;\n        }\n        let resolvedValue = this._value;\n        if (value !== null && value !== undefined) {\n            resolvedValue = value;\n        }\n        if (!resolvedKey) {\n            throw Error('Key serializer is not defined');\n        }\n        if (!resolvedValue) {\n            throw Error('Value serializer is not defined');\n        }\n        // Prepare map\n        let prepared = new Map();\n        for (const [k, v] of this._map) {\n            prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);\n        }\n        // Store\n        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder);\n    }\n    generateMerkleProof(key) {\n        return (0, generateMerkleProof_1.generateMerkleProof)(this, key, this._key);\n    }\n    generateMerkleUpdate(key, newValue) {\n        return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key, this._key, newValue);\n    }\n}\nexports.Dictionary = Dictionary;\nDictionary.Keys = {\n    /**\n     * Standard address key\n     * @returns DictionaryKey<Address>\n     */\n    Address: () => {\n        return createAddressKey();\n    },\n    /**\n     * Create standard big integer key\n     * @param bits number of bits\n     * @returns DictionaryKey<bigint>\n     */\n    BigInt: (bits) => {\n        return createBigIntKey(bits);\n    },\n    /**\n     * Create integer key\n     * @param bits bits of integer\n     * @returns DictionaryKey<number>\n     */\n    Int: (bits) => {\n        return createIntKey(bits);\n    },\n    /**\n     * Create standard unsigned big integer key\n     * @param bits number of bits\n     * @returns DictionaryKey<bigint>\n     */\n    BigUint: (bits) => {\n        return createBigUintKey(bits);\n    },\n    /**\n     * Create standard unsigned integer key\n     * @param bits number of bits\n     * @returns DictionaryKey<number>\n     */\n    Uint: (bits) => {\n        return createUintKey(bits);\n    },\n    /**\n     * Create standard buffer key\n     * @param bytes number of bytes of a buffer\n     * @returns DictionaryKey<Buffer>\n     */\n    Buffer: (bytes) => {\n        return createBufferKey(bytes);\n    },\n    /**\n     * Create BitString key\n     * @param bits key length\n     * @returns DictionaryKey<BitString>\n     * Point is that Buffer has to be 8 bit aligned,\n     * while key is TVM dictionary doesn't have to be\n     * aligned at all.\n     */\n    BitString: (bits) => {\n        return createBitStringKey(bits);\n    }\n};\nDictionary.Values = {\n    /**\n     * Create standard integer value\n     * @returns DictionaryValue<bigint>\n     */\n    BigInt: (bits) => {\n        return createBigIntValue(bits);\n    },\n    /**\n     * Create standard integer value\n     * @returns DictionaryValue<number>\n     */\n    Int: (bits) => {\n        return createIntValue(bits);\n    },\n    /**\n     * Create big var int\n     * @param bits nubmer of header bits\n     * @returns DictionaryValue<bigint>\n     */\n    BigVarInt: (bits) => {\n        return createBigVarIntValue(bits);\n    },\n    /**\n     * Create standard unsigned integer value\n     * @param bits number of bits\n     * @returns DictionaryValue<bigint>\n     */\n    BigUint: (bits) => {\n        return createBigUintValue(bits);\n    },\n    /**\n     * Create standard unsigned integer value\n     * @param bits number of bits\n     * @returns DictionaryValue<bigint>\n     */\n    Uint: (bits) => {\n        return createUintValue(bits);\n    },\n    /**\n     * Create big var int\n     * @param bits nubmer of header bits\n     * @returns DictionaryValue<bigint>\n     */\n    BigVarUint: (bits) => {\n        return createBigVarUintValue(bits);\n    },\n    /**\n     * Create standard boolean value\n     * @returns DictionaryValue<boolean>\n     */\n    Bool: () => {\n        return createBooleanValue();\n    },\n    /**\n     * Create standard address value\n     * @returns DictionaryValue<Address>\n     */\n    Address: () => {\n        return createAddressValue();\n    },\n    /**\n     * Create standard cell value\n     * @returns DictionaryValue<Cell>\n     */\n    Cell: () => {\n        return createCellValue();\n    },\n    /**\n     * Create Builder value\n     * @param bytes number of bytes of a buffer\n     * @returns DictionaryValue<Builder>\n     */\n    Buffer: (bytes) => {\n        return createBufferValue(bytes);\n    },\n    /**\n     * Create BitString value\n     * @param requested bit length\n     * @returns DictionaryValue<BitString>\n     * Point is that Buffer is not applicable\n     * when length is not 8 bit alligned.\n     */\n    BitString: (bits) => {\n        return createBitStringValue(bits);\n    },\n    /**\n     * Create dictionary value\n     * @param key\n     * @param value\n     */\n    Dictionary: (key, value) => {\n        return createDictionaryValue(key, value);\n    }\n};\n//\n// Keys and Values\n//\nfunction createAddressKey() {\n    return {\n        bits: 267,\n        serialize: (src) => {\n            if (!Address_1.Address.isAddress(src)) {\n                throw Error('Key is not an address');\n            }\n            return (0, Builder_1.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);\n        },\n        parse: (src) => {\n            return (0, Builder_1.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();\n        }\n    };\n}\nfunction createBigIntKey(bits) {\n    return {\n        bits,\n        serialize: (src) => {\n            if (typeof src !== 'bigint') {\n                throw Error('Key is not a bigint');\n            }\n            return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);\n        },\n        parse: (src) => {\n            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);\n        }\n    };\n}\nfunction createIntKey(bits) {\n    return {\n        bits: bits,\n        serialize: (src) => {\n            if (typeof src !== 'number') {\n                throw Error('Key is not a number');\n            }\n            if (!Number.isSafeInteger(src)) {\n                throw Error('Key is not a safe integer: ' + src);\n            }\n            return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);\n        },\n        parse: (src) => {\n            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);\n        }\n    };\n}\nfunction createBigUintKey(bits) {\n    return {\n        bits,\n        serialize: (src) => {\n            if (typeof src !== 'bigint') {\n                throw Error('Key is not a bigint');\n            }\n            if (src < 0) {\n                throw Error('Key is negative: ' + src);\n            }\n            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);\n        },\n        parse: (src) => {\n            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);\n        }\n    };\n}\nfunction createUintKey(bits) {\n    return {\n        bits,\n        serialize: (src) => {\n            if (typeof src !== 'number') {\n                throw Error('Key is not a number');\n            }\n            if (!Number.isSafeInteger(src)) {\n                throw Error('Key is not a safe integer: ' + src);\n            }\n            if (src < 0) {\n                throw Error('Key is negative: ' + src);\n            }\n            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);\n        },\n        parse: (src) => {\n            return Number((0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));\n        }\n    };\n}\nfunction createBufferKey(bytes) {\n    return {\n        bits: bytes * 8,\n        serialize: (src) => {\n            if (!Buffer.isBuffer(src)) {\n                throw Error('Key is not a buffer');\n            }\n            return (0, Builder_1.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);\n        },\n        parse: (src) => {\n            return (0, Builder_1.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);\n        }\n    };\n}\nfunction createBitStringKey(bits) {\n    return {\n        bits,\n        serialize: (src) => {\n            if (!BitString_1.BitString.isBitString(src))\n                throw Error('Key is not a BitString');\n            return (0, Builder_1.beginCell)().storeBits(src).endCell().beginParse().loadUintBig(bits);\n        },\n        parse: (src) => {\n            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadBits(bits);\n        }\n    };\n}\nfunction createIntValue(bits) {\n    return {\n        serialize: (src, buidler) => {\n            buidler.storeInt(src, bits);\n        },\n        parse: (src) => {\n            return src.loadInt(bits);\n        }\n    };\n}\nfunction createBigIntValue(bits) {\n    return {\n        serialize: (src, buidler) => {\n            buidler.storeInt(src, bits);\n        },\n        parse: (src) => {\n            return src.loadIntBig(bits);\n        }\n    };\n}\nfunction createBigVarIntValue(bits) {\n    return {\n        serialize: (src, buidler) => {\n            buidler.storeVarInt(src, bits);\n        },\n        parse: (src) => {\n            return src.loadVarIntBig(bits);\n        }\n    };\n}\nfunction createBigVarUintValue(bits) {\n    return {\n        serialize: (src, buidler) => {\n            buidler.storeVarUint(src, bits);\n        },\n        parse: (src) => {\n            return src.loadVarUintBig(bits);\n        }\n    };\n}\nfunction createUintValue(bits) {\n    return {\n        serialize: (src, buidler) => {\n            buidler.storeUint(src, bits);\n        },\n        parse: (src) => {\n            return src.loadUint(bits);\n        }\n    };\n}\nfunction createBigUintValue(bits) {\n    return {\n        serialize: (src, buidler) => {\n            buidler.storeUint(src, bits);\n        },\n        parse: (src) => {\n            return src.loadUintBig(bits);\n        }\n    };\n}\nfunction createBooleanValue() {\n    return {\n        serialize: (src, buidler) => {\n            buidler.storeBit(src);\n        },\n        parse: (src) => {\n            return src.loadBit();\n        }\n    };\n}\nfunction createAddressValue() {\n    return {\n        serialize: (src, buidler) => {\n            buidler.storeAddress(src);\n        },\n        parse: (src) => {\n            return src.loadAddress();\n        }\n    };\n}\nfunction createCellValue() {\n    return {\n        serialize: (src, buidler) => {\n            buidler.storeRef(src);\n        },\n        parse: (src) => {\n            return src.loadRef();\n        }\n    };\n}\nfunction createDictionaryValue(key, value) {\n    return {\n        serialize: (src, buidler) => {\n            src.store(buidler);\n        },\n        parse: (src) => {\n            return Dictionary.load(key, value, src);\n        }\n    };\n}\nfunction createBufferValue(size) {\n    return {\n        serialize: (src, buidler) => {\n            if (src.length !== size) {\n                throw Error('Invalid buffer size');\n            }\n            buidler.storeBuffer(src);\n        },\n        parse: (src) => {\n            return src.loadBuffer(size);\n        }\n    };\n}\nfunction createBitStringValue(bits) {\n    return {\n        serialize: (src, builder) => {\n            if (src.length !== bits) {\n                throw Error('Invalid BitString size');\n            }\n            builder.storeBits(src);\n        },\n        parse: (src) => {\n            return src.loadBits(bits);\n        }\n    };\n}\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,UAAU,GAAG,KAAK,CAAC;AAC3B,MAAMC,SAAS,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC/C,MAAMC,SAAS,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC3C,MAAME,MAAM,GAAGF,OAAO,CAAC,aAAa,CAAC;AACrC,MAAMG,WAAW,GAAGH,OAAO,CAAC,kBAAkB,CAAC;AAC/C,MAAMI,qBAAqB,GAAGJ,OAAO,CAAC,uBAAuB,CAAC;AAC9D,MAAMK,sBAAsB,GAAGL,OAAO,CAAC,wBAAwB,CAAC;AAChE,MAAMM,WAAW,GAAGN,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMO,eAAe,GAAGP,OAAO,CAAC,iBAAiB,CAAC;AAClD,MAAMQ,uBAAuB,GAAGR,OAAO,CAAC,+BAA+B,CAAC;AACxE,MAAMF,UAAU,CAAC;EACb;AACJ;AACA;AACA;AACA;AACA;EACI,OAAOW,KAAKA,CAACC,GAAG,EAAEb,KAAK,EAAE;IACrB,IAAIa,GAAG,IAAIb,KAAK,EAAE;MACd,OAAO,IAAIC,UAAU,CAAC,IAAIa,GAAG,CAAC,CAAC,EAAED,GAAG,EAAEb,KAAK,CAAC;IAChD,CAAC,MACI;MACD,OAAO,IAAIC,UAAU,CAAC,IAAIa,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;IAChD;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,IAAIA,CAACF,GAAG,EAAEb,KAAK,EAAEgB,EAAE,EAAE;IACxB,IAAIC,KAAK;IACT,IAAID,EAAE,YAAYX,MAAM,CAACa,IAAI,EAAE;MAC3B,IAAIF,EAAE,CAACG,QAAQ,EAAE;QACb,OAAOlB,UAAU,CAACW,KAAK,CAACC,GAAG,EAAEb,KAAK,CAAC;MACvC;MACAiB,KAAK,GAAGD,EAAE,CAACI,UAAU,CAAC,CAAC;IAC3B,CAAC,MACI;MACDH,KAAK,GAAGD,EAAE;IACd;IACA,IAAIK,IAAI,GAAGJ,KAAK,CAACK,YAAY,CAAC,CAAC;IAC/B,IAAID,IAAI,IAAI,CAACA,IAAI,CAACF,QAAQ,EAAE;MACxB,OAAOlB,UAAU,CAACsB,UAAU,CAACV,GAAG,EAAEb,KAAK,EAAEqB,IAAI,CAACD,UAAU,CAAC,CAAC,CAAC;IAC/D,CAAC,MACI;MACD,OAAOnB,UAAU,CAACW,KAAK,CAACC,GAAG,EAAEb,KAAK,CAAC;IACvC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOuB,UAAUA,CAACV,GAAG,EAAEb,KAAK,EAAEgB,EAAE,EAAE;IAC9B,IAAI,CAACA,EAAE,EAAE;MACL,OAAOf,UAAU,CAACW,KAAK,CAACC,GAAG,EAAEb,KAAK,CAAC;IACvC;IACA,IAAIiB,KAAK;IACT,IAAID,EAAE,YAAYX,MAAM,CAACa,IAAI,EAAE;MAC3BD,KAAK,GAAGD,EAAE,CAACI,UAAU,CAAC,CAAC;IAC3B,CAAC,MACI;MACDH,KAAK,GAAGD,EAAE;IACd;IACA,IAAIQ,MAAM,GAAG,CAAC,CAAC,EAAEf,WAAW,CAACgB,SAAS,EAAER,KAAK,EAAEJ,GAAG,CAACa,IAAI,EAAE1B,KAAK,CAAC2B,KAAK,CAAC;IACrE,IAAIC,OAAO,GAAG,IAAId,GAAG,CAAC,CAAC;IACvB,KAAK,IAAI,CAACe,CAAC,EAAEC,CAAC,CAAC,IAAIN,MAAM,EAAE;MACvBI,OAAO,CAACG,GAAG,CAAC,CAAC,CAAC,EAAEpB,uBAAuB,CAACqB,oBAAoB,EAAEnB,GAAG,CAACc,KAAK,CAACE,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC;IACnF;IACA,OAAO,IAAI7B,UAAU,CAAC2B,OAAO,EAAEf,GAAG,EAAEb,KAAK,CAAC;EAC9C;EACAiC,WAAWA,CAACT,MAAM,EAAEX,GAAG,EAAEb,KAAK,EAAE;IAC5B,IAAI,CAACkC,IAAI,GAAGrB,GAAG;IACf,IAAI,CAACsB,MAAM,GAAGnC,KAAK;IACnB,IAAI,CAACoC,IAAI,GAAGZ,MAAM;EACtB;EACA,IAAIa,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACD,IAAI,CAACC,IAAI;EACzB;EACAC,GAAGA,CAACzB,GAAG,EAAE;IACL,OAAO,IAAI,CAACuB,IAAI,CAACE,GAAG,CAAC,CAAC,CAAC,EAAE3B,uBAAuB,CAACqB,oBAAoB,EAAEnB,GAAG,CAAC,CAAC;EAChF;EACA0B,GAAGA,CAAC1B,GAAG,EAAE;IACL,OAAO,IAAI,CAACuB,IAAI,CAACG,GAAG,CAAC,CAAC,CAAC,EAAE5B,uBAAuB,CAACqB,oBAAoB,EAAEnB,GAAG,CAAC,CAAC;EAChF;EACAkB,GAAGA,CAAClB,GAAG,EAAEb,KAAK,EAAE;IACZ,IAAI,CAACoC,IAAI,CAACL,GAAG,CAAC,CAAC,CAAC,EAAEpB,uBAAuB,CAACqB,oBAAoB,EAAEnB,GAAG,CAAC,EAAEb,KAAK,CAAC;IAC5E,OAAO,IAAI;EACf;EACAwC,MAAMA,CAAC3B,GAAG,EAAE;IACR,MAAMgB,CAAC,GAAG,CAAC,CAAC,EAAElB,uBAAuB,CAACqB,oBAAoB,EAAEnB,GAAG,CAAC;IAChE,OAAO,IAAI,CAACuB,IAAI,CAACI,MAAM,CAACX,CAAC,CAAC;EAC9B;EACAY,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACL,IAAI,CAACK,KAAK,CAAC,CAAC;EACrB;EACA,EAAEC,MAAM,CAACC,QAAQ,IAAI;IACjB,KAAK,MAAM,CAACd,CAAC,EAAEC,CAAC,CAAC,IAAI,IAAI,CAACM,IAAI,EAAE;MAC5B,MAAMvB,GAAG,GAAG,CAAC,CAAC,EAAEF,uBAAuB,CAACiC,sBAAsB,EAAEf,CAAC,CAAC;MAClE,MAAM,CAAChB,GAAG,EAAEiB,CAAC,CAAC;IAClB;EACJ;EACAe,IAAIA,CAAA,EAAG;IACH,OAAOC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACX,IAAI,CAACS,IAAI,CAAC,CAAC,CAAC,CAACG,GAAG,CAAElB,CAAC,IAAK,CAAC,CAAC,EAAEnB,uBAAuB,CAACiC,sBAAsB,EAAEd,CAAC,CAAC,CAAC;EAC1G;EACAN,MAAMA,CAAA,EAAG;IACL,OAAOsB,KAAK,CAACC,IAAI,CAAC,IAAI,CAACX,IAAI,CAACZ,MAAM,CAAC,CAAC,CAAC;EACzC;EACAyB,KAAKA,CAACC,OAAO,EAAErC,GAAG,EAAEb,KAAK,EAAE;IACvB,IAAI,IAAI,CAACoC,IAAI,CAACC,IAAI,KAAK,CAAC,EAAE;MACtBa,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC;IACvB,CAAC,MACI;MACD;MACA,IAAIC,WAAW,GAAG,IAAI,CAAClB,IAAI;MAC3B,IAAIrB,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAKwC,SAAS,EAAE;QACnCD,WAAW,GAAGvC,GAAG;MACrB;MACA,IAAIyC,aAAa,GAAG,IAAI,CAACnB,MAAM;MAC/B,IAAInC,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKqD,SAAS,EAAE;QACvCC,aAAa,GAAGtD,KAAK;MACzB;MACA,IAAI,CAACoD,WAAW,EAAE;QACd,MAAMG,KAAK,CAAC,+BAA+B,CAAC;MAChD;MACA,IAAI,CAACD,aAAa,EAAE;QAChB,MAAMC,KAAK,CAAC,iCAAiC,CAAC;MAClD;MACA;MACA,IAAIC,QAAQ,GAAG,IAAI1C,GAAG,CAAC,CAAC;MACxB,KAAK,MAAM,CAACe,CAAC,EAAEC,CAAC,CAAC,IAAI,IAAI,CAACM,IAAI,EAAE;QAC5BoB,QAAQ,CAACzB,GAAG,CAACqB,WAAW,CAACK,SAAS,CAAC,CAAC,CAAC,EAAE9C,uBAAuB,CAACiC,sBAAsB,EAAEf,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC;MAClG;MACA;MACAoB,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC;MACnB,IAAIO,EAAE,GAAG,CAAC,CAAC,EAAEtD,SAAS,CAACuD,SAAS,EAAE,CAAC;MACnC,CAAC,CAAC,EAAEjD,eAAe,CAACkD,aAAa,EAAEJ,QAAQ,EAAEJ,WAAW,CAAC1B,IAAI,EAAE4B,aAAa,CAACG,SAAS,EAAEC,EAAE,CAAC;MAC3FR,OAAO,CAACW,QAAQ,CAACH,EAAE,CAACI,OAAO,CAAC,CAAC,CAAC;IAClC;EACJ;EACAC,WAAWA,CAACb,OAAO,EAAErC,GAAG,EAAEb,KAAK,EAAE;IAC7B,IAAI,IAAI,CAACoC,IAAI,CAACC,IAAI,KAAK,CAAC,EAAE;MACtB,MAAMkB,KAAK,CAAC,wCAAwC,CAAC;IACzD;IACA;IACA,IAAIH,WAAW,GAAG,IAAI,CAAClB,IAAI;IAC3B,IAAIrB,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAKwC,SAAS,EAAE;MACnCD,WAAW,GAAGvC,GAAG;IACrB;IACA,IAAIyC,aAAa,GAAG,IAAI,CAACnB,MAAM;IAC/B,IAAInC,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKqD,SAAS,EAAE;MACvCC,aAAa,GAAGtD,KAAK;IACzB;IACA,IAAI,CAACoD,WAAW,EAAE;MACd,MAAMG,KAAK,CAAC,+BAA+B,CAAC;IAChD;IACA,IAAI,CAACD,aAAa,EAAE;MAChB,MAAMC,KAAK,CAAC,iCAAiC,CAAC;IAClD;IACA;IACA,IAAIC,QAAQ,GAAG,IAAI1C,GAAG,CAAC,CAAC;IACxB,KAAK,MAAM,CAACe,CAAC,EAAEC,CAAC,CAAC,IAAI,IAAI,CAACM,IAAI,EAAE;MAC5BoB,QAAQ,CAACzB,GAAG,CAACqB,WAAW,CAACK,SAAS,CAAC,CAAC,CAAC,EAAE9C,uBAAuB,CAACiC,sBAAsB,EAAEf,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC;IAClG;IACA;IACA,CAAC,CAAC,EAAEpB,eAAe,CAACkD,aAAa,EAAEJ,QAAQ,EAAEJ,WAAW,CAAC1B,IAAI,EAAE4B,aAAa,CAACG,SAAS,EAAEP,OAAO,CAAC;EACpG;EACAc,mBAAmBA,CAACnD,GAAG,EAAE;IACrB,OAAO,CAAC,CAAC,EAAEN,qBAAqB,CAACyD,mBAAmB,EAAE,IAAI,EAAEnD,GAAG,EAAE,IAAI,CAACqB,IAAI,CAAC;EAC/E;EACA+B,oBAAoBA,CAACpD,GAAG,EAAEqD,QAAQ,EAAE;IAChC,OAAO,CAAC,CAAC,EAAE1D,sBAAsB,CAACyD,oBAAoB,EAAE,IAAI,EAAEpD,GAAG,EAAE,IAAI,CAACqB,IAAI,EAAEgC,QAAQ,CAAC;EAC3F;AACJ;AACAnE,OAAO,CAACE,UAAU,GAAGA,UAAU;AAC/BA,UAAU,CAACkE,IAAI,GAAG;EACd;AACJ;AACA;AACA;EACIC,OAAO,EAAEA,CAAA,KAAM;IACX,OAAOC,gBAAgB,CAAC,CAAC;EAC7B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIC,MAAM,EAAG5C,IAAI,IAAK;IACd,OAAO6C,eAAe,CAAC7C,IAAI,CAAC;EAChC,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI8C,GAAG,EAAG9C,IAAI,IAAK;IACX,OAAO+C,YAAY,CAAC/C,IAAI,CAAC;EAC7B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIgD,OAAO,EAAGhD,IAAI,IAAK;IACf,OAAOiD,gBAAgB,CAACjD,IAAI,CAAC;EACjC,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIkD,IAAI,EAAGlD,IAAI,IAAK;IACZ,OAAOmD,aAAa,CAACnD,IAAI,CAAC;EAC9B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIoD,MAAM,EAAGC,KAAK,IAAK;IACf,OAAOC,eAAe,CAACD,KAAK,CAAC;EACjC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,SAAS,EAAGvD,IAAI,IAAK;IACjB,OAAOwD,kBAAkB,CAACxD,IAAI,CAAC;EACnC;AACJ,CAAC;AACDzB,UAAU,CAACkF,MAAM,GAAG;EAChB;AACJ;AACA;AACA;EACIb,MAAM,EAAG5C,IAAI,IAAK;IACd,OAAO0D,iBAAiB,CAAC1D,IAAI,CAAC;EAClC,CAAC;EACD;AACJ;AACA;AACA;EACI8C,GAAG,EAAG9C,IAAI,IAAK;IACX,OAAO2D,cAAc,CAAC3D,IAAI,CAAC;EAC/B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI4D,SAAS,EAAG5D,IAAI,IAAK;IACjB,OAAO6D,oBAAoB,CAAC7D,IAAI,CAAC;EACrC,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIgD,OAAO,EAAGhD,IAAI,IAAK;IACf,OAAO8D,kBAAkB,CAAC9D,IAAI,CAAC;EACnC,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIkD,IAAI,EAAGlD,IAAI,IAAK;IACZ,OAAO+D,eAAe,CAAC/D,IAAI,CAAC;EAChC,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIgE,UAAU,EAAGhE,IAAI,IAAK;IAClB,OAAOiE,qBAAqB,CAACjE,IAAI,CAAC;EACtC,CAAC;EACD;AACJ;AACA;AACA;EACIkE,IAAI,EAAEA,CAAA,KAAM;IACR,OAAOC,kBAAkB,CAAC,CAAC;EAC/B,CAAC;EACD;AACJ;AACA;AACA;EACIzB,OAAO,EAAEA,CAAA,KAAM;IACX,OAAO0B,kBAAkB,CAAC,CAAC;EAC/B,CAAC;EACD;AACJ;AACA;AACA;EACI5E,IAAI,EAAEA,CAAA,KAAM;IACR,OAAO6E,eAAe,CAAC,CAAC;EAC5B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIjB,MAAM,EAAGC,KAAK,IAAK;IACf,OAAOiB,iBAAiB,CAACjB,KAAK,CAAC;EACnC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,SAAS,EAAGvD,IAAI,IAAK;IACjB,OAAOuE,oBAAoB,CAACvE,IAAI,CAAC;EACrC,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIzB,UAAU,EAAEA,CAACY,GAAG,EAAEb,KAAK,KAAK;IACxB,OAAOkG,qBAAqB,CAACrF,GAAG,EAAEb,KAAK,CAAC;EAC5C;AACJ,CAAC;AACD;AACA;AACA;AACA,SAASqE,gBAAgBA,CAAA,EAAG;EACxB,OAAO;IACH3C,IAAI,EAAE,GAAG;IACT+B,SAAS,EAAG0C,GAAG,IAAK;MAChB,IAAI,CAACjG,SAAS,CAACkE,OAAO,CAACgC,SAAS,CAACD,GAAG,CAAC,EAAE;QACnC,MAAM5C,KAAK,CAAC,uBAAuB,CAAC;MACxC;MACA,OAAO,CAAC,CAAC,EAAEnD,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC0C,YAAY,CAACF,GAAG,CAAC,CAACrC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAACkF,cAAc,CAAC,GAAG,CAAC;IAClG,CAAC;IACD3E,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAO,CAAC,CAAC,EAAE/F,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC4C,SAAS,CAACJ,GAAG,EAAE,GAAG,CAAC,CAACrC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAACoF,WAAW,CAAC,CAAC;IAC9F;EACJ,CAAC;AACL;AACA,SAASjC,eAAeA,CAAC7C,IAAI,EAAE;EAC3B,OAAO;IACHA,IAAI;IACJ+B,SAAS,EAAG0C,GAAG,IAAK;MAChB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;QACzB,MAAM5C,KAAK,CAAC,qBAAqB,CAAC;MACtC;MACA,OAAO,CAAC,CAAC,EAAEnD,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC8C,QAAQ,CAACN,GAAG,EAAEzE,IAAI,CAAC,CAACoC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAACsF,WAAW,CAAChF,IAAI,CAAC;IAClG,CAAC;IACDC,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAO,CAAC,CAAC,EAAE/F,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC4C,SAAS,CAACJ,GAAG,EAAEzE,IAAI,CAAC,CAACoC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAACuF,UAAU,CAACjF,IAAI,CAAC;IAClG;EACJ,CAAC;AACL;AACA,SAAS+C,YAAYA,CAAC/C,IAAI,EAAE;EACxB,OAAO;IACHA,IAAI,EAAEA,IAAI;IACV+B,SAAS,EAAG0C,GAAG,IAAK;MAChB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;QACzB,MAAM5C,KAAK,CAAC,qBAAqB,CAAC;MACtC;MACA,IAAI,CAACqD,MAAM,CAACC,aAAa,CAACV,GAAG,CAAC,EAAE;QAC5B,MAAM5C,KAAK,CAAC,6BAA6B,GAAG4C,GAAG,CAAC;MACpD;MACA,OAAO,CAAC,CAAC,EAAE/F,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC8C,QAAQ,CAACN,GAAG,EAAEzE,IAAI,CAAC,CAACoC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAACsF,WAAW,CAAChF,IAAI,CAAC;IAClG,CAAC;IACDC,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAO,CAAC,CAAC,EAAE/F,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC4C,SAAS,CAACJ,GAAG,EAAEzE,IAAI,CAAC,CAACoC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAAC0F,OAAO,CAACpF,IAAI,CAAC;IAC/F;EACJ,CAAC;AACL;AACA,SAASiD,gBAAgBA,CAACjD,IAAI,EAAE;EAC5B,OAAO;IACHA,IAAI;IACJ+B,SAAS,EAAG0C,GAAG,IAAK;MAChB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;QACzB,MAAM5C,KAAK,CAAC,qBAAqB,CAAC;MACtC;MACA,IAAI4C,GAAG,GAAG,CAAC,EAAE;QACT,MAAM5C,KAAK,CAAC,mBAAmB,GAAG4C,GAAG,CAAC;MAC1C;MACA,OAAO,CAAC,CAAC,EAAE/F,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC4C,SAAS,CAACJ,GAAG,EAAEzE,IAAI,CAAC,CAACoC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAACsF,WAAW,CAAChF,IAAI,CAAC;IACnG,CAAC;IACDC,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAO,CAAC,CAAC,EAAE/F,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC4C,SAAS,CAACJ,GAAG,EAAEzE,IAAI,CAAC,CAACoC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAACsF,WAAW,CAAChF,IAAI,CAAC;IACnG;EACJ,CAAC;AACL;AACA,SAASmD,aAAaA,CAACnD,IAAI,EAAE;EACzB,OAAO;IACHA,IAAI;IACJ+B,SAAS,EAAG0C,GAAG,IAAK;MAChB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;QACzB,MAAM5C,KAAK,CAAC,qBAAqB,CAAC;MACtC;MACA,IAAI,CAACqD,MAAM,CAACC,aAAa,CAACV,GAAG,CAAC,EAAE;QAC5B,MAAM5C,KAAK,CAAC,6BAA6B,GAAG4C,GAAG,CAAC;MACpD;MACA,IAAIA,GAAG,GAAG,CAAC,EAAE;QACT,MAAM5C,KAAK,CAAC,mBAAmB,GAAG4C,GAAG,CAAC;MAC1C;MACA,OAAO,CAAC,CAAC,EAAE/F,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC4C,SAAS,CAACJ,GAAG,EAAEzE,IAAI,CAAC,CAACoC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAACsF,WAAW,CAAChF,IAAI,CAAC;IACnG,CAAC;IACDC,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOS,MAAM,CAAC,CAAC,CAAC,EAAExG,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC4C,SAAS,CAACJ,GAAG,EAAEzE,IAAI,CAAC,CAACoC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAAC2F,QAAQ,CAACrF,IAAI,CAAC,CAAC;IACxG;EACJ,CAAC;AACL;AACA,SAASsD,eAAeA,CAACD,KAAK,EAAE;EAC5B,OAAO;IACHrD,IAAI,EAAEqD,KAAK,GAAG,CAAC;IACftB,SAAS,EAAG0C,GAAG,IAAK;MAChB,IAAI,CAACrB,MAAM,CAACkC,QAAQ,CAACb,GAAG,CAAC,EAAE;QACvB,MAAM5C,KAAK,CAAC,qBAAqB,CAAC;MACtC;MACA,OAAO,CAAC,CAAC,EAAEnD,SAAS,CAACuD,SAAS,EAAE,CAAC,CAACsD,WAAW,CAACd,GAAG,CAAC,CAACrC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAACsF,WAAW,CAAC3B,KAAK,GAAG,CAAC,CAAC;IACpG,CAAC;IACDpD,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAO,CAAC,CAAC,EAAE/F,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC4C,SAAS,CAACJ,GAAG,EAAEpB,KAAK,GAAG,CAAC,CAAC,CAACjB,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAAC8F,UAAU,CAACnC,KAAK,CAAC;IACxG;EACJ,CAAC;AACL;AACA,SAASG,kBAAkBA,CAACxD,IAAI,EAAE;EAC9B,OAAO;IACHA,IAAI;IACJ+B,SAAS,EAAG0C,GAAG,IAAK;MAChB,IAAI,CAAC7F,WAAW,CAAC2E,SAAS,CAACkC,WAAW,CAAChB,GAAG,CAAC,EACvC,MAAM5C,KAAK,CAAC,wBAAwB,CAAC;MACzC,OAAO,CAAC,CAAC,EAAEnD,SAAS,CAACuD,SAAS,EAAE,CAAC,CAACyD,SAAS,CAACjB,GAAG,CAAC,CAACrC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAACsF,WAAW,CAAChF,IAAI,CAAC;IAC7F,CAAC;IACDC,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAO,CAAC,CAAC,EAAE/F,SAAS,CAACuD,SAAS,EAAE,CAAC,CAAC4C,SAAS,CAACJ,GAAG,EAAEzE,IAAI,CAAC,CAACoC,OAAO,CAAC,CAAC,CAAC1C,UAAU,CAAC,CAAC,CAACiG,QAAQ,CAAC3F,IAAI,CAAC;IAChG;EACJ,CAAC;AACL;AACA,SAAS2D,cAAcA,CAAC3D,IAAI,EAAE;EAC1B,OAAO;IACH+B,SAAS,EAAEA,CAAC0C,GAAG,EAAEmB,OAAO,KAAK;MACzBA,OAAO,CAACb,QAAQ,CAACN,GAAG,EAAEzE,IAAI,CAAC;IAC/B,CAAC;IACDC,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOA,GAAG,CAACW,OAAO,CAACpF,IAAI,CAAC;IAC5B;EACJ,CAAC;AACL;AACA,SAAS0D,iBAAiBA,CAAC1D,IAAI,EAAE;EAC7B,OAAO;IACH+B,SAAS,EAAEA,CAAC0C,GAAG,EAAEmB,OAAO,KAAK;MACzBA,OAAO,CAACb,QAAQ,CAACN,GAAG,EAAEzE,IAAI,CAAC;IAC/B,CAAC;IACDC,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOA,GAAG,CAACQ,UAAU,CAACjF,IAAI,CAAC;IAC/B;EACJ,CAAC;AACL;AACA,SAAS6D,oBAAoBA,CAAC7D,IAAI,EAAE;EAChC,OAAO;IACH+B,SAAS,EAAEA,CAAC0C,GAAG,EAAEmB,OAAO,KAAK;MACzBA,OAAO,CAACC,WAAW,CAACpB,GAAG,EAAEzE,IAAI,CAAC;IAClC,CAAC;IACDC,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOA,GAAG,CAACqB,aAAa,CAAC9F,IAAI,CAAC;IAClC;EACJ,CAAC;AACL;AACA,SAASiE,qBAAqBA,CAACjE,IAAI,EAAE;EACjC,OAAO;IACH+B,SAAS,EAAEA,CAAC0C,GAAG,EAAEmB,OAAO,KAAK;MACzBA,OAAO,CAACG,YAAY,CAACtB,GAAG,EAAEzE,IAAI,CAAC;IACnC,CAAC;IACDC,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOA,GAAG,CAACuB,cAAc,CAAChG,IAAI,CAAC;IACnC;EACJ,CAAC;AACL;AACA,SAAS+D,eAAeA,CAAC/D,IAAI,EAAE;EAC3B,OAAO;IACH+B,SAAS,EAAEA,CAAC0C,GAAG,EAAEmB,OAAO,KAAK;MACzBA,OAAO,CAACf,SAAS,CAACJ,GAAG,EAAEzE,IAAI,CAAC;IAChC,CAAC;IACDC,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOA,GAAG,CAACY,QAAQ,CAACrF,IAAI,CAAC;IAC7B;EACJ,CAAC;AACL;AACA,SAAS8D,kBAAkBA,CAAC9D,IAAI,EAAE;EAC9B,OAAO;IACH+B,SAAS,EAAEA,CAAC0C,GAAG,EAAEmB,OAAO,KAAK;MACzBA,OAAO,CAACf,SAAS,CAACJ,GAAG,EAAEzE,IAAI,CAAC;IAChC,CAAC;IACDC,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOA,GAAG,CAACO,WAAW,CAAChF,IAAI,CAAC;IAChC;EACJ,CAAC;AACL;AACA,SAASmE,kBAAkBA,CAAA,EAAG;EAC1B,OAAO;IACHpC,SAAS,EAAEA,CAAC0C,GAAG,EAAEmB,OAAO,KAAK;MACzBA,OAAO,CAACnE,QAAQ,CAACgD,GAAG,CAAC;IACzB,CAAC;IACDxE,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOA,GAAG,CAACwB,OAAO,CAAC,CAAC;IACxB;EACJ,CAAC;AACL;AACA,SAAS7B,kBAAkBA,CAAA,EAAG;EAC1B,OAAO;IACHrC,SAAS,EAAEA,CAAC0C,GAAG,EAAEmB,OAAO,KAAK;MACzBA,OAAO,CAACjB,YAAY,CAACF,GAAG,CAAC;IAC7B,CAAC;IACDxE,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOA,GAAG,CAACK,WAAW,CAAC,CAAC;IAC5B;EACJ,CAAC;AACL;AACA,SAAST,eAAeA,CAAA,EAAG;EACvB,OAAO;IACHtC,SAAS,EAAEA,CAAC0C,GAAG,EAAEmB,OAAO,KAAK;MACzBA,OAAO,CAACzD,QAAQ,CAACsC,GAAG,CAAC;IACzB,CAAC;IACDxE,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOA,GAAG,CAACyB,OAAO,CAAC,CAAC;IACxB;EACJ,CAAC;AACL;AACA,SAAS1B,qBAAqBA,CAACrF,GAAG,EAAEb,KAAK,EAAE;EACvC,OAAO;IACHyD,SAAS,EAAEA,CAAC0C,GAAG,EAAEmB,OAAO,KAAK;MACzBnB,GAAG,CAAClD,KAAK,CAACqE,OAAO,CAAC;IACtB,CAAC;IACD3F,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOlG,UAAU,CAACc,IAAI,CAACF,GAAG,EAAEb,KAAK,EAAEmG,GAAG,CAAC;IAC3C;EACJ,CAAC;AACL;AACA,SAASH,iBAAiBA,CAAC3D,IAAI,EAAE;EAC7B,OAAO;IACHoB,SAAS,EAAEA,CAAC0C,GAAG,EAAEmB,OAAO,KAAK;MACzB,IAAInB,GAAG,CAAC0B,MAAM,KAAKxF,IAAI,EAAE;QACrB,MAAMkB,KAAK,CAAC,qBAAqB,CAAC;MACtC;MACA+D,OAAO,CAACL,WAAW,CAACd,GAAG,CAAC;IAC5B,CAAC;IACDxE,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOA,GAAG,CAACe,UAAU,CAAC7E,IAAI,CAAC;IAC/B;EACJ,CAAC;AACL;AACA,SAAS4D,oBAAoBA,CAACvE,IAAI,EAAE;EAChC,OAAO;IACH+B,SAAS,EAAEA,CAAC0C,GAAG,EAAEjD,OAAO,KAAK;MACzB,IAAIiD,GAAG,CAAC0B,MAAM,KAAKnG,IAAI,EAAE;QACrB,MAAM6B,KAAK,CAAC,wBAAwB,CAAC;MACzC;MACAL,OAAO,CAACkE,SAAS,CAACjB,GAAG,CAAC;IAC1B,CAAC;IACDxE,KAAK,EAAGwE,GAAG,IAAK;MACZ,OAAOA,GAAG,CAACkB,QAAQ,CAAC3F,IAAI,CAAC;IAC7B;EACJ,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}