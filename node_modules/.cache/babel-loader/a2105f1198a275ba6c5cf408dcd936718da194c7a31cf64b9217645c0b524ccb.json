{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseTuple = exports.serializeTuple = void 0;\nconst Builder_1 = require(\"../boc/Builder\");\nconst INT64_MIN = BigInt('-9223372036854775808');\nconst INT64_MAX = BigInt('9223372036854775807');\n// vm_stk_null#00 = VmStackValue;\n// vm_stk_tinyint#01 value:int64 = VmStackValue;\n// vm_stk_int#0201_ value:int257 = VmStackValue;\n// vm_stk_nan#02ff = VmStackValue;\n// vm_stk_cell#03 cell:^Cell = VmStackValue;\n//_ cell:^Cell st_bits:(## 10) end_bits:(## 10) { st_bits <= end_bits }\n//   st_ref:(#<= 4) end_ref:(#<= 4) { st_ref <= end_ref } = VmCellSlice;\n// vm_stk_slice#04 _:VmCellSlice = VmStackValue;\n// vm_stk_builder#05 cell:^Cell = VmStackValue;\n// vm_stk_cont#06 cont:VmCont = VmStackValue;\n// vm_tupref_nil$_ = VmTupleRef 0;\n// vm_tupref_single$_ entry:^VmStackValue = VmTupleRef 1;\n// vm_tupref_any$_ {n:#} ref:^(VmTuple (n + 2)) = VmTupleRef (n + 2);\n// vm_tuple_nil$_ = VmTuple 0;\n// vm_tuple_tcons$_ {n:#} head:(VmTupleRef n) tail:^VmStackValue = VmTuple (n + 1);\n// vm_stk_tuple#07 len:(## 16) data:(VmTuple len) = VmStackValue;\nfunction serializeTupleItem(src, builder) {\n  if (src.type === 'null') {\n    builder.storeUint(0x00, 8);\n  } else if (src.type === 'int') {\n    if (src.value <= INT64_MAX && src.value >= INT64_MIN) {\n      builder.storeUint(0x01, 8);\n      builder.storeInt(src.value, 64);\n    } else {\n      builder.storeUint(0x0100, 15);\n      builder.storeInt(src.value, 257);\n    }\n  } else if (src.type === 'nan') {\n    builder.storeInt(0x02ff, 16);\n  } else if (src.type === 'cell') {\n    builder.storeUint(0x03, 8);\n    builder.storeRef(src.cell);\n  } else if (src.type === 'slice') {\n    builder.storeUint(0x04, 8);\n    builder.storeUint(0, 10);\n    builder.storeUint(src.cell.bits.length, 10);\n    builder.storeUint(0, 3);\n    builder.storeUint(src.cell.refs.length, 3);\n    builder.storeRef(src.cell);\n  } else if (src.type === 'builder') {\n    builder.storeUint(0x05, 8);\n    builder.storeRef(src.cell);\n  } else if (src.type === 'tuple') {\n    let head = null;\n    let tail = null;\n    for (let i = 0; i < src.items.length; i++) {\n      // Swap\n      let s = head;\n      head = tail;\n      tail = s;\n      if (i > 1) {\n        head = (0, Builder_1.beginCell)().storeRef(tail).storeRef(head).endCell();\n      }\n      let bc = (0, Builder_1.beginCell)();\n      serializeTupleItem(src.items[i], bc);\n      tail = bc.endCell();\n    }\n    builder.storeUint(0x07, 8);\n    builder.storeUint(src.items.length, 16);\n    if (head) {\n      builder.storeRef(head);\n    }\n    if (tail) {\n      builder.storeRef(tail);\n    }\n  } else {\n    throw Error('Invalid value');\n  }\n}\nfunction parseStackItem(cs) {\n  let kind = cs.loadUint(8);\n  if (kind === 0) {\n    return {\n      type: 'null'\n    };\n  } else if (kind === 1) {\n    return {\n      type: 'int',\n      value: cs.loadIntBig(64)\n    };\n  } else if (kind === 2) {\n    if (cs.loadUint(7) === 0) {\n      return {\n        type: 'int',\n        value: cs.loadIntBig(257)\n      };\n    } else {\n      cs.loadBit(); // must eq 1\n      return {\n        type: 'nan'\n      };\n    }\n  } else if (kind === 3) {\n    return {\n      type: 'cell',\n      cell: cs.loadRef()\n    };\n  } else if (kind === 4) {\n    let startBits = cs.loadUint(10);\n    let endBits = cs.loadUint(10);\n    let startRefs = cs.loadUint(3);\n    let endRefs = cs.loadUint(3);\n    // Copy to new cell\n    let rs = cs.loadRef().beginParse();\n    rs.skip(startBits);\n    let dt = rs.loadBits(endBits - startBits);\n    let builder = (0, Builder_1.beginCell)().storeBits(dt);\n    // Copy refs if exist\n    if (startRefs < endRefs) {\n      for (let i = 0; i < startRefs; i++) {\n        rs.loadRef();\n      }\n      for (let i = 0; i < endRefs - startRefs; i++) {\n        builder.storeRef(rs.loadRef());\n      }\n    }\n    return {\n      type: 'slice',\n      cell: builder.endCell()\n    };\n  } else if (kind === 5) {\n    return {\n      type: 'builder',\n      cell: cs.loadRef()\n    };\n  } else if (kind === 7) {\n    let length = cs.loadUint(16);\n    let items = [];\n    if (length > 1) {\n      let head = cs.loadRef().beginParse();\n      let tail = cs.loadRef().beginParse();\n      items.unshift(parseStackItem(tail));\n      for (let i = 0; i < length - 2; i++) {\n        let ohead = head;\n        head = ohead.loadRef().beginParse();\n        tail = ohead.loadRef().beginParse();\n        items.unshift(parseStackItem(tail));\n      }\n      items.unshift(parseStackItem(head));\n    } else if (length === 1) {\n      items.push(parseStackItem(cs.loadRef().beginParse()));\n    }\n    return {\n      type: 'tuple',\n      items\n    };\n  } else {\n    throw Error('Unsupported stack item');\n  }\n}\n//\n// Stack parsing\n// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/block.tlb#L783\n//\n// vm_stack#_ depth:(## 24) stack:(VmStackList depth) = VmStack;\n// vm_stk_cons#_ {n:#} rest:^(VmStackList n) tos:VmStackValue = VmStackList (n + 1);\n// vm_stk_nil#_ = VmStackList 0;\n//\nfunction serializeTupleTail(src, builder) {\n  if (src.length > 0) {\n    // rest:^(VmStackList n)\n    let tail = (0, Builder_1.beginCell)();\n    serializeTupleTail(src.slice(0, src.length - 1), tail);\n    builder.storeRef(tail.endCell());\n    // tos\n    serializeTupleItem(src[src.length - 1], builder);\n  }\n}\nfunction serializeTuple(src) {\n  let builder = (0, Builder_1.beginCell)();\n  builder.storeUint(src.length, 24);\n  let r = [...src];\n  serializeTupleTail(r, builder);\n  return builder.endCell();\n}\nexports.serializeTuple = serializeTuple;\nfunction parseTuple(src) {\n  let res = [];\n  let cs = src.beginParse();\n  let size = cs.loadUint(24);\n  for (let i = 0; i < size; i++) {\n    let next = cs.loadRef();\n    res.unshift(parseStackItem(cs));\n    cs = next.beginParse();\n  }\n  return res;\n}\nexports.parseTuple = parseTuple;","map":{"version":3,"names":["Object","defineProperty","exports","value","parseTuple","serializeTuple","Builder_1","require","INT64_MIN","BigInt","INT64_MAX","serializeTupleItem","src","builder","type","storeUint","storeInt","storeRef","cell","bits","length","refs","head","tail","i","items","s","beginCell","endCell","bc","Error","parseStackItem","cs","kind","loadUint","loadIntBig","loadBit","loadRef","startBits","endBits","startRefs","endRefs","rs","beginParse","skip","dt","loadBits","storeBits","unshift","ohead","push","serializeTupleTail","slice","r","res","size","next"],"sources":["C:/Users/adams/Downloads/GLL/slotpot/node_modules/@ton/core/dist/tuple/tuple.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseTuple = exports.serializeTuple = void 0;\nconst Builder_1 = require(\"../boc/Builder\");\nconst INT64_MIN = BigInt('-9223372036854775808');\nconst INT64_MAX = BigInt('9223372036854775807');\n// vm_stk_null#00 = VmStackValue;\n// vm_stk_tinyint#01 value:int64 = VmStackValue;\n// vm_stk_int#0201_ value:int257 = VmStackValue;\n// vm_stk_nan#02ff = VmStackValue;\n// vm_stk_cell#03 cell:^Cell = VmStackValue;\n//_ cell:^Cell st_bits:(## 10) end_bits:(## 10) { st_bits <= end_bits }\n//   st_ref:(#<= 4) end_ref:(#<= 4) { st_ref <= end_ref } = VmCellSlice;\n// vm_stk_slice#04 _:VmCellSlice = VmStackValue;\n// vm_stk_builder#05 cell:^Cell = VmStackValue;\n// vm_stk_cont#06 cont:VmCont = VmStackValue;\n// vm_tupref_nil$_ = VmTupleRef 0;\n// vm_tupref_single$_ entry:^VmStackValue = VmTupleRef 1;\n// vm_tupref_any$_ {n:#} ref:^(VmTuple (n + 2)) = VmTupleRef (n + 2);\n// vm_tuple_nil$_ = VmTuple 0;\n// vm_tuple_tcons$_ {n:#} head:(VmTupleRef n) tail:^VmStackValue = VmTuple (n + 1);\n// vm_stk_tuple#07 len:(## 16) data:(VmTuple len) = VmStackValue;\nfunction serializeTupleItem(src, builder) {\n    if (src.type === 'null') {\n        builder.storeUint(0x00, 8);\n    }\n    else if (src.type === 'int') {\n        if (src.value <= INT64_MAX && src.value >= INT64_MIN) {\n            builder.storeUint(0x01, 8);\n            builder.storeInt(src.value, 64);\n        }\n        else {\n            builder.storeUint(0x0100, 15);\n            builder.storeInt(src.value, 257);\n        }\n    }\n    else if (src.type === 'nan') {\n        builder.storeInt(0x02ff, 16);\n    }\n    else if (src.type === 'cell') {\n        builder.storeUint(0x03, 8);\n        builder.storeRef(src.cell);\n    }\n    else if (src.type === 'slice') {\n        builder.storeUint(0x04, 8);\n        builder.storeUint(0, 10);\n        builder.storeUint(src.cell.bits.length, 10);\n        builder.storeUint(0, 3);\n        builder.storeUint(src.cell.refs.length, 3);\n        builder.storeRef(src.cell);\n    }\n    else if (src.type === 'builder') {\n        builder.storeUint(0x05, 8);\n        builder.storeRef(src.cell);\n    }\n    else if (src.type === 'tuple') {\n        let head = null;\n        let tail = null;\n        for (let i = 0; i < src.items.length; i++) {\n            // Swap\n            let s = head;\n            head = tail;\n            tail = s;\n            if (i > 1) {\n                head = (0, Builder_1.beginCell)()\n                    .storeRef(tail)\n                    .storeRef(head)\n                    .endCell();\n            }\n            let bc = (0, Builder_1.beginCell)();\n            serializeTupleItem(src.items[i], bc);\n            tail = bc.endCell();\n        }\n        builder.storeUint(0x07, 8);\n        builder.storeUint(src.items.length, 16);\n        if (head) {\n            builder.storeRef(head);\n        }\n        if (tail) {\n            builder.storeRef(tail);\n        }\n    }\n    else {\n        throw Error('Invalid value');\n    }\n}\nfunction parseStackItem(cs) {\n    let kind = cs.loadUint(8);\n    if (kind === 0) {\n        return { type: 'null' };\n    }\n    else if (kind === 1) {\n        return { type: 'int', value: cs.loadIntBig(64) };\n    }\n    else if (kind === 2) {\n        if (cs.loadUint(7) === 0) {\n            return { type: 'int', value: cs.loadIntBig(257) };\n        }\n        else {\n            cs.loadBit(); // must eq 1\n            return { type: 'nan' };\n        }\n    }\n    else if (kind === 3) {\n        return { type: 'cell', cell: cs.loadRef() };\n    }\n    else if (kind === 4) {\n        let startBits = cs.loadUint(10);\n        let endBits = cs.loadUint(10);\n        let startRefs = cs.loadUint(3);\n        let endRefs = cs.loadUint(3);\n        // Copy to new cell\n        let rs = cs.loadRef().beginParse();\n        rs.skip(startBits);\n        let dt = rs.loadBits(endBits - startBits);\n        let builder = (0, Builder_1.beginCell)()\n            .storeBits(dt);\n        // Copy refs if exist\n        if (startRefs < endRefs) {\n            for (let i = 0; i < startRefs; i++) {\n                rs.loadRef();\n            }\n            for (let i = 0; i < endRefs - startRefs; i++) {\n                builder.storeRef(rs.loadRef());\n            }\n        }\n        return { type: 'slice', cell: builder.endCell() };\n    }\n    else if (kind === 5) {\n        return { type: 'builder', cell: cs.loadRef() };\n    }\n    else if (kind === 7) {\n        let length = cs.loadUint(16);\n        let items = [];\n        if (length > 1) {\n            let head = cs.loadRef().beginParse();\n            let tail = cs.loadRef().beginParse();\n            items.unshift(parseStackItem(tail));\n            for (let i = 0; i < length - 2; i++) {\n                let ohead = head;\n                head = ohead.loadRef().beginParse();\n                tail = ohead.loadRef().beginParse();\n                items.unshift(parseStackItem(tail));\n            }\n            items.unshift(parseStackItem(head));\n        }\n        else if (length === 1) {\n            items.push(parseStackItem(cs.loadRef().beginParse()));\n        }\n        return { type: 'tuple', items };\n    }\n    else {\n        throw Error('Unsupported stack item');\n    }\n}\n//\n// Stack parsing\n// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/block.tlb#L783\n//\n// vm_stack#_ depth:(## 24) stack:(VmStackList depth) = VmStack;\n// vm_stk_cons#_ {n:#} rest:^(VmStackList n) tos:VmStackValue = VmStackList (n + 1);\n// vm_stk_nil#_ = VmStackList 0;\n//\nfunction serializeTupleTail(src, builder) {\n    if (src.length > 0) {\n        // rest:^(VmStackList n)\n        let tail = (0, Builder_1.beginCell)();\n        serializeTupleTail(src.slice(0, src.length - 1), tail);\n        builder.storeRef(tail.endCell());\n        // tos\n        serializeTupleItem(src[src.length - 1], builder);\n    }\n}\nfunction serializeTuple(src) {\n    let builder = (0, Builder_1.beginCell)();\n    builder.storeUint(src.length, 24);\n    let r = [...src];\n    serializeTupleTail(r, builder);\n    return builder.endCell();\n}\nexports.serializeTuple = serializeTuple;\nfunction parseTuple(src) {\n    let res = [];\n    let cs = src.beginParse();\n    let size = cs.loadUint(24);\n    for (let i = 0; i < size; i++) {\n        let next = cs.loadRef();\n        res.unshift(parseStackItem(cs));\n        cs = next.beginParse();\n    }\n    return res;\n}\nexports.parseTuple = parseTuple;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}