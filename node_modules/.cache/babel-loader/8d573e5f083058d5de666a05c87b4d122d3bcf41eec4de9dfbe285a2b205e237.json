{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mnemonicFromRandomSeed = exports.mnemonicIndexesToBytes = exports.bytesToMnemonics = exports.bytesToMnemonicIndexes = exports.mnemonicNew = exports.mnemonicValidate = exports.mnemonicToHDSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicToSeed = exports.mnemonicToEntropy = void 0;\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst getSecureRandom_1 = require(\"../primitives/getSecureRandom\");\nconst hmac_sha512_1 = require(\"../primitives/hmac_sha512\");\nconst pbkdf2_sha512_1 = require(\"../primitives/pbkdf2_sha512\");\nconst binary_1 = require(\"../utils/binary\");\nconst wordlist_1 = require(\"./wordlist\");\nconst PBKDF_ITERATIONS = 100000;\nasync function isPasswordNeeded(mnemonicArray) {\n  const passlessEntropy = await mnemonicToEntropy(mnemonicArray);\n  return (await isPasswordSeed(passlessEntropy)) && !(await isBasicSeed(passlessEntropy));\n}\nfunction normalizeMnemonic(src) {\n  return src.map(v => v.toLowerCase().trim());\n}\nasync function isBasicSeed(entropy) {\n  // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L68\n  // bool Mnemonic::is_basic_seed() {\n  //   td::SecureString hash(64);\n  //   td::pbkdf2_sha512(as_slice(to_entropy()), \"TON seed version\", td::max(1, PBKDF_ITERATIONS / 256),\n  //                     hash.as_mutable_slice());\n  //   return hash.as_slice()[0] == 0;\n  // }\n  const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, 'TON seed version', Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);\n  return seed[0] == 0;\n}\nasync function isPasswordSeed(entropy) {\n  // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L75\n  // bool Mnemonic::is_password_seed() {\n  //   td::SecureString hash(64);\n  //   td::pbkdf2_sha512(as_slice(to_entropy()), \"TON fast seed version\", 1, hash.as_mutable_slice());\n  //   return hash.as_slice()[0] == 1;\n  // }\n  const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, 'TON fast seed version', 1, 64);\n  return seed[0] == 1;\n}\nasync function mnemonicToEntropy(mnemonicArray, password) {\n  // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L52\n  // td::SecureString Mnemonic::to_entropy() const {\n  //   td::SecureString res(64);\n  //   td::hmac_sha512(join(words_), password_, res.as_mutable_slice());\n  //   return res;\n  // }\n  return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(' '), password && password.length > 0 ? password : '');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nasync function mnemonicToSeed(mnemonicArray, seed, password) {\n  // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L58\n  // td::SecureString Mnemonic::to_seed() const {\n  //   td::SecureString hash(64);\n  //   td::pbkdf2_sha512(as_slice(to_entropy()), \"TON default seed\", PBKDF_ITERATIONS, hash.as_mutable_slice());\n  //   return hash;\n  // }\n  const entropy = await mnemonicToEntropy(mnemonicArray, password);\n  return await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);\n}\nexports.mnemonicToSeed = mnemonicToSeed;\n/**\n * Extract private key from mnemonic\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns Key Pair\n */\nasync function mnemonicToPrivateKey(mnemonicArray, password) {\n  // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L64\n  // td::Ed25519::PrivateKey Mnemonic::to_private_key() const {\n  //   return td::Ed25519::PrivateKey(td::SecureString(as_slice(to_seed()).substr(0, td::Ed25519::PrivateKey::LENGTH)));\n  // }\n  mnemonicArray = normalizeMnemonic(mnemonicArray);\n  const seed = await mnemonicToSeed(mnemonicArray, 'TON default seed', password);\n  let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed.slice(0, 32));\n  return {\n    publicKey: Buffer.from(keyPair.publicKey),\n    secretKey: Buffer.from(keyPair.secretKey)\n  };\n}\nexports.mnemonicToPrivateKey = mnemonicToPrivateKey;\n/**\n * Convert mnemonic to wallet key pair\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns Key Pair\n */\nasync function mnemonicToWalletKey(mnemonicArray, password) {\n  let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);\n  let seedSecret = seedPk.secretKey.slice(0, 32);\n  const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);\n  return {\n    publicKey: Buffer.from(keyPair.publicKey),\n    secretKey: Buffer.from(keyPair.secretKey)\n  };\n}\nexports.mnemonicToWalletKey = mnemonicToWalletKey;\n/**\n * Convert mnemonics to HD seed\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns 64 byte seed\n */\nasync function mnemonicToHDSeed(mnemonicArray, password) {\n  mnemonicArray = normalizeMnemonic(mnemonicArray);\n  return await mnemonicToSeed(mnemonicArray, 'TON HD Keys seed', password);\n}\nexports.mnemonicToHDSeed = mnemonicToHDSeed;\n/**\n * Validate Mnemonic\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns true for valid mnemonic\n */\nasync function mnemonicValidate(mnemonicArray, password) {\n  // Normalize\n  mnemonicArray = normalizeMnemonic(mnemonicArray);\n  // Validate mnemonic words\n  for (let word of mnemonicArray) {\n    if (wordlist_1.wordlist.indexOf(word) < 0) {\n      return false;\n    }\n  }\n  // Check password\n  if (password && password.length > 0) {\n    if (!(await isPasswordNeeded(mnemonicArray))) {\n      return false;\n    }\n  }\n  // Validate seed\n  return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));\n}\nexports.mnemonicValidate = mnemonicValidate;\n/**\n * Generate new Mnemonic\n * @param wordsCount number of words to generate\n * @param password mnemonic password\n * @returns\n */\nasync function mnemonicNew(wordsCount = 24, password) {\n  // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L159\n  let mnemonicArray = [];\n  while (true) {\n    // Regenerate new mnemonics\n    mnemonicArray = [];\n    for (let i = 0; i < wordsCount; i++) {\n      let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);\n      mnemonicArray.push(wordlist_1.wordlist[ind]);\n    }\n    // Chek password conformance\n    if (password && password.length > 0) {\n      if (!(await isPasswordNeeded(mnemonicArray))) {\n        continue;\n      }\n    }\n    // Check if basic seed correct\n    if (!(await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password)))) {\n      continue;\n    }\n    break;\n  }\n  return mnemonicArray;\n}\nexports.mnemonicNew = mnemonicNew;\n/**\n * Converts bytes to mnemonics array (could be invalid for TON)\n * @param src source buffer\n * @param wordsCount number of words\n */\nfunction bytesToMnemonicIndexes(src, wordsCount) {\n  let bits = (0, binary_1.bytesToBits)(src);\n  let indexes = [];\n  for (let i = 0; i < wordsCount; i++) {\n    let sl = bits.slice(i * 11, i * 11 + 11);\n    indexes.push(parseInt(sl, 2));\n  }\n  return indexes;\n}\nexports.bytesToMnemonicIndexes = bytesToMnemonicIndexes;\nfunction bytesToMnemonics(src, wordsCount) {\n  let mnemonics = bytesToMnemonicIndexes(src, wordsCount);\n  let res = [];\n  for (let m of mnemonics) {\n    res.push(wordlist_1.wordlist[m]);\n  }\n  return res;\n}\nexports.bytesToMnemonics = bytesToMnemonics;\n/**\n * Converts mnemonics indexes to buffer with zero padding in the end\n * @param src source indexes\n * @returns Buffer\n */\nfunction mnemonicIndexesToBytes(src) {\n  let res = '';\n  for (let s of src) {\n    if (!Number.isSafeInteger(s)) {\n      throw Error('Invalid input');\n    }\n    if (s < 0 || s >= 2028) {\n      throw Error('Invalid input');\n    }\n    res += (0, binary_1.lpad)(s.toString(2), '0', 11);\n  }\n  while (res.length % 8 !== 0) {\n    res = res + '0';\n  }\n  return (0, binary_1.bitsToBytes)(res);\n}\nexports.mnemonicIndexesToBytes = mnemonicIndexesToBytes;\n/**\n * Generates deterministically mnemonics\n * @param seed\n * @param wordsCount\n * @param password\n */\nasync function mnemonicFromRandomSeed(seed, wordsCount = 24, password) {\n  const bytesLength = Math.ceil(wordsCount * 11 / 8);\n  let currentSeed = seed;\n  while (true) {\n    // Create entropy\n    let entropy = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(currentSeed, 'TON mnemonic seed', Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), bytesLength);\n    // Create mnemonics\n    let mnemonics = bytesToMnemonics(entropy, wordsCount);\n    // Check if mnemonics are valid\n    if (await mnemonicValidate(mnemonics, password)) {\n      return mnemonics;\n    }\n    currentSeed = entropy;\n  }\n}\nexports.mnemonicFromRandomSeed = mnemonicFromRandomSeed;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","mnemonicFromRandomSeed","mnemonicIndexesToBytes","bytesToMnemonics","bytesToMnemonicIndexes","mnemonicNew","mnemonicValidate","mnemonicToHDSeed","mnemonicToWalletKey","mnemonicToPrivateKey","mnemonicToSeed","mnemonicToEntropy","tweetnacl_1","require","getSecureRandom_1","hmac_sha512_1","pbkdf2_sha512_1","binary_1","wordlist_1","PBKDF_ITERATIONS","isPasswordNeeded","mnemonicArray","passlessEntropy","isPasswordSeed","isBasicSeed","normalizeMnemonic","src","map","v","toLowerCase","trim","entropy","seed","pbkdf2_sha512","Math","max","floor","password","hmac_sha512","join","length","keyPair","default","sign","fromSeed","slice","publicKey","Buffer","from","secretKey","seedPk","seedSecret","word","wordlist","indexOf","wordsCount","i","ind","getSecureRandomNumber","push","bits","bytesToBits","indexes","sl","parseInt","mnemonics","res","m","s","Number","isSafeInteger","Error","lpad","toString","bitsToBytes","bytesLength","ceil","currentSeed"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/crypto/dist/mnemonic/mnemonic.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mnemonicFromRandomSeed = exports.mnemonicIndexesToBytes = exports.bytesToMnemonics = exports.bytesToMnemonicIndexes = exports.mnemonicNew = exports.mnemonicValidate = exports.mnemonicToHDSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicToSeed = exports.mnemonicToEntropy = void 0;\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst getSecureRandom_1 = require(\"../primitives/getSecureRandom\");\nconst hmac_sha512_1 = require(\"../primitives/hmac_sha512\");\nconst pbkdf2_sha512_1 = require(\"../primitives/pbkdf2_sha512\");\nconst binary_1 = require(\"../utils/binary\");\nconst wordlist_1 = require(\"./wordlist\");\nconst PBKDF_ITERATIONS = 100000;\nasync function isPasswordNeeded(mnemonicArray) {\n    const passlessEntropy = await mnemonicToEntropy(mnemonicArray);\n    return (await isPasswordSeed(passlessEntropy)) && !(await isBasicSeed(passlessEntropy));\n}\nfunction normalizeMnemonic(src) {\n    return src.map((v) => v.toLowerCase().trim());\n}\nasync function isBasicSeed(entropy) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L68\n    // bool Mnemonic::is_basic_seed() {\n    //   td::SecureString hash(64);\n    //   td::pbkdf2_sha512(as_slice(to_entropy()), \"TON seed version\", td::max(1, PBKDF_ITERATIONS / 256),\n    //                     hash.as_mutable_slice());\n    //   return hash.as_slice()[0] == 0;\n    // }\n    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, 'TON seed version', Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);\n    return seed[0] == 0;\n}\nasync function isPasswordSeed(entropy) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L75\n    // bool Mnemonic::is_password_seed() {\n    //   td::SecureString hash(64);\n    //   td::pbkdf2_sha512(as_slice(to_entropy()), \"TON fast seed version\", 1, hash.as_mutable_slice());\n    //   return hash.as_slice()[0] == 1;\n    // }\n    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, 'TON fast seed version', 1, 64);\n    return seed[0] == 1;\n}\nasync function mnemonicToEntropy(mnemonicArray, password) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L52\n    // td::SecureString Mnemonic::to_entropy() const {\n    //   td::SecureString res(64);\n    //   td::hmac_sha512(join(words_), password_, res.as_mutable_slice());\n    //   return res;\n    // }\n    return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(' '), password && password.length > 0 ? password : '');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nasync function mnemonicToSeed(mnemonicArray, seed, password) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L58\n    // td::SecureString Mnemonic::to_seed() const {\n    //   td::SecureString hash(64);\n    //   td::pbkdf2_sha512(as_slice(to_entropy()), \"TON default seed\", PBKDF_ITERATIONS, hash.as_mutable_slice());\n    //   return hash;\n    // }\n    const entropy = await mnemonicToEntropy(mnemonicArray, password);\n    return await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);\n}\nexports.mnemonicToSeed = mnemonicToSeed;\n/**\n * Extract private key from mnemonic\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns Key Pair\n */\nasync function mnemonicToPrivateKey(mnemonicArray, password) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L64\n    // td::Ed25519::PrivateKey Mnemonic::to_private_key() const {\n    //   return td::Ed25519::PrivateKey(td::SecureString(as_slice(to_seed()).substr(0, td::Ed25519::PrivateKey::LENGTH)));\n    // }\n    mnemonicArray = normalizeMnemonic(mnemonicArray);\n    const seed = (await mnemonicToSeed(mnemonicArray, 'TON default seed', password));\n    let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed.slice(0, 32));\n    return {\n        publicKey: Buffer.from(keyPair.publicKey),\n        secretKey: Buffer.from(keyPair.secretKey)\n    };\n}\nexports.mnemonicToPrivateKey = mnemonicToPrivateKey;\n/**\n * Convert mnemonic to wallet key pair\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns Key Pair\n */\nasync function mnemonicToWalletKey(mnemonicArray, password) {\n    let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);\n    let seedSecret = seedPk.secretKey.slice(0, 32);\n    const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);\n    return {\n        publicKey: Buffer.from(keyPair.publicKey),\n        secretKey: Buffer.from(keyPair.secretKey)\n    };\n}\nexports.mnemonicToWalletKey = mnemonicToWalletKey;\n/**\n * Convert mnemonics to HD seed\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns 64 byte seed\n */\nasync function mnemonicToHDSeed(mnemonicArray, password) {\n    mnemonicArray = normalizeMnemonic(mnemonicArray);\n    return (await mnemonicToSeed(mnemonicArray, 'TON HD Keys seed', password));\n}\nexports.mnemonicToHDSeed = mnemonicToHDSeed;\n/**\n * Validate Mnemonic\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns true for valid mnemonic\n */\nasync function mnemonicValidate(mnemonicArray, password) {\n    // Normalize\n    mnemonicArray = normalizeMnemonic(mnemonicArray);\n    // Validate mnemonic words\n    for (let word of mnemonicArray) {\n        if (wordlist_1.wordlist.indexOf(word) < 0) {\n            return false;\n        }\n    }\n    // Check password\n    if (password && password.length > 0) {\n        if (!await isPasswordNeeded(mnemonicArray)) {\n            return false;\n        }\n    }\n    // Validate seed\n    return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));\n}\nexports.mnemonicValidate = mnemonicValidate;\n/**\n * Generate new Mnemonic\n * @param wordsCount number of words to generate\n * @param password mnemonic password\n * @returns\n */\nasync function mnemonicNew(wordsCount = 24, password) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L159\n    let mnemonicArray = [];\n    while (true) {\n        // Regenerate new mnemonics\n        mnemonicArray = [];\n        for (let i = 0; i < wordsCount; i++) {\n            let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);\n            mnemonicArray.push(wordlist_1.wordlist[ind]);\n        }\n        // Chek password conformance\n        if (password && password.length > 0) {\n            if (!await isPasswordNeeded(mnemonicArray)) {\n                continue;\n            }\n        }\n        // Check if basic seed correct\n        if (!(await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password)))) {\n            continue;\n        }\n        break;\n    }\n    return mnemonicArray;\n}\nexports.mnemonicNew = mnemonicNew;\n/**\n * Converts bytes to mnemonics array (could be invalid for TON)\n * @param src source buffer\n * @param wordsCount number of words\n */\nfunction bytesToMnemonicIndexes(src, wordsCount) {\n    let bits = (0, binary_1.bytesToBits)(src);\n    let indexes = [];\n    for (let i = 0; i < wordsCount; i++) {\n        let sl = bits.slice(i * 11, i * 11 + 11);\n        indexes.push(parseInt(sl, 2));\n    }\n    return indexes;\n}\nexports.bytesToMnemonicIndexes = bytesToMnemonicIndexes;\nfunction bytesToMnemonics(src, wordsCount) {\n    let mnemonics = bytesToMnemonicIndexes(src, wordsCount);\n    let res = [];\n    for (let m of mnemonics) {\n        res.push(wordlist_1.wordlist[m]);\n    }\n    return res;\n}\nexports.bytesToMnemonics = bytesToMnemonics;\n/**\n * Converts mnemonics indexes to buffer with zero padding in the end\n * @param src source indexes\n * @returns Buffer\n */\nfunction mnemonicIndexesToBytes(src) {\n    let res = '';\n    for (let s of src) {\n        if (!Number.isSafeInteger(s)) {\n            throw Error('Invalid input');\n        }\n        if (s < 0 || s >= 2028) {\n            throw Error('Invalid input');\n        }\n        res += (0, binary_1.lpad)(s.toString(2), '0', 11);\n    }\n    while (res.length % 8 !== 0) {\n        res = res + '0';\n    }\n    return (0, binary_1.bitsToBytes)(res);\n}\nexports.mnemonicIndexesToBytes = mnemonicIndexesToBytes;\n/**\n * Generates deterministically mnemonics\n * @param seed\n * @param wordsCount\n * @param password\n */\nasync function mnemonicFromRandomSeed(seed, wordsCount = 24, password) {\n    const bytesLength = Math.ceil(wordsCount * 11 / 8);\n    let currentSeed = seed;\n    while (true) {\n        // Create entropy\n        let entropy = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(currentSeed, 'TON mnemonic seed', Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), bytesLength);\n        // Create mnemonics\n        let mnemonics = bytesToMnemonics(entropy, wordsCount);\n        // Check if mnemonics are valid\n        if (await mnemonicValidate(mnemonics, password)) {\n            return mnemonics;\n        }\n        currentSeed = entropy;\n    }\n}\nexports.mnemonicFromRandomSeed = mnemonicFromRandomSeed;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}