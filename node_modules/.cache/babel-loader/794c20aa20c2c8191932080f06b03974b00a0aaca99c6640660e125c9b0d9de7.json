{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRepr = exports.getBitsDescriptor = exports.getRefsDescriptor = void 0;\nconst CellType_1 = require(\"../CellType\");\nconst paddedBits_1 = require(\"../utils/paddedBits\");\nfunction getRefsDescriptor(refs, levelMask, type) {\n  return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + levelMask * 32;\n}\nexports.getRefsDescriptor = getRefsDescriptor;\nfunction getBitsDescriptor(bits) {\n  let len = bits.length;\n  return Math.ceil(len / 8) + Math.floor(len / 8);\n}\nexports.getBitsDescriptor = getBitsDescriptor;\nfunction getRepr(originalBits, bits, refs, level, levelMask, type) {\n  // Allocate\n  const bitsLen = Math.ceil(bits.length / 8);\n  const repr = Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);\n  // Write descriptors\n  let reprCursor = 0;\n  repr[reprCursor++] = getRefsDescriptor(refs, levelMask, type);\n  repr[reprCursor++] = getBitsDescriptor(originalBits);\n  // Write bits\n  (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);\n  reprCursor += bitsLen;\n  // Write refs\n  for (const c of refs) {\n    let childDepth;\n    if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {\n      childDepth = c.depth(level + 1);\n    } else {\n      childDepth = c.depth(level);\n    }\n    repr[reprCursor++] = Math.floor(childDepth / 256);\n    repr[reprCursor++] = childDepth % 256;\n  }\n  for (const c of refs) {\n    let childHash;\n    if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {\n      childHash = c.hash(level + 1);\n    } else {\n      childHash = c.hash(level);\n    }\n    childHash.copy(repr, reprCursor);\n    reprCursor += 32;\n  }\n  // Result\n  return repr;\n}\nexports.getRepr = getRepr;","map":{"version":3,"names":["Object","defineProperty","exports","value","getRepr","getBitsDescriptor","getRefsDescriptor","CellType_1","require","paddedBits_1","refs","levelMask","type","length","CellType","Ordinary","bits","len","Math","ceil","floor","originalBits","level","bitsLen","repr","Buffer","alloc","reprCursor","bitsToPaddedBuffer","copy","c","childDepth","MerkleProof","MerkleUpdate","depth","childHash","hash"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/boc/cell/descriptor.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRepr = exports.getBitsDescriptor = exports.getRefsDescriptor = void 0;\nconst CellType_1 = require(\"../CellType\");\nconst paddedBits_1 = require(\"../utils/paddedBits\");\nfunction getRefsDescriptor(refs, levelMask, type) {\n    return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + levelMask * 32;\n}\nexports.getRefsDescriptor = getRefsDescriptor;\nfunction getBitsDescriptor(bits) {\n    let len = bits.length;\n    return Math.ceil(len / 8) + Math.floor(len / 8);\n}\nexports.getBitsDescriptor = getBitsDescriptor;\nfunction getRepr(originalBits, bits, refs, level, levelMask, type) {\n    // Allocate\n    const bitsLen = Math.ceil(bits.length / 8);\n    const repr = Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);\n    // Write descriptors\n    let reprCursor = 0;\n    repr[reprCursor++] = getRefsDescriptor(refs, levelMask, type);\n    repr[reprCursor++] = getBitsDescriptor(originalBits);\n    // Write bits\n    (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);\n    reprCursor += bitsLen;\n    // Write refs\n    for (const c of refs) {\n        let childDepth;\n        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {\n            childDepth = c.depth(level + 1);\n        }\n        else {\n            childDepth = c.depth(level);\n        }\n        repr[reprCursor++] = Math.floor(childDepth / 256);\n        repr[reprCursor++] = childDepth % 256;\n    }\n    for (const c of refs) {\n        let childHash;\n        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {\n            childHash = c.hash(level + 1);\n        }\n        else {\n            childHash = c.hash(level);\n        }\n        childHash.copy(repr, reprCursor);\n        reprCursor += 32;\n    }\n    // Result\n    return repr;\n}\nexports.getRepr = getRepr;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}