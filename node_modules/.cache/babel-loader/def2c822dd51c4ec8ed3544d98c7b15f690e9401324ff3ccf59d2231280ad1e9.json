{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wonderCalculator = void 0;\nconst BitString_1 = require(\"../BitString\");\nconst CellType_1 = require(\"../CellType\");\nconst LevelMask_1 = require(\"./LevelMask\");\nconst exoticPruned_1 = require(\"./exoticPruned\");\nconst exoticMerkleProof_1 = require(\"./exoticMerkleProof\");\nconst descriptor_1 = require(\"./descriptor\");\nconst crypto_1 = require(\"@ton/crypto\");\nconst exoticMerkleUpdate_1 = require(\"./exoticMerkleUpdate\");\nconst exoticLibrary_1 = require(\"./exoticLibrary\");\n//\n// This function replicates unknown logic of resolving cell data\n// https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/vm/cells/DataCell.cpp#L214\n//\nfunction wonderCalculator(type, bits, refs) {\n  //\n  // Resolving level mask\n  //\n  let levelMask;\n  let pruned = null;\n  if (type === CellType_1.CellType.Ordinary) {\n    let mask = 0;\n    for (let r of refs) {\n      mask = mask | r.mask.value;\n    }\n    levelMask = new LevelMask_1.LevelMask(mask);\n  } else if (type === CellType_1.CellType.PrunedBranch) {\n    // Parse pruned\n    pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);\n    // Load level\n    levelMask = new LevelMask_1.LevelMask(pruned.mask);\n  } else if (type === CellType_1.CellType.MerkleProof) {\n    // Parse proof\n    let loaded = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);\n    // Load level\n    levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);\n  } else if (type === CellType_1.CellType.MerkleUpdate) {\n    // Parse update\n    let loaded = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);\n    // Load level\n    levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);\n  } else if (type === CellType_1.CellType.Library) {\n    // Parse library\n    let loaded = (0, exoticLibrary_1.exoticLibrary)(bits, refs);\n    // Load level\n    levelMask = new LevelMask_1.LevelMask();\n  } else {\n    throw new Error(\"Unsupported exotic type\");\n  }\n  //\n  // Calculate hashes and depths\n  // NOTE: https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/vm/cells/DataCell.cpp#L214\n  //\n  let depths = [];\n  let hashes = [];\n  let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;\n  let totalHashCount = levelMask.hashCount;\n  let hashIOffset = totalHashCount - hashCount;\n  for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {\n    if (!levelMask.isSignificant(levelI)) {\n      continue;\n    }\n    if (hashI < hashIOffset) {\n      hashI++;\n      continue;\n    }\n    //\n    // Bits\n    //\n    let currentBits;\n    if (hashI === hashIOffset) {\n      if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {\n        throw Error('Invalid');\n      }\n      currentBits = bits;\n    } else {\n      if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {\n        throw Error('Invalid: ' + levelI + ', ' + type);\n      }\n      currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);\n    }\n    //\n    // Depth\n    //\n    let currentDepth = 0;\n    for (let c of refs) {\n      let childDepth;\n      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {\n        childDepth = c.depth(levelI + 1);\n      } else {\n        childDepth = c.depth(levelI);\n      }\n      currentDepth = Math.max(currentDepth, childDepth);\n    }\n    if (refs.length > 0) {\n      currentDepth++;\n    }\n    //\n    // Hash\n    //\n    let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, levelMask.apply(levelI).value, type);\n    let hash = (0, crypto_1.sha256_sync)(repr);\n    //\n    // Persist next\n    //\n    let destI = hashI - hashIOffset;\n    depths[destI] = currentDepth;\n    hashes[destI] = hash;\n    //\n    // Next\n    //\n    hashI++;\n  }\n  //\n  // Calculate hash and depth for all levels\n  //\n  let resolvedHashes = [];\n  let resolvedDepths = [];\n  if (pruned) {\n    for (let i = 0; i < 4; i++) {\n      const {\n        hashIndex\n      } = levelMask.apply(i);\n      const {\n        hashIndex: thisHashIndex\n      } = levelMask;\n      if (hashIndex !== thisHashIndex) {\n        resolvedHashes.push(pruned.pruned[hashIndex].hash);\n        resolvedDepths.push(pruned.pruned[hashIndex].depth);\n      } else {\n        resolvedHashes.push(hashes[0]);\n        resolvedDepths.push(depths[0]);\n      }\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);\n      resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);\n    }\n  }\n  //\n  // Result\n  //\n  return {\n    mask: levelMask,\n    hashes: resolvedHashes,\n    depths: resolvedDepths\n  };\n}\nexports.wonderCalculator = wonderCalculator;","map":{"version":3,"names":["Object","defineProperty","exports","value","wonderCalculator","BitString_1","require","CellType_1","LevelMask_1","exoticPruned_1","exoticMerkleProof_1","descriptor_1","crypto_1","exoticMerkleUpdate_1","exoticLibrary_1","type","bits","refs","levelMask","pruned","CellType","Ordinary","mask","r","LevelMask","PrunedBranch","exoticPruned","MerkleProof","loaded","exoticMerkleProof","MerkleUpdate","exoticMerkleUpdate","Library","exoticLibrary","Error","depths","hashes","hashCount","totalHashCount","hashIOffset","levelI","hashI","level","isSignificant","currentBits","BitString","currentDepth","c","childDepth","depth","Math","max","length","repr","getRepr","apply","hash","sha256_sync","destI","resolvedHashes","resolvedDepths","i","hashIndex","thisHashIndex","push"],"sources":["C:/Users/adams/Downloads/GLL/slotpot/node_modules/@ton/core/dist/boc/cell/wonderCalculator.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wonderCalculator = void 0;\nconst BitString_1 = require(\"../BitString\");\nconst CellType_1 = require(\"../CellType\");\nconst LevelMask_1 = require(\"./LevelMask\");\nconst exoticPruned_1 = require(\"./exoticPruned\");\nconst exoticMerkleProof_1 = require(\"./exoticMerkleProof\");\nconst descriptor_1 = require(\"./descriptor\");\nconst crypto_1 = require(\"@ton/crypto\");\nconst exoticMerkleUpdate_1 = require(\"./exoticMerkleUpdate\");\nconst exoticLibrary_1 = require(\"./exoticLibrary\");\n//\n// This function replicates unknown logic of resolving cell data\n// https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/vm/cells/DataCell.cpp#L214\n//\nfunction wonderCalculator(type, bits, refs) {\n    //\n    // Resolving level mask\n    //\n    let levelMask;\n    let pruned = null;\n    if (type === CellType_1.CellType.Ordinary) {\n        let mask = 0;\n        for (let r of refs) {\n            mask = mask | r.mask.value;\n        }\n        levelMask = new LevelMask_1.LevelMask(mask);\n    }\n    else if (type === CellType_1.CellType.PrunedBranch) {\n        // Parse pruned\n        pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);\n        // Load level\n        levelMask = new LevelMask_1.LevelMask(pruned.mask);\n    }\n    else if (type === CellType_1.CellType.MerkleProof) {\n        // Parse proof\n        let loaded = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);\n        // Load level\n        levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);\n    }\n    else if (type === CellType_1.CellType.MerkleUpdate) {\n        // Parse update\n        let loaded = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);\n        // Load level\n        levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);\n    }\n    else if (type === CellType_1.CellType.Library) {\n        // Parse library\n        let loaded = (0, exoticLibrary_1.exoticLibrary)(bits, refs);\n        // Load level\n        levelMask = new LevelMask_1.LevelMask();\n    }\n    else {\n        throw new Error(\"Unsupported exotic type\");\n    }\n    //\n    // Calculate hashes and depths\n    // NOTE: https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/vm/cells/DataCell.cpp#L214\n    //\n    let depths = [];\n    let hashes = [];\n    let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;\n    let totalHashCount = levelMask.hashCount;\n    let hashIOffset = totalHashCount - hashCount;\n    for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {\n        if (!levelMask.isSignificant(levelI)) {\n            continue;\n        }\n        if (hashI < hashIOffset) {\n            hashI++;\n            continue;\n        }\n        //\n        // Bits\n        //\n        let currentBits;\n        if (hashI === hashIOffset) {\n            if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {\n                throw Error('Invalid');\n            }\n            currentBits = bits;\n        }\n        else {\n            if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {\n                throw Error('Invalid: ' + levelI + ', ' + type);\n            }\n            currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);\n        }\n        //\n        // Depth\n        //\n        let currentDepth = 0;\n        for (let c of refs) {\n            let childDepth;\n            if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {\n                childDepth = c.depth(levelI + 1);\n            }\n            else {\n                childDepth = c.depth(levelI);\n            }\n            currentDepth = Math.max(currentDepth, childDepth);\n        }\n        if (refs.length > 0) {\n            currentDepth++;\n        }\n        //\n        // Hash\n        //\n        let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, levelMask.apply(levelI).value, type);\n        let hash = (0, crypto_1.sha256_sync)(repr);\n        //\n        // Persist next\n        //\n        let destI = hashI - hashIOffset;\n        depths[destI] = currentDepth;\n        hashes[destI] = hash;\n        //\n        // Next\n        //\n        hashI++;\n    }\n    //\n    // Calculate hash and depth for all levels\n    //\n    let resolvedHashes = [];\n    let resolvedDepths = [];\n    if (pruned) {\n        for (let i = 0; i < 4; i++) {\n            const { hashIndex } = levelMask.apply(i);\n            const { hashIndex: thisHashIndex } = levelMask;\n            if (hashIndex !== thisHashIndex) {\n                resolvedHashes.push(pruned.pruned[hashIndex].hash);\n                resolvedDepths.push(pruned.pruned[hashIndex].depth);\n            }\n            else {\n                resolvedHashes.push(hashes[0]);\n                resolvedDepths.push(depths[0]);\n            }\n        }\n    }\n    else {\n        for (let i = 0; i < 4; i++) {\n            resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);\n            resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);\n        }\n    }\n    //\n    // Result\n    //\n    return {\n        mask: levelMask,\n        hashes: resolvedHashes,\n        depths: resolvedDepths\n    };\n}\nexports.wonderCalculator = wonderCalculator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}