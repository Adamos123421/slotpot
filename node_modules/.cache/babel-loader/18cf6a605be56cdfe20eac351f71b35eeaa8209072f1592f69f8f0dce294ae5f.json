{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TonClient = void 0;\nconst HttpApi_1 = require(\"./api/HttpApi\");\nconst core_1 = require(\"@ton/core\");\nclass TonClient {\n  constructor(parameters) {\n    this.parameters = {\n      endpoint: parameters.endpoint\n    };\n    this.api = new HttpApi_1.HttpApi(this.parameters.endpoint, {\n      timeout: parameters.timeout,\n      apiKey: parameters.apiKey,\n      adapter: parameters.httpAdapter\n    });\n  }\n  /**\n   * Get Address Balance\n   * @param address address for balance check\n   * @returns balance\n   */\n  async getBalance(address) {\n    return (await this.getContractState(address)).balance;\n  }\n  /**\n   * Invoke get method\n   * @param address contract address\n   * @param name name of method\n   * @param params optional parameters\n   * @returns stack and gas_used field\n   */\n  async runMethod(address, name, stack = []) {\n    let res = await this.api.callGetMethod(address, name, stack);\n    if (res.exit_code !== 0) {\n      throw Error('Unable to execute get method. Got exit_code: ' + res.exit_code);\n    }\n    return {\n      gas_used: res.gas_used,\n      stack: parseStack(res.stack)\n    };\n  }\n  /**\n   * Invoke get method\n   * @param address contract address\n   * @param name name of method\n   * @param params optional parameters\n   * @returns stack and gas_used field\n   * @deprecated use runMethod instead\n   */\n  async callGetMethod(address, name, stack = []) {\n    return this.runMethod(address, name, stack);\n  }\n  /**\n   * Invoke get method that returns error code instead of throwing error\n   * @param address contract address\n   * @param name name of method\n   * @param params optional parameters\n   * @returns stack and gas_used field\n  */\n  async runMethodWithError(address, name, params = []) {\n    let res = await this.api.callGetMethod(address, name, params);\n    return {\n      gas_used: res.gas_used,\n      stack: parseStack(res.stack),\n      exit_code: res.exit_code\n    };\n  }\n  /**\n   * Invoke get method that returns error code instead of throwing error\n   * @param address contract address\n   * @param name name of method\n   * @param params optional parameters\n   * @returns stack and gas_used field\n   * @deprecated use runMethodWithError instead\n   */\n  async callGetMethodWithError(address, name, stack = []) {\n    return this.runMethodWithError(address, name, stack);\n  }\n  /**\n   * Get transactions\n   * @param address address\n   */\n  async getTransactions(address, opts) {\n    // Fetch transactions\n    let tx = await this.api.getTransactions(address, opts);\n    let res = [];\n    for (let r of tx) {\n      res.push((0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(r.data, 'base64'))[0].beginParse()));\n    }\n    return res;\n  }\n  /**\n   * Get transaction by it's id\n   * @param address address\n   * @param lt logical time\n   * @param hash transaction hash\n   * @returns transaction or null if not exist\n   */\n  async getTransaction(address, lt, hash) {\n    let res = await this.api.getTransaction(address, lt, hash);\n    if (res) {\n      return (0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(res.data, 'base64'))[0].beginParse());\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Locate outcoming transaction of destination address by incoming message\n   * @param source message source address\n   * @param destination message destination address\n   * @param created_lt message's created lt\n   * @returns transaction\n   */\n  async tryLocateResultTx(source, destination, created_lt) {\n    let res = await this.api.tryLocateResultTx(source, destination, created_lt);\n    return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());\n  }\n  /**\n   * Locate incoming transaction of source address by outcoming message\n   * @param source message source address\n   * @param destination message destination address\n   * @param created_lt message's created lt\n   * @returns transaction\n   */\n  async tryLocateSourceTx(source, destination, created_lt) {\n    let res = await this.api.tryLocateSourceTx(source, destination, created_lt);\n    return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());\n  }\n  /**\n   * Fetch latest masterchain info\n   * @returns masterchain info\n   */\n  async getMasterchainInfo() {\n    let r = await this.api.getMasterchainInfo();\n    return {\n      workchain: r.init.workchain,\n      shard: r.last.shard,\n      initSeqno: r.init.seqno,\n      latestSeqno: r.last.seqno\n    };\n  }\n  /**\n   * Fetch latest workchain shards\n   * @param seqno masterchain seqno\n   */\n  async getWorkchainShards(seqno) {\n    let r = await this.api.getShards(seqno);\n    return r.map(m => ({\n      workchain: m.workchain,\n      shard: m.shard,\n      seqno: m.seqno\n    }));\n  }\n  /**\n   * Fetch transactions inf shards\n   * @param workchain\n   * @param seqno\n   * @param shard\n   */\n  async getShardTransactions(workchain, seqno, shard) {\n    let tx = await this.api.getBlockTransactions(workchain, seqno, shard);\n    if (tx.incomplete) {\n      throw Error('Unsupported');\n    }\n    return tx.transactions.map(v => ({\n      account: core_1.Address.parseRaw(v.account),\n      lt: v.lt,\n      hash: v.hash\n    }));\n  }\n  /**\n   * Send message to a network\n   * @param src source message\n   */\n  async sendMessage(src) {\n    const boc = (0, core_1.beginCell)().store((0, core_1.storeMessage)(src)).endCell().toBoc();\n    await this.api.sendBoc(boc);\n  }\n  /**\n   * Send file to a network\n   * @param src source file\n   */\n  async sendFile(src) {\n    await this.api.sendBoc(src);\n  }\n  /**\n   * Estimate fees for external message\n   * @param address target address\n   * @returns\n   */\n  async estimateExternalMessageFee(address, args) {\n    return await this.api.estimateFee(address, {\n      body: args.body,\n      initCode: args.initCode,\n      initData: args.initData,\n      ignoreSignature: args.ignoreSignature\n    });\n  }\n  /**\n   * Send external message to contract\n   * @param contract contract to send message\n   * @param src message body\n   */\n  async sendExternalMessage(contract, src) {\n    if ((await this.isContractDeployed(contract.address)) || !contract.init) {\n      const message = (0, core_1.external)({\n        to: contract.address,\n        body: src\n      });\n      await this.sendMessage(message);\n    } else {\n      const message = (0, core_1.external)({\n        to: contract.address,\n        init: contract.init,\n        body: src\n      });\n      await this.sendMessage(message);\n    }\n  }\n  /**\n   * Check if contract is deployed\n   * @param address addres to check\n   * @returns true if contract is in active state\n   */\n  async isContractDeployed(address) {\n    return (await this.getContractState(address)).state === 'active';\n  }\n  /**\n   * Resolves contract state\n   * @param address contract address\n   */\n  async getContractState(address) {\n    let info = await this.api.getAddressInformation(address);\n    let balance = BigInt(info.balance);\n    let state = info.state;\n    return {\n      balance,\n      state,\n      code: info.code !== '' ? Buffer.from(info.code, 'base64') : null,\n      data: info.data !== '' ? Buffer.from(info.data, 'base64') : null,\n      lastTransaction: info.last_transaction_id.lt !== '0' ? {\n        lt: info.last_transaction_id.lt,\n        hash: info.last_transaction_id.hash\n      } : null,\n      blockId: {\n        workchain: info.block_id.workchain,\n        shard: info.block_id.shard,\n        seqno: info.block_id.seqno\n      },\n      timestampt: info.sync_utime\n    };\n  }\n  /**\n   * Open contract\n   * @param src source contract\n   * @returns contract\n   */\n  open(src) {\n    return (0, core_1.openContract)(src, args => createProvider(this, args.address, args.init));\n  }\n  /**\n   * Create a provider\n   * @param address address\n   * @param init optional init\n   * @returns provider\n   */\n  provider(address, init) {\n    return createProvider(this, address, init ?? null);\n  }\n}\nexports.TonClient = TonClient;\nfunction parseStackEntry(s) {\n  switch (s[\"@type\"]) {\n    case \"tvm.stackEntryNumber\":\n      return {\n        type: 'int',\n        value: BigInt(s.number.number)\n      };\n    case \"tvm.stackEntryCell\":\n      return {\n        type: 'cell',\n        cell: core_1.Cell.fromBase64(s.cell)\n      };\n    case 'tvm.stackEntryTuple':\n      return {\n        type: 'tuple',\n        items: s.tuple.elements.map(parseStackEntry)\n      };\n    case 'tvm.stackEntryList':\n      return {\n        type: 'list',\n        items: s.list.elements.map(parseStackEntry)\n      };\n    default:\n      throw Error(\"Unsupported item type: \" + s[\"@type\"]);\n  }\n}\nfunction parseStackItem(s) {\n  if (s[0] === 'num') {\n    let val = s[1];\n    if (val.startsWith('-')) {\n      return {\n        type: 'int',\n        value: -BigInt(val.slice(1))\n      };\n    } else {\n      return {\n        type: 'int',\n        value: BigInt(val)\n      };\n    }\n  } else if (s[0] === 'null') {\n    return {\n      type: 'null'\n    };\n  } else if (s[0] === 'cell') {\n    return {\n      type: 'cell',\n      cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, 'base64'))[0]\n    };\n  } else if (s[0] === 'slice') {\n    return {\n      type: 'slice',\n      cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, 'base64'))[0]\n    };\n  } else if (s[0] === 'builder') {\n    return {\n      type: 'builder',\n      cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, 'base64'))[0]\n    };\n  } else if (s[0] === 'tuple' || s[0] === 'list') {\n    // toncenter.com missbehaviour\n    if (s[1].elements.length === 0) {\n      return {\n        type: 'null'\n      };\n    }\n    return {\n      type: s[0],\n      items: s[1].elements.map(parseStackEntry)\n    };\n  } else {\n    throw Error('Unsupported stack item type: ' + s[0]);\n  }\n}\nfunction parseStack(src) {\n  let stack = [];\n  for (let s of src) {\n    stack.push(parseStackItem(s));\n  }\n  return new core_1.TupleReader(stack);\n}\nfunction createProvider(client, address, init) {\n  return {\n    async getState() {\n      let state = await client.getContractState(address);\n      let balance = state.balance;\n      let last = state.lastTransaction ? {\n        lt: BigInt(state.lastTransaction.lt),\n        hash: Buffer.from(state.lastTransaction.hash, 'base64')\n      } : null;\n      let storage;\n      if (state.state === 'active') {\n        storage = {\n          type: 'active',\n          code: state.code ? state.code : null,\n          data: state.data ? state.data : null\n        };\n      } else if (state.state === 'uninitialized') {\n        storage = {\n          type: 'uninit'\n        };\n      } else if (state.state === 'frozen') {\n        storage = {\n          type: 'frozen',\n          stateHash: Buffer.alloc(0)\n        };\n      } else {\n        throw Error('Unsupported state');\n      }\n      return {\n        balance,\n        last,\n        state: storage\n      };\n    },\n    async get(name, args) {\n      let method = await client.callGetMethod(address, name, args);\n      return {\n        stack: method.stack\n      };\n    },\n    async external(message) {\n      //\n      // Resolve init\n      //\n      let neededInit = null;\n      if (init && !(await client.isContractDeployed(address))) {\n        neededInit = init;\n      }\n      //\n      // Send package\n      //\n      const ext = (0, core_1.external)({\n        to: address,\n        init: neededInit,\n        body: message\n      });\n      let boc = (0, core_1.beginCell)().store((0, core_1.storeMessage)(ext)).endCell().toBoc();\n      await client.sendFile(boc);\n    },\n    async internal(via, message) {\n      // Resolve init\n      let neededInit = null;\n      if (init && !(await client.isContractDeployed(address))) {\n        neededInit = init;\n      }\n      // Resolve bounce\n      let bounce = true;\n      if (message.bounce !== null && message.bounce !== undefined) {\n        bounce = message.bounce;\n      }\n      // Resolve value\n      let value;\n      if (typeof message.value === 'string') {\n        value = (0, core_1.toNano)(message.value);\n      } else {\n        value = message.value;\n      }\n      // Resolve body\n      let body = null;\n      if (typeof message.body === 'string') {\n        body = (0, core_1.comment)(message.body);\n      } else if (message.body) {\n        body = message.body;\n      }\n      // Send internal message\n      await via.send({\n        to: address,\n        value,\n        bounce,\n        sendMode: message.sendMode,\n        init: neededInit,\n        body\n      });\n    },\n    open(contract) {\n      return (0, core_1.openContract)(contract, args => createProvider(client, args.address, args.init ?? null));\n    },\n    getTransactions(address, lt, hash, limit) {\n      return client.getTransactions(address, {\n        limit: limit ?? 100,\n        lt: lt.toString(),\n        hash: hash.toString('base64'),\n        inclusive: true\n      });\n    }\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TonClient","HttpApi_1","require","core_1","constructor","parameters","endpoint","api","HttpApi","timeout","apiKey","adapter","httpAdapter","getBalance","address","getContractState","balance","runMethod","name","stack","res","callGetMethod","exit_code","Error","gas_used","parseStack","runMethodWithError","params","callGetMethodWithError","getTransactions","opts","tx","r","push","loadTransaction","Cell","fromBoc","Buffer","from","data","beginParse","getTransaction","lt","hash","tryLocateResultTx","source","destination","created_lt","fromBase64","tryLocateSourceTx","getMasterchainInfo","workchain","init","shard","last","initSeqno","seqno","latestSeqno","getWorkchainShards","getShards","map","m","getShardTransactions","getBlockTransactions","incomplete","transactions","v","account","Address","parseRaw","sendMessage","src","boc","beginCell","store","storeMessage","endCell","toBoc","sendBoc","sendFile","estimateExternalMessageFee","args","estimateFee","body","initCode","initData","ignoreSignature","sendExternalMessage","contract","isContractDeployed","message","external","to","state","info","getAddressInformation","BigInt","code","lastTransaction","last_transaction_id","blockId","block_id","timestampt","sync_utime","open","openContract","createProvider","provider","parseStackEntry","s","type","number","cell","items","tuple","elements","list","parseStackItem","val","startsWith","slice","bytes","length","TupleReader","client","getState","storage","stateHash","alloc","get","method","neededInit","ext","internal","via","bounce","undefined","toNano","comment","send","sendMode","limit","toString","inclusive"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/ton/dist/client/TonClient.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TonClient = void 0;\nconst HttpApi_1 = require(\"./api/HttpApi\");\nconst core_1 = require(\"@ton/core\");\nclass TonClient {\n    constructor(parameters) {\n        this.parameters = {\n            endpoint: parameters.endpoint\n        };\n        this.api = new HttpApi_1.HttpApi(this.parameters.endpoint, {\n            timeout: parameters.timeout,\n            apiKey: parameters.apiKey,\n            adapter: parameters.httpAdapter\n        });\n    }\n    /**\n     * Get Address Balance\n     * @param address address for balance check\n     * @returns balance\n     */\n    async getBalance(address) {\n        return (await this.getContractState(address)).balance;\n    }\n    /**\n     * Invoke get method\n     * @param address contract address\n     * @param name name of method\n     * @param params optional parameters\n     * @returns stack and gas_used field\n     */\n    async runMethod(address, name, stack = []) {\n        let res = await this.api.callGetMethod(address, name, stack);\n        if (res.exit_code !== 0) {\n            throw Error('Unable to execute get method. Got exit_code: ' + res.exit_code);\n        }\n        return { gas_used: res.gas_used, stack: parseStack(res.stack) };\n    }\n    /**\n     * Invoke get method\n     * @param address contract address\n     * @param name name of method\n     * @param params optional parameters\n     * @returns stack and gas_used field\n     * @deprecated use runMethod instead\n     */\n    async callGetMethod(address, name, stack = []) {\n        return this.runMethod(address, name, stack);\n    }\n    /**\n     * Invoke get method that returns error code instead of throwing error\n     * @param address contract address\n     * @param name name of method\n     * @param params optional parameters\n     * @returns stack and gas_used field\n    */\n    async runMethodWithError(address, name, params = []) {\n        let res = await this.api.callGetMethod(address, name, params);\n        return { gas_used: res.gas_used, stack: parseStack(res.stack), exit_code: res.exit_code };\n    }\n    /**\n     * Invoke get method that returns error code instead of throwing error\n     * @param address contract address\n     * @param name name of method\n     * @param params optional parameters\n     * @returns stack and gas_used field\n     * @deprecated use runMethodWithError instead\n     */\n    async callGetMethodWithError(address, name, stack = []) {\n        return this.runMethodWithError(address, name, stack);\n    }\n    /**\n     * Get transactions\n     * @param address address\n     */\n    async getTransactions(address, opts) {\n        // Fetch transactions\n        let tx = await this.api.getTransactions(address, opts);\n        let res = [];\n        for (let r of tx) {\n            res.push((0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(r.data, 'base64'))[0].beginParse()));\n        }\n        return res;\n    }\n    /**\n     * Get transaction by it's id\n     * @param address address\n     * @param lt logical time\n     * @param hash transaction hash\n     * @returns transaction or null if not exist\n     */\n    async getTransaction(address, lt, hash) {\n        let res = await this.api.getTransaction(address, lt, hash);\n        if (res) {\n            return (0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(res.data, 'base64'))[0].beginParse());\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Locate outcoming transaction of destination address by incoming message\n     * @param source message source address\n     * @param destination message destination address\n     * @param created_lt message's created lt\n     * @returns transaction\n     */\n    async tryLocateResultTx(source, destination, created_lt) {\n        let res = await this.api.tryLocateResultTx(source, destination, created_lt);\n        return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());\n    }\n    /**\n     * Locate incoming transaction of source address by outcoming message\n     * @param source message source address\n     * @param destination message destination address\n     * @param created_lt message's created lt\n     * @returns transaction\n     */\n    async tryLocateSourceTx(source, destination, created_lt) {\n        let res = await this.api.tryLocateSourceTx(source, destination, created_lt);\n        return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());\n    }\n    /**\n     * Fetch latest masterchain info\n     * @returns masterchain info\n     */\n    async getMasterchainInfo() {\n        let r = await this.api.getMasterchainInfo();\n        return {\n            workchain: r.init.workchain,\n            shard: r.last.shard,\n            initSeqno: r.init.seqno,\n            latestSeqno: r.last.seqno\n        };\n    }\n    /**\n     * Fetch latest workchain shards\n     * @param seqno masterchain seqno\n     */\n    async getWorkchainShards(seqno) {\n        let r = await this.api.getShards(seqno);\n        return r.map((m) => ({\n            workchain: m.workchain,\n            shard: m.shard,\n            seqno: m.seqno\n        }));\n    }\n    /**\n     * Fetch transactions inf shards\n     * @param workchain\n     * @param seqno\n     * @param shard\n     */\n    async getShardTransactions(workchain, seqno, shard) {\n        let tx = await this.api.getBlockTransactions(workchain, seqno, shard);\n        if (tx.incomplete) {\n            throw Error('Unsupported');\n        }\n        return tx.transactions.map((v) => ({\n            account: core_1.Address.parseRaw(v.account),\n            lt: v.lt,\n            hash: v.hash\n        }));\n    }\n    /**\n     * Send message to a network\n     * @param src source message\n     */\n    async sendMessage(src) {\n        const boc = (0, core_1.beginCell)()\n            .store((0, core_1.storeMessage)(src))\n            .endCell()\n            .toBoc();\n        await this.api.sendBoc(boc);\n    }\n    /**\n     * Send file to a network\n     * @param src source file\n     */\n    async sendFile(src) {\n        await this.api.sendBoc(src);\n    }\n    /**\n     * Estimate fees for external message\n     * @param address target address\n     * @returns\n     */\n    async estimateExternalMessageFee(address, args) {\n        return await this.api.estimateFee(address, { body: args.body, initCode: args.initCode, initData: args.initData, ignoreSignature: args.ignoreSignature });\n    }\n    /**\n     * Send external message to contract\n     * @param contract contract to send message\n     * @param src message body\n     */\n    async sendExternalMessage(contract, src) {\n        if (await this.isContractDeployed(contract.address) || !contract.init) {\n            const message = (0, core_1.external)({\n                to: contract.address,\n                body: src\n            });\n            await this.sendMessage(message);\n        }\n        else {\n            const message = (0, core_1.external)({\n                to: contract.address,\n                init: contract.init,\n                body: src\n            });\n            await this.sendMessage(message);\n        }\n    }\n    /**\n     * Check if contract is deployed\n     * @param address addres to check\n     * @returns true if contract is in active state\n     */\n    async isContractDeployed(address) {\n        return (await this.getContractState(address)).state === 'active';\n    }\n    /**\n     * Resolves contract state\n     * @param address contract address\n     */\n    async getContractState(address) {\n        let info = await this.api.getAddressInformation(address);\n        let balance = BigInt(info.balance);\n        let state = info.state;\n        return {\n            balance,\n            state,\n            code: info.code !== '' ? Buffer.from(info.code, 'base64') : null,\n            data: info.data !== '' ? Buffer.from(info.data, 'base64') : null,\n            lastTransaction: info.last_transaction_id.lt !== '0' ? {\n                lt: info.last_transaction_id.lt,\n                hash: info.last_transaction_id.hash,\n            } : null,\n            blockId: {\n                workchain: info.block_id.workchain,\n                shard: info.block_id.shard,\n                seqno: info.block_id.seqno\n            },\n            timestampt: info.sync_utime\n        };\n    }\n    /**\n     * Open contract\n     * @param src source contract\n     * @returns contract\n     */\n    open(src) {\n        return (0, core_1.openContract)(src, (args) => createProvider(this, args.address, args.init));\n    }\n    /**\n     * Create a provider\n     * @param address address\n     * @param init optional init\n     * @returns provider\n     */\n    provider(address, init) {\n        return createProvider(this, address, init ?? null);\n    }\n}\nexports.TonClient = TonClient;\nfunction parseStackEntry(s) {\n    switch (s[\"@type\"]) {\n        case \"tvm.stackEntryNumber\":\n            return { type: 'int', value: BigInt(s.number.number) };\n        case \"tvm.stackEntryCell\":\n            return { type: 'cell', cell: core_1.Cell.fromBase64(s.cell) };\n        case 'tvm.stackEntryTuple':\n            return { type: 'tuple', items: s.tuple.elements.map(parseStackEntry) };\n        case 'tvm.stackEntryList':\n            return { type: 'list', items: s.list.elements.map(parseStackEntry) };\n        default:\n            throw Error(\"Unsupported item type: \" + s[\"@type\"]);\n    }\n}\nfunction parseStackItem(s) {\n    if (s[0] === 'num') {\n        let val = s[1];\n        if (val.startsWith('-')) {\n            return { type: 'int', value: -BigInt(val.slice(1)) };\n        }\n        else {\n            return { type: 'int', value: BigInt(val) };\n        }\n    }\n    else if (s[0] === 'null') {\n        return { type: 'null' };\n    }\n    else if (s[0] === 'cell') {\n        return { type: 'cell', cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, 'base64'))[0] };\n    }\n    else if (s[0] === 'slice') {\n        return { type: 'slice', cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, 'base64'))[0] };\n    }\n    else if (s[0] === 'builder') {\n        return { type: 'builder', cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, 'base64'))[0] };\n    }\n    else if (s[0] === 'tuple' || s[0] === 'list') {\n        // toncenter.com missbehaviour\n        if (s[1].elements.length === 0) {\n            return { type: 'null' };\n        }\n        return {\n            type: s[0],\n            items: s[1].elements.map(parseStackEntry)\n        };\n    }\n    else {\n        throw Error('Unsupported stack item type: ' + s[0]);\n    }\n}\nfunction parseStack(src) {\n    let stack = [];\n    for (let s of src) {\n        stack.push(parseStackItem(s));\n    }\n    return new core_1.TupleReader(stack);\n}\nfunction createProvider(client, address, init) {\n    return {\n        async getState() {\n            let state = await client.getContractState(address);\n            let balance = state.balance;\n            let last = state.lastTransaction ? { lt: BigInt(state.lastTransaction.lt), hash: Buffer.from(state.lastTransaction.hash, 'base64') } : null;\n            let storage;\n            if (state.state === 'active') {\n                storage = {\n                    type: 'active',\n                    code: state.code ? state.code : null,\n                    data: state.data ? state.data : null,\n                };\n            }\n            else if (state.state === 'uninitialized') {\n                storage = {\n                    type: 'uninit',\n                };\n            }\n            else if (state.state === 'frozen') {\n                storage = {\n                    type: 'frozen',\n                    stateHash: Buffer.alloc(0),\n                };\n            }\n            else {\n                throw Error('Unsupported state');\n            }\n            return {\n                balance,\n                last,\n                state: storage,\n            };\n        },\n        async get(name, args) {\n            let method = await client.callGetMethod(address, name, args);\n            return { stack: method.stack };\n        },\n        async external(message) {\n            //\n            // Resolve init\n            //\n            let neededInit = null;\n            if (init && !await client.isContractDeployed(address)) {\n                neededInit = init;\n            }\n            //\n            // Send package\n            //\n            const ext = (0, core_1.external)({\n                to: address,\n                init: neededInit,\n                body: message\n            });\n            let boc = (0, core_1.beginCell)()\n                .store((0, core_1.storeMessage)(ext))\n                .endCell()\n                .toBoc();\n            await client.sendFile(boc);\n        },\n        async internal(via, message) {\n            // Resolve init\n            let neededInit = null;\n            if (init && (!await client.isContractDeployed(address))) {\n                neededInit = init;\n            }\n            // Resolve bounce\n            let bounce = true;\n            if (message.bounce !== null && message.bounce !== undefined) {\n                bounce = message.bounce;\n            }\n            // Resolve value\n            let value;\n            if (typeof message.value === 'string') {\n                value = (0, core_1.toNano)(message.value);\n            }\n            else {\n                value = message.value;\n            }\n            // Resolve body\n            let body = null;\n            if (typeof message.body === 'string') {\n                body = (0, core_1.comment)(message.body);\n            }\n            else if (message.body) {\n                body = message.body;\n            }\n            // Send internal message\n            await via.send({\n                to: address,\n                value,\n                bounce,\n                sendMode: message.sendMode,\n                init: neededInit,\n                body\n            });\n        },\n        open(contract) {\n            return (0, core_1.openContract)(contract, (args) => createProvider(client, args.address, args.init ?? null));\n        },\n        getTransactions(address, lt, hash, limit) {\n            return client.getTransactions(address, { limit: limit ?? 100, lt: lt.toString(), hash: hash.toString('base64'), inclusive: true });\n        }\n    };\n}\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,SAAS,GAAG,KAAK,CAAC;AAC1B,MAAMC,SAAS,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC1C,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAW,CAAC;AACnC,MAAMF,SAAS,CAAC;EACZI,WAAWA,CAACC,UAAU,EAAE;IACpB,IAAI,CAACA,UAAU,GAAG;MACdC,QAAQ,EAAED,UAAU,CAACC;IACzB,CAAC;IACD,IAAI,CAACC,GAAG,GAAG,IAAIN,SAAS,CAACO,OAAO,CAAC,IAAI,CAACH,UAAU,CAACC,QAAQ,EAAE;MACvDG,OAAO,EAAEJ,UAAU,CAACI,OAAO;MAC3BC,MAAM,EAAEL,UAAU,CAACK,MAAM;MACzBC,OAAO,EAAEN,UAAU,CAACO;IACxB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;EACI,MAAMC,UAAUA,CAACC,OAAO,EAAE;IACtB,OAAO,CAAC,MAAM,IAAI,CAACC,gBAAgB,CAACD,OAAO,CAAC,EAAEE,OAAO;EACzD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAMC,SAASA,CAACH,OAAO,EAAEI,IAAI,EAAEC,KAAK,GAAG,EAAE,EAAE;IACvC,IAAIC,GAAG,GAAG,MAAM,IAAI,CAACb,GAAG,CAACc,aAAa,CAACP,OAAO,EAAEI,IAAI,EAAEC,KAAK,CAAC;IAC5D,IAAIC,GAAG,CAACE,SAAS,KAAK,CAAC,EAAE;MACrB,MAAMC,KAAK,CAAC,+CAA+C,GAAGH,GAAG,CAACE,SAAS,CAAC;IAChF;IACA,OAAO;MAAEE,QAAQ,EAAEJ,GAAG,CAACI,QAAQ;MAAEL,KAAK,EAAEM,UAAU,CAACL,GAAG,CAACD,KAAK;IAAE,CAAC;EACnE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAME,aAAaA,CAACP,OAAO,EAAEI,IAAI,EAAEC,KAAK,GAAG,EAAE,EAAE;IAC3C,OAAO,IAAI,CAACF,SAAS,CAACH,OAAO,EAAEI,IAAI,EAAEC,KAAK,CAAC;EAC/C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAMO,kBAAkBA,CAACZ,OAAO,EAAEI,IAAI,EAAES,MAAM,GAAG,EAAE,EAAE;IACjD,IAAIP,GAAG,GAAG,MAAM,IAAI,CAACb,GAAG,CAACc,aAAa,CAACP,OAAO,EAAEI,IAAI,EAAES,MAAM,CAAC;IAC7D,OAAO;MAAEH,QAAQ,EAAEJ,GAAG,CAACI,QAAQ;MAAEL,KAAK,EAAEM,UAAU,CAACL,GAAG,CAACD,KAAK,CAAC;MAAEG,SAAS,EAAEF,GAAG,CAACE;IAAU,CAAC;EAC7F;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMM,sBAAsBA,CAACd,OAAO,EAAEI,IAAI,EAAEC,KAAK,GAAG,EAAE,EAAE;IACpD,OAAO,IAAI,CAACO,kBAAkB,CAACZ,OAAO,EAAEI,IAAI,EAAEC,KAAK,CAAC;EACxD;EACA;AACJ;AACA;AACA;EACI,MAAMU,eAAeA,CAACf,OAAO,EAAEgB,IAAI,EAAE;IACjC;IACA,IAAIC,EAAE,GAAG,MAAM,IAAI,CAACxB,GAAG,CAACsB,eAAe,CAACf,OAAO,EAAEgB,IAAI,CAAC;IACtD,IAAIV,GAAG,GAAG,EAAE;IACZ,KAAK,IAAIY,CAAC,IAAID,EAAE,EAAE;MACdX,GAAG,CAACa,IAAI,CAAC,CAAC,CAAC,EAAE9B,MAAM,CAAC+B,eAAe,EAAE/B,MAAM,CAACgC,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAACN,CAAC,CAACO,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC;IAC7G;IACA,OAAOpB,GAAG;EACd;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAMqB,cAAcA,CAAC3B,OAAO,EAAE4B,EAAE,EAAEC,IAAI,EAAE;IACpC,IAAIvB,GAAG,GAAG,MAAM,IAAI,CAACb,GAAG,CAACkC,cAAc,CAAC3B,OAAO,EAAE4B,EAAE,EAAEC,IAAI,CAAC;IAC1D,IAAIvB,GAAG,EAAE;MACL,OAAO,CAAC,CAAC,EAAEjB,MAAM,CAAC+B,eAAe,EAAE/B,MAAM,CAACgC,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAClB,GAAG,CAACmB,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC;IAC5G,CAAC,MACI;MACD,OAAO,IAAI;IACf;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAMI,iBAAiBA,CAACC,MAAM,EAAEC,WAAW,EAAEC,UAAU,EAAE;IACrD,IAAI3B,GAAG,GAAG,MAAM,IAAI,CAACb,GAAG,CAACqC,iBAAiB,CAACC,MAAM,EAAEC,WAAW,EAAEC,UAAU,CAAC;IAC3E,OAAO,CAAC,CAAC,EAAE5C,MAAM,CAAC+B,eAAe,EAAE/B,MAAM,CAACgC,IAAI,CAACa,UAAU,CAAC5B,GAAG,CAACmB,IAAI,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC;EACrF;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAMS,iBAAiBA,CAACJ,MAAM,EAAEC,WAAW,EAAEC,UAAU,EAAE;IACrD,IAAI3B,GAAG,GAAG,MAAM,IAAI,CAACb,GAAG,CAAC0C,iBAAiB,CAACJ,MAAM,EAAEC,WAAW,EAAEC,UAAU,CAAC;IAC3E,OAAO,CAAC,CAAC,EAAE5C,MAAM,CAAC+B,eAAe,EAAE/B,MAAM,CAACgC,IAAI,CAACa,UAAU,CAAC5B,GAAG,CAACmB,IAAI,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC;EACrF;EACA;AACJ;AACA;AACA;EACI,MAAMU,kBAAkBA,CAAA,EAAG;IACvB,IAAIlB,CAAC,GAAG,MAAM,IAAI,CAACzB,GAAG,CAAC2C,kBAAkB,CAAC,CAAC;IAC3C,OAAO;MACHC,SAAS,EAAEnB,CAAC,CAACoB,IAAI,CAACD,SAAS;MAC3BE,KAAK,EAAErB,CAAC,CAACsB,IAAI,CAACD,KAAK;MACnBE,SAAS,EAAEvB,CAAC,CAACoB,IAAI,CAACI,KAAK;MACvBC,WAAW,EAAEzB,CAAC,CAACsB,IAAI,CAACE;IACxB,CAAC;EACL;EACA;AACJ;AACA;AACA;EACI,MAAME,kBAAkBA,CAACF,KAAK,EAAE;IAC5B,IAAIxB,CAAC,GAAG,MAAM,IAAI,CAACzB,GAAG,CAACoD,SAAS,CAACH,KAAK,CAAC;IACvC,OAAOxB,CAAC,CAAC4B,GAAG,CAAEC,CAAC,KAAM;MACjBV,SAAS,EAAEU,CAAC,CAACV,SAAS;MACtBE,KAAK,EAAEQ,CAAC,CAACR,KAAK;MACdG,KAAK,EAAEK,CAAC,CAACL;IACb,CAAC,CAAC,CAAC;EACP;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMM,oBAAoBA,CAACX,SAAS,EAAEK,KAAK,EAAEH,KAAK,EAAE;IAChD,IAAItB,EAAE,GAAG,MAAM,IAAI,CAACxB,GAAG,CAACwD,oBAAoB,CAACZ,SAAS,EAAEK,KAAK,EAAEH,KAAK,CAAC;IACrE,IAAItB,EAAE,CAACiC,UAAU,EAAE;MACf,MAAMzC,KAAK,CAAC,aAAa,CAAC;IAC9B;IACA,OAAOQ,EAAE,CAACkC,YAAY,CAACL,GAAG,CAAEM,CAAC,KAAM;MAC/BC,OAAO,EAAEhE,MAAM,CAACiE,OAAO,CAACC,QAAQ,CAACH,CAAC,CAACC,OAAO,CAAC;MAC3CzB,EAAE,EAAEwB,CAAC,CAACxB,EAAE;MACRC,IAAI,EAAEuB,CAAC,CAACvB;IACZ,CAAC,CAAC,CAAC;EACP;EACA;AACJ;AACA;AACA;EACI,MAAM2B,WAAWA,CAACC,GAAG,EAAE;IACnB,MAAMC,GAAG,GAAG,CAAC,CAAC,EAAErE,MAAM,CAACsE,SAAS,EAAE,CAAC,CAC9BC,KAAK,CAAC,CAAC,CAAC,EAAEvE,MAAM,CAACwE,YAAY,EAAEJ,GAAG,CAAC,CAAC,CACpCK,OAAO,CAAC,CAAC,CACTC,KAAK,CAAC,CAAC;IACZ,MAAM,IAAI,CAACtE,GAAG,CAACuE,OAAO,CAACN,GAAG,CAAC;EAC/B;EACA;AACJ;AACA;AACA;EACI,MAAMO,QAAQA,CAACR,GAAG,EAAE;IAChB,MAAM,IAAI,CAAChE,GAAG,CAACuE,OAAO,CAACP,GAAG,CAAC;EAC/B;EACA;AACJ;AACA;AACA;AACA;EACI,MAAMS,0BAA0BA,CAAClE,OAAO,EAAEmE,IAAI,EAAE;IAC5C,OAAO,MAAM,IAAI,CAAC1E,GAAG,CAAC2E,WAAW,CAACpE,OAAO,EAAE;MAAEqE,IAAI,EAAEF,IAAI,CAACE,IAAI;MAAEC,QAAQ,EAAEH,IAAI,CAACG,QAAQ;MAAEC,QAAQ,EAAEJ,IAAI,CAACI,QAAQ;MAAEC,eAAe,EAAEL,IAAI,CAACK;IAAgB,CAAC,CAAC;EAC5J;EACA;AACJ;AACA;AACA;AACA;EACI,MAAMC,mBAAmBA,CAACC,QAAQ,EAAEjB,GAAG,EAAE;IACrC,IAAI,OAAM,IAAI,CAACkB,kBAAkB,CAACD,QAAQ,CAAC1E,OAAO,CAAC,KAAI,CAAC0E,QAAQ,CAACpC,IAAI,EAAE;MACnE,MAAMsC,OAAO,GAAG,CAAC,CAAC,EAAEvF,MAAM,CAACwF,QAAQ,EAAE;QACjCC,EAAE,EAAEJ,QAAQ,CAAC1E,OAAO;QACpBqE,IAAI,EAAEZ;MACV,CAAC,CAAC;MACF,MAAM,IAAI,CAACD,WAAW,CAACoB,OAAO,CAAC;IACnC,CAAC,MACI;MACD,MAAMA,OAAO,GAAG,CAAC,CAAC,EAAEvF,MAAM,CAACwF,QAAQ,EAAE;QACjCC,EAAE,EAAEJ,QAAQ,CAAC1E,OAAO;QACpBsC,IAAI,EAAEoC,QAAQ,CAACpC,IAAI;QACnB+B,IAAI,EAAEZ;MACV,CAAC,CAAC;MACF,MAAM,IAAI,CAACD,WAAW,CAACoB,OAAO,CAAC;IACnC;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI,MAAMD,kBAAkBA,CAAC3E,OAAO,EAAE;IAC9B,OAAO,CAAC,MAAM,IAAI,CAACC,gBAAgB,CAACD,OAAO,CAAC,EAAE+E,KAAK,KAAK,QAAQ;EACpE;EACA;AACJ;AACA;AACA;EACI,MAAM9E,gBAAgBA,CAACD,OAAO,EAAE;IAC5B,IAAIgF,IAAI,GAAG,MAAM,IAAI,CAACvF,GAAG,CAACwF,qBAAqB,CAACjF,OAAO,CAAC;IACxD,IAAIE,OAAO,GAAGgF,MAAM,CAACF,IAAI,CAAC9E,OAAO,CAAC;IAClC,IAAI6E,KAAK,GAAGC,IAAI,CAACD,KAAK;IACtB,OAAO;MACH7E,OAAO;MACP6E,KAAK;MACLI,IAAI,EAAEH,IAAI,CAACG,IAAI,KAAK,EAAE,GAAG5D,MAAM,CAACC,IAAI,CAACwD,IAAI,CAACG,IAAI,EAAE,QAAQ,CAAC,GAAG,IAAI;MAChE1D,IAAI,EAAEuD,IAAI,CAACvD,IAAI,KAAK,EAAE,GAAGF,MAAM,CAACC,IAAI,CAACwD,IAAI,CAACvD,IAAI,EAAE,QAAQ,CAAC,GAAG,IAAI;MAChE2D,eAAe,EAAEJ,IAAI,CAACK,mBAAmB,CAACzD,EAAE,KAAK,GAAG,GAAG;QACnDA,EAAE,EAAEoD,IAAI,CAACK,mBAAmB,CAACzD,EAAE;QAC/BC,IAAI,EAAEmD,IAAI,CAACK,mBAAmB,CAACxD;MACnC,CAAC,GAAG,IAAI;MACRyD,OAAO,EAAE;QACLjD,SAAS,EAAE2C,IAAI,CAACO,QAAQ,CAAClD,SAAS;QAClCE,KAAK,EAAEyC,IAAI,CAACO,QAAQ,CAAChD,KAAK;QAC1BG,KAAK,EAAEsC,IAAI,CAACO,QAAQ,CAAC7C;MACzB,CAAC;MACD8C,UAAU,EAAER,IAAI,CAACS;IACrB,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;EACIC,IAAIA,CAACjC,GAAG,EAAE;IACN,OAAO,CAAC,CAAC,EAAEpE,MAAM,CAACsG,YAAY,EAAElC,GAAG,EAAGU,IAAI,IAAKyB,cAAc,CAAC,IAAI,EAAEzB,IAAI,CAACnE,OAAO,EAAEmE,IAAI,CAAC7B,IAAI,CAAC,CAAC;EACjG;EACA;AACJ;AACA;AACA;AACA;AACA;EACIuD,QAAQA,CAAC7F,OAAO,EAAEsC,IAAI,EAAE;IACpB,OAAOsD,cAAc,CAAC,IAAI,EAAE5F,OAAO,EAAEsC,IAAI,IAAI,IAAI,CAAC;EACtD;AACJ;AACAtD,OAAO,CAACE,SAAS,GAAGA,SAAS;AAC7B,SAAS4G,eAAeA,CAACC,CAAC,EAAE;EACxB,QAAQA,CAAC,CAAC,OAAO,CAAC;IACd,KAAK,sBAAsB;MACvB,OAAO;QAAEC,IAAI,EAAE,KAAK;QAAE/G,KAAK,EAAEiG,MAAM,CAACa,CAAC,CAACE,MAAM,CAACA,MAAM;MAAE,CAAC;IAC1D,KAAK,oBAAoB;MACrB,OAAO;QAAED,IAAI,EAAE,MAAM;QAAEE,IAAI,EAAE7G,MAAM,CAACgC,IAAI,CAACa,UAAU,CAAC6D,CAAC,CAACG,IAAI;MAAE,CAAC;IACjE,KAAK,qBAAqB;MACtB,OAAO;QAAEF,IAAI,EAAE,OAAO;QAAEG,KAAK,EAAEJ,CAAC,CAACK,KAAK,CAACC,QAAQ,CAACvD,GAAG,CAACgD,eAAe;MAAE,CAAC;IAC1E,KAAK,oBAAoB;MACrB,OAAO;QAAEE,IAAI,EAAE,MAAM;QAAEG,KAAK,EAAEJ,CAAC,CAACO,IAAI,CAACD,QAAQ,CAACvD,GAAG,CAACgD,eAAe;MAAE,CAAC;IACxE;MACI,MAAMrF,KAAK,CAAC,yBAAyB,GAAGsF,CAAC,CAAC,OAAO,CAAC,CAAC;EAC3D;AACJ;AACA,SAASQ,cAAcA,CAACR,CAAC,EAAE;EACvB,IAAIA,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;IAChB,IAAIS,GAAG,GAAGT,CAAC,CAAC,CAAC,CAAC;IACd,IAAIS,GAAG,CAACC,UAAU,CAAC,GAAG,CAAC,EAAE;MACrB,OAAO;QAAET,IAAI,EAAE,KAAK;QAAE/G,KAAK,EAAE,CAACiG,MAAM,CAACsB,GAAG,CAACE,KAAK,CAAC,CAAC,CAAC;MAAE,CAAC;IACxD,CAAC,MACI;MACD,OAAO;QAAEV,IAAI,EAAE,KAAK;QAAE/G,KAAK,EAAEiG,MAAM,CAACsB,GAAG;MAAE,CAAC;IAC9C;EACJ,CAAC,MACI,IAAIT,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;IACtB,OAAO;MAAEC,IAAI,EAAE;IAAO,CAAC;EAC3B,CAAC,MACI,IAAID,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;IACtB,OAAO;MAAEC,IAAI,EAAE,MAAM;MAAEE,IAAI,EAAE7G,MAAM,CAACgC,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAACuE,CAAC,CAAC,CAAC,CAAC,CAACY,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;IAAE,CAAC;EAC5F,CAAC,MACI,IAAIZ,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;IACvB,OAAO;MAAEC,IAAI,EAAE,OAAO;MAAEE,IAAI,EAAE7G,MAAM,CAACgC,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAACuE,CAAC,CAAC,CAAC,CAAC,CAACY,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;IAAE,CAAC;EAC7F,CAAC,MACI,IAAIZ,CAAC,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE;IACzB,OAAO;MAAEC,IAAI,EAAE,SAAS;MAAEE,IAAI,EAAE7G,MAAM,CAACgC,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAACuE,CAAC,CAAC,CAAC,CAAC,CAACY,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;IAAE,CAAC;EAC/F,CAAC,MACI,IAAIZ,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,IAAIA,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;IAC1C;IACA,IAAIA,CAAC,CAAC,CAAC,CAAC,CAACM,QAAQ,CAACO,MAAM,KAAK,CAAC,EAAE;MAC5B,OAAO;QAAEZ,IAAI,EAAE;MAAO,CAAC;IAC3B;IACA,OAAO;MACHA,IAAI,EAAED,CAAC,CAAC,CAAC,CAAC;MACVI,KAAK,EAAEJ,CAAC,CAAC,CAAC,CAAC,CAACM,QAAQ,CAACvD,GAAG,CAACgD,eAAe;IAC5C,CAAC;EACL,CAAC,MACI;IACD,MAAMrF,KAAK,CAAC,+BAA+B,GAAGsF,CAAC,CAAC,CAAC,CAAC,CAAC;EACvD;AACJ;AACA,SAASpF,UAAUA,CAAC8C,GAAG,EAAE;EACrB,IAAIpD,KAAK,GAAG,EAAE;EACd,KAAK,IAAI0F,CAAC,IAAItC,GAAG,EAAE;IACfpD,KAAK,CAACc,IAAI,CAACoF,cAAc,CAACR,CAAC,CAAC,CAAC;EACjC;EACA,OAAO,IAAI1G,MAAM,CAACwH,WAAW,CAACxG,KAAK,CAAC;AACxC;AACA,SAASuF,cAAcA,CAACkB,MAAM,EAAE9G,OAAO,EAAEsC,IAAI,EAAE;EAC3C,OAAO;IACH,MAAMyE,QAAQA,CAAA,EAAG;MACb,IAAIhC,KAAK,GAAG,MAAM+B,MAAM,CAAC7G,gBAAgB,CAACD,OAAO,CAAC;MAClD,IAAIE,OAAO,GAAG6E,KAAK,CAAC7E,OAAO;MAC3B,IAAIsC,IAAI,GAAGuC,KAAK,CAACK,eAAe,GAAG;QAAExD,EAAE,EAAEsD,MAAM,CAACH,KAAK,CAACK,eAAe,CAACxD,EAAE,CAAC;QAAEC,IAAI,EAAEN,MAAM,CAACC,IAAI,CAACuD,KAAK,CAACK,eAAe,CAACvD,IAAI,EAAE,QAAQ;MAAE,CAAC,GAAG,IAAI;MAC3I,IAAImF,OAAO;MACX,IAAIjC,KAAK,CAACA,KAAK,KAAK,QAAQ,EAAE;QAC1BiC,OAAO,GAAG;UACNhB,IAAI,EAAE,QAAQ;UACdb,IAAI,EAAEJ,KAAK,CAACI,IAAI,GAAGJ,KAAK,CAACI,IAAI,GAAG,IAAI;UACpC1D,IAAI,EAAEsD,KAAK,CAACtD,IAAI,GAAGsD,KAAK,CAACtD,IAAI,GAAG;QACpC,CAAC;MACL,CAAC,MACI,IAAIsD,KAAK,CAACA,KAAK,KAAK,eAAe,EAAE;QACtCiC,OAAO,GAAG;UACNhB,IAAI,EAAE;QACV,CAAC;MACL,CAAC,MACI,IAAIjB,KAAK,CAACA,KAAK,KAAK,QAAQ,EAAE;QAC/BiC,OAAO,GAAG;UACNhB,IAAI,EAAE,QAAQ;UACdiB,SAAS,EAAE1F,MAAM,CAAC2F,KAAK,CAAC,CAAC;QAC7B,CAAC;MACL,CAAC,MACI;QACD,MAAMzG,KAAK,CAAC,mBAAmB,CAAC;MACpC;MACA,OAAO;QACHP,OAAO;QACPsC,IAAI;QACJuC,KAAK,EAAEiC;MACX,CAAC;IACL,CAAC;IACD,MAAMG,GAAGA,CAAC/G,IAAI,EAAE+D,IAAI,EAAE;MAClB,IAAIiD,MAAM,GAAG,MAAMN,MAAM,CAACvG,aAAa,CAACP,OAAO,EAAEI,IAAI,EAAE+D,IAAI,CAAC;MAC5D,OAAO;QAAE9D,KAAK,EAAE+G,MAAM,CAAC/G;MAAM,CAAC;IAClC,CAAC;IACD,MAAMwE,QAAQA,CAACD,OAAO,EAAE;MACpB;MACA;MACA;MACA,IAAIyC,UAAU,GAAG,IAAI;MACrB,IAAI/E,IAAI,IAAI,EAAC,MAAMwE,MAAM,CAACnC,kBAAkB,CAAC3E,OAAO,CAAC,GAAE;QACnDqH,UAAU,GAAG/E,IAAI;MACrB;MACA;MACA;MACA;MACA,MAAMgF,GAAG,GAAG,CAAC,CAAC,EAAEjI,MAAM,CAACwF,QAAQ,EAAE;QAC7BC,EAAE,EAAE9E,OAAO;QACXsC,IAAI,EAAE+E,UAAU;QAChBhD,IAAI,EAAEO;MACV,CAAC,CAAC;MACF,IAAIlB,GAAG,GAAG,CAAC,CAAC,EAAErE,MAAM,CAACsE,SAAS,EAAE,CAAC,CAC5BC,KAAK,CAAC,CAAC,CAAC,EAAEvE,MAAM,CAACwE,YAAY,EAAEyD,GAAG,CAAC,CAAC,CACpCxD,OAAO,CAAC,CAAC,CACTC,KAAK,CAAC,CAAC;MACZ,MAAM+C,MAAM,CAAC7C,QAAQ,CAACP,GAAG,CAAC;IAC9B,CAAC;IACD,MAAM6D,QAAQA,CAACC,GAAG,EAAE5C,OAAO,EAAE;MACzB;MACA,IAAIyC,UAAU,GAAG,IAAI;MACrB,IAAI/E,IAAI,IAAK,EAAC,MAAMwE,MAAM,CAACnC,kBAAkB,CAAC3E,OAAO,CAAC,CAAC,EAAE;QACrDqH,UAAU,GAAG/E,IAAI;MACrB;MACA;MACA,IAAImF,MAAM,GAAG,IAAI;MACjB,IAAI7C,OAAO,CAAC6C,MAAM,KAAK,IAAI,IAAI7C,OAAO,CAAC6C,MAAM,KAAKC,SAAS,EAAE;QACzDD,MAAM,GAAG7C,OAAO,CAAC6C,MAAM;MAC3B;MACA;MACA,IAAIxI,KAAK;MACT,IAAI,OAAO2F,OAAO,CAAC3F,KAAK,KAAK,QAAQ,EAAE;QACnCA,KAAK,GAAG,CAAC,CAAC,EAAEI,MAAM,CAACsI,MAAM,EAAE/C,OAAO,CAAC3F,KAAK,CAAC;MAC7C,CAAC,MACI;QACDA,KAAK,GAAG2F,OAAO,CAAC3F,KAAK;MACzB;MACA;MACA,IAAIoF,IAAI,GAAG,IAAI;MACf,IAAI,OAAOO,OAAO,CAACP,IAAI,KAAK,QAAQ,EAAE;QAClCA,IAAI,GAAG,CAAC,CAAC,EAAEhF,MAAM,CAACuI,OAAO,EAAEhD,OAAO,CAACP,IAAI,CAAC;MAC5C,CAAC,MACI,IAAIO,OAAO,CAACP,IAAI,EAAE;QACnBA,IAAI,GAAGO,OAAO,CAACP,IAAI;MACvB;MACA;MACA,MAAMmD,GAAG,CAACK,IAAI,CAAC;QACX/C,EAAE,EAAE9E,OAAO;QACXf,KAAK;QACLwI,MAAM;QACNK,QAAQ,EAAElD,OAAO,CAACkD,QAAQ;QAC1BxF,IAAI,EAAE+E,UAAU;QAChBhD;MACJ,CAAC,CAAC;IACN,CAAC;IACDqB,IAAIA,CAAChB,QAAQ,EAAE;MACX,OAAO,CAAC,CAAC,EAAErF,MAAM,CAACsG,YAAY,EAAEjB,QAAQ,EAAGP,IAAI,IAAKyB,cAAc,CAACkB,MAAM,EAAE3C,IAAI,CAACnE,OAAO,EAAEmE,IAAI,CAAC7B,IAAI,IAAI,IAAI,CAAC,CAAC;IAChH,CAAC;IACDvB,eAAeA,CAACf,OAAO,EAAE4B,EAAE,EAAEC,IAAI,EAAEkG,KAAK,EAAE;MACtC,OAAOjB,MAAM,CAAC/F,eAAe,CAACf,OAAO,EAAE;QAAE+H,KAAK,EAAEA,KAAK,IAAI,GAAG;QAAEnG,EAAE,EAAEA,EAAE,CAACoG,QAAQ,CAAC,CAAC;QAAEnG,IAAI,EAAEA,IAAI,CAACmG,QAAQ,CAAC,QAAQ,CAAC;QAAEC,SAAS,EAAE;MAAK,CAAC,CAAC;IACtI;EACJ,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}