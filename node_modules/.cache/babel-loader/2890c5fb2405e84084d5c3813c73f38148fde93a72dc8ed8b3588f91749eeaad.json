{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.topologicalSort = void 0;\nfunction topologicalSort(src) {\n  let pending = [src];\n  let allCells = new Map();\n  let notPermCells = new Set();\n  let sorted = [];\n  while (pending.length > 0) {\n    const cells = [...pending];\n    pending = [];\n    for (let cell of cells) {\n      const hash = cell.hash().toString('hex');\n      if (allCells.has(hash)) {\n        continue;\n      }\n      notPermCells.add(hash);\n      allCells.set(hash, {\n        cell: cell,\n        refs: cell.refs.map(v => v.hash().toString('hex'))\n      });\n      for (let r of cell.refs) {\n        pending.push(r);\n      }\n    }\n  }\n  let tempMark = new Set();\n  function visit(hash) {\n    if (!notPermCells.has(hash)) {\n      return;\n    }\n    if (tempMark.has(hash)) {\n      throw Error('Not a DAG');\n    }\n    tempMark.add(hash);\n    let refs = allCells.get(hash).refs;\n    for (let ci = refs.length - 1; ci >= 0; ci--) {\n      visit(refs[ci]);\n    }\n    sorted.push(hash);\n    tempMark.delete(hash);\n    notPermCells.delete(hash);\n  }\n  while (notPermCells.size > 0) {\n    const id = Array.from(notPermCells)[0];\n    visit(id);\n  }\n  let indexes = new Map();\n  for (let i = 0; i < sorted.length; i++) {\n    indexes.set(sorted[sorted.length - i - 1], i);\n  }\n  let result = [];\n  for (let i = sorted.length - 1; i >= 0; i--) {\n    let ent = sorted[i];\n    const rrr = allCells.get(ent);\n    result.push({\n      cell: rrr.cell,\n      refs: rrr.refs.map(v => indexes.get(v))\n    });\n  }\n  return result;\n}\nexports.topologicalSort = topologicalSort;","map":{"version":3,"names":["Object","defineProperty","exports","value","topologicalSort","src","pending","allCells","Map","notPermCells","Set","sorted","length","cells","cell","hash","toString","has","add","set","refs","map","v","r","push","tempMark","visit","Error","get","ci","delete","size","id","Array","from","indexes","i","result","ent","rrr"],"sources":["C:/Users/adams/Downloads/GLL/slotpot/node_modules/@ton/core/dist/boc/cell/utils/topologicalSort.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.topologicalSort = void 0;\nfunction topologicalSort(src) {\n    let pending = [src];\n    let allCells = new Map();\n    let notPermCells = new Set();\n    let sorted = [];\n    while (pending.length > 0) {\n        const cells = [...pending];\n        pending = [];\n        for (let cell of cells) {\n            const hash = cell.hash().toString('hex');\n            if (allCells.has(hash)) {\n                continue;\n            }\n            notPermCells.add(hash);\n            allCells.set(hash, { cell: cell, refs: cell.refs.map((v) => v.hash().toString('hex')) });\n            for (let r of cell.refs) {\n                pending.push(r);\n            }\n        }\n    }\n    let tempMark = new Set();\n    function visit(hash) {\n        if (!notPermCells.has(hash)) {\n            return;\n        }\n        if (tempMark.has(hash)) {\n            throw Error('Not a DAG');\n        }\n        tempMark.add(hash);\n        let refs = allCells.get(hash).refs;\n        for (let ci = refs.length - 1; ci >= 0; ci--) {\n            visit(refs[ci]);\n        }\n        sorted.push(hash);\n        tempMark.delete(hash);\n        notPermCells.delete(hash);\n    }\n    while (notPermCells.size > 0) {\n        const id = Array.from(notPermCells)[0];\n        visit(id);\n    }\n    let indexes = new Map();\n    for (let i = 0; i < sorted.length; i++) {\n        indexes.set(sorted[sorted.length - i - 1], i);\n    }\n    let result = [];\n    for (let i = sorted.length - 1; i >= 0; i--) {\n        let ent = sorted[i];\n        const rrr = allCells.get(ent);\n        result.push({ cell: rrr.cell, refs: rrr.refs.map((v) => indexes.get(v)) });\n    }\n    return result;\n}\nexports.topologicalSort = topologicalSort;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}