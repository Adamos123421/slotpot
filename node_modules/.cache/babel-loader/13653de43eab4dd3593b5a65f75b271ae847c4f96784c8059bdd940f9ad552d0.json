{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exoticPruned = void 0;\nconst BitReader_1 = require(\"../BitReader\");\nconst LevelMask_1 = require(\"./LevelMask\");\nfunction exoticPruned(bits, refs) {\n  let reader = new BitReader_1.BitReader(bits);\n  // Check type\n  let type = reader.loadUint(8);\n  if (type !== 1) {\n    throw new Error(`Pruned branch cell must have type 1, got \"${type}\"`);\n  }\n  // Check refs\n  if (refs.length !== 0) {\n    throw new Error(`Pruned Branch cell can't has refs, got \"${refs.length}\"`);\n  }\n  // Resolve cell\n  let mask;\n  if (bits.length === 280) {\n    // Special case for config proof\n    // This test proof is generated in the moment of voting for a slashing\n    // it seems that tools generate it incorrectly and therefore doesn't have mask in it\n    // so we need to hardcode it equal to 1\n    mask = new LevelMask_1.LevelMask(1);\n  } else {\n    // Check level\n    mask = new LevelMask_1.LevelMask(reader.loadUint(8));\n    if (mask.level < 1 || mask.level > 3) {\n      throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got \"${mask.level}/${mask.value}\"`);\n    }\n    // Read pruned\n    const size = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 /* Hash */ + 16 /* Depth */);\n    if (bits.length !== size) {\n      throw new Error(`Pruned branch cell must have exactly ${size} bits, got \"${bits.length}\"`);\n    }\n  }\n  // Read pruned\n  let pruned = [];\n  let hashes = [];\n  let depths = [];\n  for (let i = 0; i < mask.level; i++) {\n    hashes.push(reader.loadBuffer(32));\n  }\n  for (let i = 0; i < mask.level; i++) {\n    depths.push(reader.loadUint(16));\n  }\n  for (let i = 0; i < mask.level; i++) {\n    pruned.push({\n      depth: depths[i],\n      hash: hashes[i]\n    });\n  }\n  return {\n    mask: mask.value,\n    pruned\n  };\n}\nexports.exoticPruned = exoticPruned;","map":{"version":3,"names":["Object","defineProperty","exports","value","exoticPruned","BitReader_1","require","LevelMask_1","bits","refs","reader","BitReader","type","loadUint","Error","length","mask","LevelMask","level","size","apply","hashCount","pruned","hashes","depths","i","push","loadBuffer","depth","hash"],"sources":["C:/Users/adams/OneDrive/Desktop/Work/slotpot/node_modules/@ton/core/dist/boc/cell/exoticPruned.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) Whales Corp.\n * All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.exoticPruned = void 0;\nconst BitReader_1 = require(\"../BitReader\");\nconst LevelMask_1 = require(\"./LevelMask\");\nfunction exoticPruned(bits, refs) {\n    let reader = new BitReader_1.BitReader(bits);\n    // Check type\n    let type = reader.loadUint(8);\n    if (type !== 1) {\n        throw new Error(`Pruned branch cell must have type 1, got \"${type}\"`);\n    }\n    // Check refs\n    if (refs.length !== 0) {\n        throw new Error(`Pruned Branch cell can't has refs, got \"${refs.length}\"`);\n    }\n    // Resolve cell\n    let mask;\n    if (bits.length === 280) {\n        // Special case for config proof\n        // This test proof is generated in the moment of voting for a slashing\n        // it seems that tools generate it incorrectly and therefore doesn't have mask in it\n        // so we need to hardcode it equal to 1\n        mask = new LevelMask_1.LevelMask(1);\n    }\n    else {\n        // Check level\n        mask = new LevelMask_1.LevelMask(reader.loadUint(8));\n        if (mask.level < 1 || mask.level > 3) {\n            throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got \"${mask.level}/${mask.value}\"`);\n        }\n        // Read pruned\n        const size = 8 + 8 + (mask.apply(mask.level - 1).hashCount * (256 /* Hash */ + 16 /* Depth */));\n        if (bits.length !== size) {\n            throw new Error(`Pruned branch cell must have exactly ${size} bits, got \"${bits.length}\"`);\n        }\n    }\n    // Read pruned\n    let pruned = [];\n    let hashes = [];\n    let depths = [];\n    for (let i = 0; i < mask.level; i++) {\n        hashes.push(reader.loadBuffer(32));\n    }\n    for (let i = 0; i < mask.level; i++) {\n        depths.push(reader.loadUint(16));\n    }\n    for (let i = 0; i < mask.level; i++) {\n        pruned.push({\n            depth: depths[i],\n            hash: hashes[i]\n        });\n    }\n    return {\n        mask: mask.value,\n        pruned\n    };\n}\nexports.exoticPruned = exoticPruned;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,YAAY,GAAG,KAAK,CAAC;AAC7B,MAAMC,WAAW,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC3C,MAAMC,WAAW,GAAGD,OAAO,CAAC,aAAa,CAAC;AAC1C,SAASF,YAAYA,CAACI,IAAI,EAAEC,IAAI,EAAE;EAC9B,IAAIC,MAAM,GAAG,IAAIL,WAAW,CAACM,SAAS,CAACH,IAAI,CAAC;EAC5C;EACA,IAAII,IAAI,GAAGF,MAAM,CAACG,QAAQ,CAAC,CAAC,CAAC;EAC7B,IAAID,IAAI,KAAK,CAAC,EAAE;IACZ,MAAM,IAAIE,KAAK,CAAC,6CAA6CF,IAAI,GAAG,CAAC;EACzE;EACA;EACA,IAAIH,IAAI,CAACM,MAAM,KAAK,CAAC,EAAE;IACnB,MAAM,IAAID,KAAK,CAAC,2CAA2CL,IAAI,CAACM,MAAM,GAAG,CAAC;EAC9E;EACA;EACA,IAAIC,IAAI;EACR,IAAIR,IAAI,CAACO,MAAM,KAAK,GAAG,EAAE;IACrB;IACA;IACA;IACA;IACAC,IAAI,GAAG,IAAIT,WAAW,CAACU,SAAS,CAAC,CAAC,CAAC;EACvC,CAAC,MACI;IACD;IACAD,IAAI,GAAG,IAAIT,WAAW,CAACU,SAAS,CAACP,MAAM,CAACG,QAAQ,CAAC,CAAC,CAAC,CAAC;IACpD,IAAIG,IAAI,CAACE,KAAK,GAAG,CAAC,IAAIF,IAAI,CAACE,KAAK,GAAG,CAAC,EAAE;MAClC,MAAM,IAAIJ,KAAK,CAAC,wDAAwDE,IAAI,CAACE,KAAK,IAAIF,IAAI,CAACb,KAAK,GAAG,CAAC;IACxG;IACA;IACA,MAAMgB,IAAI,GAAG,CAAC,GAAG,CAAC,GAAIH,IAAI,CAACI,KAAK,CAACJ,IAAI,CAACE,KAAK,GAAG,CAAC,CAAC,CAACG,SAAS,IAAI,GAAG,CAAC,aAAa,EAAE,CAAC,YAAa;IAC/F,IAAIb,IAAI,CAACO,MAAM,KAAKI,IAAI,EAAE;MACtB,MAAM,IAAIL,KAAK,CAAC,wCAAwCK,IAAI,eAAeX,IAAI,CAACO,MAAM,GAAG,CAAC;IAC9F;EACJ;EACA;EACA,IAAIO,MAAM,GAAG,EAAE;EACf,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,MAAM,GAAG,EAAE;EACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,IAAI,CAACE,KAAK,EAAEO,CAAC,EAAE,EAAE;IACjCF,MAAM,CAACG,IAAI,CAAChB,MAAM,CAACiB,UAAU,CAAC,EAAE,CAAC,CAAC;EACtC;EACA,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,IAAI,CAACE,KAAK,EAAEO,CAAC,EAAE,EAAE;IACjCD,MAAM,CAACE,IAAI,CAAChB,MAAM,CAACG,QAAQ,CAAC,EAAE,CAAC,CAAC;EACpC;EACA,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,IAAI,CAACE,KAAK,EAAEO,CAAC,EAAE,EAAE;IACjCH,MAAM,CAACI,IAAI,CAAC;MACRE,KAAK,EAAEJ,MAAM,CAACC,CAAC,CAAC;MAChBI,IAAI,EAAEN,MAAM,CAACE,CAAC;IAClB,CAAC,CAAC;EACN;EACA,OAAO;IACHT,IAAI,EAAEA,IAAI,CAACb,KAAK;IAChBmB;EACJ,CAAC;AACL;AACApB,OAAO,CAACE,YAAY,GAAGA,YAAY","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}